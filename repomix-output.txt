This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added.

================================================================
Directory Structure
================================================================
.cursor/
  rules/
    github-api.mdc
config/
  native-modules.json
  README.md
  UserInstructions.md
electron/
  __tests__/
    main.path.test.js
  utils/
    treeSitterTest.js
    treeSitterUtils.js
    treeSitterUtils.ts
  excluded-files.js
  main.js
  preload.js
  README.md
src/
  __tests__/
    utils/
      theme.test.ts
    buildWorkflow.test.ts
    setup.ts
  assets/
    favicon.svg
  components/
    __tests__/
      IgnorePatterns.test.tsx
    ui/
      Button/
        Button.module.css
        Button.tsx
        index.ts
      ButtonGroup/
        ButtonGroup.module.css
        ButtonGroup.tsx
        index.ts
      Card/
        Card.module.css
        Card.tsx
        index.ts
      Dialog/
        Dialog.module.css
        Dialog.tsx
        index.ts
      Dropdown/
        Dropdown.module.css
        Dropdown.tsx
        index.ts
      DropdownMenu/
        DropdownAdapter.tsx
        DropdownMenu.module.css
        DropdownMenu.tsx
        index.ts
        TemplateDropdownAdapter.tsx
      Input/
        index.ts
        Input.module.css
        Input.tsx
      Switch/
        index.ts
        Switch.module.css
        Switch.tsx
      Tabs/
        index.ts
        Tabs.module.css
        Tabs.tsx
        TabsContent.tsx
        TabsList.tsx
        TabsTrigger.tsx
        useTabs.ts
      Toast/
        index.ts
        Toast.module.css
        Toast.tsx
        toastUtils.ts
      ConfirmationDialog.tsx
      index.ts
      TabsComponents.tsx
    ControlContainer.module.css
    ControlContainer.tsx
    ErrorBoundary.tsx
    FileCard.module.css
    FileCard.tsx
    FileList.module.css
    FileList.tsx
    FileTreeHeader.module.css
    FileTreeHeader.tsx
    GuideModal.module.css
    GuideModal.tsx
    IgnorePatterns.module.css
    IgnorePatterns.tsx
    SearchBar.module.css
    SearchBar.tsx
    Sidebar.module.css
    Sidebar.module.css.d.ts
    Sidebar.tsx
    ThemeToggle.module.css
    ThemeToggle.tsx
    TreeItem.module.css
    TreeItem.tsx
    UserInstructionsWithTemplates.module.css
    UserInstructionsWithTemplates.tsx
  constants/
    api.ts
    outputFormats.ts
    promptTemplates.ts
    theme.ts
  context/
    ThemeContext.tsx
    ThemeContextType.ts
  hooks/
    useTheme.ts
  renderer/
    components/
      FileExplorer/
        FileSystemManager.jsx
  styles/
    globals.css
    index.css
  types/
    css.d.ts
    electron.d.ts
    FileInfo.ts
    FileTypes.ts
    GlobalPatternsState.ts
    index.ts
    ModelTypes.ts
    SortOrder.ts
  utils/
    cn.ts
    compressionUtils.ts
    create-variants.ts
    formatters.ts
    modelUtils.ts
    pathUtils.ts
    patternUtils.ts
    sortIcons.tsx
  App.module.css
  App.tsx
  declarations.d.ts
  main.tsx
  react-app-env.d.ts
.eslintrc.cjs
.gitignore
.npmrc
.tsprunerc
index.html
jest.config.ts
LICENSE
main.js
package.json
README.md
release_notes.md
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Files
================================================================

================
File: electron/utils/treeSitterTest.js
================
 1: // Test file to verify tree-sitter loading
 2: const path = require('path');
 3: const fs = require('fs');
 4: // Log the environment for debugging
 5: console.log('========================================');
 6: console.log('TREE-SITTER MODULE LOADER TEST');
 7: console.log('========================================');
 8: console.log('Current directory:', process.cwd());
 9: console.log('resourcesPath:', process.resourcesPath || 'Not available');
10: console.log('appPath:', path.dirname(require.main.filename));
11: console.log('Module paths:', module.paths);
12: console.log('========================================');
13: // Try to load tree-sitter and each parser
14: const modules = [
15:   'tree-sitter',
16:   'tree-sitter-javascript',
17:   'tree-sitter-typescript',
18:   'tree-sitter-python',
19:   'tree-sitter-css',
20:   'tree-sitter-html'
21: ];
22: function tryRequire(moduleName) {
23:   try {
24:     const mod = require(moduleName);
25:     console.log(`✓ Successfully loaded ${moduleName}`);
26:     return true;
27:   } catch (err) {
28:     console.error(`✗ Failed to load ${moduleName}: ${err.message}`);
29:     // Try alternative locations if this is a packaged app
30:     if (process.resourcesPath) {
31:       try {
32:         const unpackedPath = path.join(process.resourcesPath, 'app.asar.unpacked', 'node_modules', moduleName);
33:         console.log(`   Trying unpacked path: ${unpackedPath}`);
34:         if (fs.existsSync(unpackedPath)) {
35:           const mod = require(unpackedPath);
36:           console.log(`✓ Successfully loaded ${moduleName} from unpacked path`);
37:           return true;
38:         }
39:       } catch (altErr) {
40:         console.error(`   Failed to load from alternative path: ${altErr.message}`);
41:       }
42:     }
43:     return false;
44:   }
45: }
46: // Test each module
47: let success = true;
48: for (const moduleName of modules) {
49:   const result = tryRequire(moduleName);
50:   success = success && result;
51: }
52: console.log('========================================');
53: console.log(`Overall result: ${success ? '✓ All modules loaded' : '✗ Some modules failed to load'}`);
54: console.log('========================================');
55: module.exports = { success };

================
File: electron/utils/treeSitterUtils.js
================
  1: const Parser = require('tree-sitter');
  2: const path = require('path');
  3: const fs = require('fs');
  4: // Use require for loading parsers in the main process
  5: let JavaScript = null;
  6: let TypeScript = null;
  7: let Python = null;
  8: let Css = null;
  9: let Html = null;
 10: // Helper function to safely load modules with detailed error logging
 11: function safeRequire(moduleName) {
 12:   try {
 13:     // Try standard require first
 14:     return require(moduleName);
 15:   } catch (e) {
 16:     if (e.code === 'MODULE_NOT_FOUND') {
 17:       console.warn(`Module not found: ${moduleName}. Error: ${e.message}`);
 18:       // Try alternative resolution approaches
 19:       try {
 20:         // For packaged app in production, check if we're in an asar environment
 21:         if (process.resourcesPath) {
 22:           // Try to find the module in the unpacked directory
 23:           const unpackedPath = path.join(process.resourcesPath, 'app.asar.unpacked', 'node_modules', moduleName);
 24:           if (fs.existsSync(unpackedPath)) {
 25:             console.log(`Found module at unpacked path: ${unpackedPath}`);
 26:             return require(unpackedPath);
 27:           }
 28:           // Also try non-unpacked path
 29:           const normalPath = path.join(process.resourcesPath, 'app.asar', 'node_modules', moduleName);
 30:           if (fs.existsSync(normalPath)) {
 31:             console.log(`Found module at normal path: ${normalPath}`);
 32:             return require(normalPath);
 33:           }
 34:           console.warn(`Could not find ${moduleName} in unpacked paths`);
 35:         }
 36:       } catch (alternativeError) {
 37:         console.error(`Alternative resolution failed for ${moduleName}:`, alternativeError);
 38:       }
 39:     } else {
 40:       console.error(`Error loading ${moduleName}:`, e);
 41:     }
 42:     return null;
 43:   }
 44: }
 45: // Load modules with the safer approach
 46: try {
 47:   JavaScript = safeRequire('tree-sitter-javascript');
 48: } catch (e) {
 49:   console.warn("Failed to load tree-sitter-javascript parser", e);
 50: }
 51: try {
 52:   // Note: tree-sitter-typescript exports multiple languages
 53:   const tsParser = safeRequire('tree-sitter-typescript');
 54:   TypeScript = tsParser?.typescript; // Use optional chaining
 55: } catch (e) {
 56:   console.warn("Failed to load tree-sitter-typescript parser", e);
 57: }
 58: try {
 59:   Python = safeRequire('tree-sitter-python');
 60: } catch (e) {
 61:   console.warn("Failed to load tree-sitter-python parser", e);
 62: }
 63: try {
 64:   Css = safeRequire('tree-sitter-css');
 65: } catch (e) {
 66:   console.warn("Failed to load tree-sitter-css parser", e);
 67: }
 68: try {
 69:   Html = safeRequire('tree-sitter-html');
 70: } catch (e) {
 71:   console.warn("Failed to load tree-sitter-html parser", e);
 72: }
 73: const COMPRESSION_PLACEHOLDERS = {
 74:   python: 'pass # ... body removed ...\n',
 75:   javascript: ' {/* ... body removed ... */}',
 76:   typescript: ' {/* ... body removed ... */}',
 77:   default: ' {/* ... body removed ... */}'
 78: };
 79: /**
 80:  * Gets the appropriate Tree-sitter language parser based on a simple language identifier.
 81:  * @param {string} language Simple language string (e.g., 'javascript', 'python').
 82:  * @returns The Tree-sitter language parser object or null if unsupported/unavailable.
 83:  */
 84: function getLanguageParser(language) {
 85:   switch (language?.toLowerCase()) {
 86:     case 'javascript':
 87:     case 'js':
 88:     case 'jsx':
 89:       return JavaScript;
 90:     case 'typescript':
 91:     case 'ts':
 92:     case 'tsx':
 93:       return TypeScript;
 94:     case 'python':
 95:     case 'py':
 96:       return Python;
 97:     case 'css':
 98:       return Css;
 99:     case 'html':
100:       return Html;
101:     default:
102:       console.warn(`Compression/Comment removal not supported for language: ${language}`);
103:       return null;
104:   }
105: }
106: // --- Queries ---
107: const FUNCTION_BODY_QUERIES = {
108:   javascript: `
109:     [
110:       (function_declaration body: (statement_block) @body)
111:       (method_definition body: (statement_block) @body)
112:       (arrow_function body: (statement_block) @body)
113:       (function_expression body: (statement_block) @body)
114:     ]
115:   `,
116:   typescript: `
117:     [
118:       (function_declaration body: (statement_block) @body)
119:       (method_definition body: (statement_block) @body)
120:       (arrow_function body: (statement_block) @body)
121:       (function_expression body: (statement_block) @body)
122:     ]
123:   `,
124:   python: `
125:     [
126:       (function_definition
127:         body: (block) @body)
128:       (class_definition
129:         body: (block . (function_definition
130:                           body: (block) @body)))
131:       (decorated_definition
132:           definition: (function_definition
133:                          body: (block) @body))
134:     ]
135:   `,
136:   css: '',
137:   html: '',
138: };
139: const COMMENT_QUERIES = {
140:   javascript: `(comment) @comment`,
141:   typescript: `(comment) @comment`,
142:   python: `(comment) @comment`,
143:   css: `(comment) @comment`,
144:   html: `(comment) @comment`,
145: };
146: // Define docstring queries to separate them from regular comments
147: const DOCSTRING_QUERIES = {
148:   javascript: `
149:     [
150:       (comment) @docstring
151:       (#match? @docstring "^\\/\\*\\*")  // JSDoc starts with /**
152:     ]
153:   `,
154:   typescript: `
155:     [
156:       (comment) @docstring
157:       (#match? @docstring "^\\/\\*\\*")  // JSDoc starts with /**
158:     ]
159:   `,
160:   python: `
161:     [
162:       (string) @docstring
163:       (#match? @docstring "^\\\"\\\"\\\"")  // Triple double-quoted strings
164:       (string) @docstring
165:       (#match? @docstring "^'''")  // Triple single-quoted strings
166:       (string) @docstring
167:       (#match? @docstring "^\\\"\\\\s*[Dd]ocstring")  // Single-quoted docstrings that begin with "docstring"
168:       (string) @docstring
169:       (#match? @docstring "^'\\\\s*[Dd]ocstring")  // Single-quoted docstrings that begin with 'docstring'
170:     ]
171:   `,
172:   css: ``,
173:   html: ``,
174: };
175: // --- Core Logic Functions ---
176: /**
177:  * Main process function to remove comments.
178:  * @param {string} source
179:  * @param {string} language
180:  * @param {boolean} keepDocstrings
181:  * @returns {string | null}
182:  */
183: function mainProcessRemoveComments(source, language, keepDocstrings = true) {
184:   const langParser = getLanguageParser(language);
185:   const queryStr = COMMENT_QUERIES[language?.toLowerCase()] || '';
186:   if (!langParser || !queryStr) {
187:     return source; // Return original if not supported
188:   }
189:   const parser = new Parser();
190:   try {
191:     parser.setLanguage(langParser);
192:     const tree = parser.parse(source);
193:     // Get all comment captures
194:     const query = new Parser.Query(langParser, queryStr);
195:     const commentMatches = query.captures(tree.rootNode);
196:     if (commentMatches.length === 0) {
197:       return source; // No comments to remove
198:     }
199:     let docstringMatches = [];
200:     // If keeping docstrings, identify them
201:     if (keepDocstrings) {
202:       const docstringQueryStr = DOCSTRING_QUERIES[language?.toLowerCase()] || '';
203:       if (docstringQueryStr) {
204:         const docstringQuery = new Parser.Query(langParser, docstringQueryStr);
205:         docstringMatches = docstringQuery.captures(tree.rootNode);
206:       }
207:     }
208:     // Create a set of docstring ranges to check against
209:     const docstringRanges = new Set();
210:     for (const docMatch of docstringMatches) {
211:       docstringRanges.add(`${docMatch.node.startIndex}-${docMatch.node.endIndex}`);
212:     }
213:     // Filter out comments that are docstrings if we're keeping them
214:     const matches = keepDocstrings
215:       ? commentMatches.filter(match => {
216:           const range = `${match.node.startIndex}-${match.node.endIndex}`;
217:           return !docstringRanges.has(range);
218:         })
219:       : commentMatches;
220:     // Sort in reverse order to handle edits from end to beginning
221:     matches.sort((a, b) => b.node.endIndex - a.node.endIndex);
222:     let sourceWithoutComments = source;
223:     for (const capture of matches) {
224:       const startIndex = capture.node.startIndex;
225:       const endIndex = capture.node.endIndex;
226:       let startSlice = startIndex;
227:       let endSlice = endIndex;
228:       while (startSlice > 0 && /[ \t]/.test(sourceWithoutComments[startSlice - 1]) && sourceWithoutComments[startSlice - 1] !== '\n') {
229:           startSlice--;
230:       }
231:       if (startSlice === 0 || sourceWithoutComments[startSlice - 1] === '\n') {
232:           if (endSlice < sourceWithoutComments.length && sourceWithoutComments[endSlice] === '\n') {
233:              endSlice++;
234:           } else if (startSlice > 0 && sourceWithoutComments[startSlice - 1] === '\n'){
235:               startSlice--;
236:           }
237:       }
238:       sourceWithoutComments = sourceWithoutComments.slice(0, startSlice) +
239:                               sourceWithoutComments.slice(endSlice);
240:     }
241:     return sourceWithoutComments.trim();
242:   } catch (error) {
243:     console.error(`Error removing comments for language '${language}' in main process:`, error);
244:     return null;
245:   }
246: }
247: /**
248:  * Main process function to compress code (remove function bodies).
249:  * @param {string} source
250:  * @param {string} language
251:  * @returns {string | null}
252:  */
253: function mainProcessCompressCode(source, language) {
254:   const langParser = getLanguageParser(language);
255:   const queryStr = FUNCTION_BODY_QUERIES[language?.toLowerCase()] || '';
256:   if (!langParser || !queryStr) {
257:     console.warn(`Cannot compress in main: No parser or query for language '${language}'.`);
258:     return null;
259:   }
260:   const parser = new Parser();
261:   try {
262:     parser.setLanguage(langParser);
263:     const tree = parser.parse(source);
264:     const query = new Parser.Query(langParser, queryStr);
265:     const captures = query.captures(tree.rootNode);
266:     const bodyCaptures = captures.filter(capture => capture.name === 'body');
267:     if (bodyCaptures.length === 0) {
268:       return source;
269:     }
270:     // Process edits from end to beginning to avoid index shifting problems
271:     bodyCaptures.sort((a, b) => b.node.startIndex - a.node.startIndex);
272:     let compressedSource = source;
273:     const placeholder = COMPRESSION_PLACEHOLDERS[language?.toLowerCase()] || COMPRESSION_PLACEHOLDERS.default;
274:     for (const capture of bodyCaptures) {
275:       const bodyNode = capture.node;
276:       const startPosition = bodyNode.startPosition;
277:       const endPosition = bodyNode.endPosition;
278:       // For Python, maintain the correct indentation
279:       let replacementText = placeholder;
280:       if (language?.toLowerCase() === 'python') {
281:         // Extract leading whitespace from the start of the body for proper indentation
282:         const lineStart = compressedSource.lastIndexOf('\n', bodyNode.startIndex) + 1;
283:         const indentation = compressedSource.slice(lineStart, bodyNode.startIndex).match(/^\s*/)[0];
284:         replacementText = indentation + placeholder;
285:       }
286:       compressedSource = compressedSource.slice(0, bodyNode.startIndex) +
287:                          replacementText +
288:                          compressedSource.slice(bodyNode.endIndex);
289:     }
290:     return compressedSource;
291:   } catch (error) {
292:     console.error(`Error compressing code for language '${language}' in main process:`, error);
293:     return null;
294:   }
295: }
296: // Export functions for use in main.js
297: module.exports = {
298:     mainProcessRemoveComments,
299:     mainProcessCompressCode,
300: };

================
File: electron/README.md
================
 1: # Electron Main Process Code
 2: 
 3: This directory contains all code related to the Electron main process, including:
 4: 
 5: - `main.js` - The main entry point for the Electron application
 6: - `preload.js` - The preload script that securely exposes Electron APIs to the renderer process
 7: - `excluded-files.js` - Configuration for file exclusion patterns
 8: 
 9: ## Architecture
10: 
11: The code follows a clear separation of concerns:
12: 
13: 1. **Main Process** (this directory) - Handles file system operations, window management, and IPC communication
14: 2. **Renderer Process** (`src/` directory) - Contains the React application for the user interface
15: 
16: ## Security
17: 
18: The preload script implements a context isolation pattern to securely expose only specific IPC channels to the renderer process, following Electron security best practices.
19: 
20: ## Development
21: 
22: When making changes to the main process code, consider:
23: 
24: 1. Running `npm run dev:electron` to test changes with the development build
25: 2. Using the same TypeScript patterns and code style as the rest of the codebase
26: 3. Keeping the preload.js file minimal and focused on API exposure

================
File: src/__tests__/utils/theme.test.ts
================
  1: /**
  2:  * Theme testing utility to verify CSS variable application across components
  3:  */
  4: import { JSDOM } from 'jsdom';
  5: interface ThemeTest {
  6:   component: string;
  7:   variables: string[];
  8:   states: string[];
  9: }
 10: const componentTests: ThemeTest[] = [
 11:   {
 12:     component: 'Button',
 13:     variables: [
 14:       '--background-primary',
 15:       '--text-primary',
 16:       '--ring-color',
 17:       '--shadow-sm'
 18:     ],
 19:     states: [':hover', ':focus', ':active', ':disabled']
 20:   },
 21:   {
 22:     component: 'Input',
 23:     variables: [
 24:       '--background-primary',
 25:       '--text-primary',
 26:       '--ring-color',
 27:       '--border-color'
 28:     ],
 29:     states: [':hover', ':focus', ':disabled']
 30:   },
 31:   {
 32:     component: 'Switch',
 33:     variables: [
 34:       '--accent-color',
 35:       '--text-disabled',
 36:       '--background-primary',
 37:       '--ring-color'
 38:     ],
 39:     states: [':checked', ':focus', ':disabled']
 40:   }
 41: ];
 42: function createVirtualDOM() {
 43:   const dom = new JSDOM(`
 44:     <!DOCTYPE html>
 45:     <html>
 46:       <head>
 47:         <style>
 48:           :root {
 49:             --background-primary: #ffffff;
 50:             --text-primary: #000000;
 51:             --ring-color: #0066ff;
 52:             --border-color: #e2e8f0;
 53:             --accent-color: #0066ff;
 54:             --text-disabled: #94a3b8;
 55:             --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
 56:           }
 57:           .dark-mode {
 58:             --background-primary: #1a1a1a;
 59:             --text-primary: #ffffff;
 60:             --ring-color: #3b82f6;
 61:             --border-color: #2d3748;
 62:             --accent-color: #3b82f6;
 63:             --text-disabled: #4a5568;
 64:             --shadow-sm: 0 1px 2px rgba(255, 255, 255, 0.05);
 65:           }
 66:         </style>
 67:       </head>
 68:       <body></body>
 69:     </html>
 70:   `);
 71:   return dom;
 72: }
 73: describe('Theme Variable Tests', () => {
 74:   let dom: JSDOM;
 75:   let root: HTMLElement;
 76:   beforeEach(() => {
 77:     dom = createVirtualDOM();
 78:     root = dom.window.document.documentElement;
 79:   });
 80:   describe('Light Theme', () => {
 81:     componentTests.forEach(test => {
 82:       describe(`${test.component} Component`, () => {
 83:         test.variables.forEach(variable => {
 84:           it(`should have correct ${variable} value`, () => {
 85:             const computedValue = dom.window.getComputedStyle(root)
 86:               .getPropertyValue(variable)
 87:               .trim();
 88:             expect(computedValue).toBeTruthy();
 89:           });
 90:         });
 91:         test.states.forEach(state => {
 92:           describe(`${state} state`, () => {
 93:             test.variables.forEach(variable => {
 94:               it(`should handle ${variable} correctly`, () => {
 95:                 // Note: In a real browser environment, we would test actual state changes
 96:                 expect(true).toBeTruthy();
 97:               });
 98:             });
 99:           });
100:         });
101:       });
102:     });
103:   });
104:   describe('Dark Theme', () => {
105:     beforeEach(() => {
106:       root.classList.add('dark-mode');
107:     });
108:     afterEach(() => {
109:       root.classList.remove('dark-mode');
110:     });
111:     componentTests.forEach(test => {
112:       describe(`${test.component} Component`, () => {
113:         test.variables.forEach(variable => {
114:           it(`should have correct ${variable} value`, () => {
115:             const computedValue = dom.window.getComputedStyle(root)
116:               .getPropertyValue(variable)
117:               .trim();
118:             expect(computedValue).toBeTruthy();
119:           });
120:         });
121:         test.states.forEach(state => {
122:           describe(`${state} state`, () => {
123:             test.variables.forEach(variable => {
124:               it(`should handle ${variable} correctly`, () => {
125:                 // Note: In a real browser environment, we would test actual state changes
126:                 expect(true).toBeTruthy();
127:               });
128:             });
129:           });
130:         });
131:       });
132:     });
133:   });
134: });

================
File: src/__tests__/setup.ts
================
 1: import '@testing-library/jest-dom';
 2: import { TextEncoder, TextDecoder } from 'util';
 3: global.TextEncoder = TextEncoder;
 4: global.TextDecoder = TextDecoder as any;
 5: // Mock window.matchMedia
 6: Object.defineProperty(window, 'matchMedia', {
 7:   writable: true,
 8:   value: jest.fn().mockImplementation(query => ({
 9:     matches: false,
10:     media: query,
11:     onchange: null,
12:     addListener: jest.fn(),
13:     removeListener: jest.fn(),
14:     addEventListener: jest.fn(),
15:     removeEventListener: jest.fn(),
16:     dispatchEvent: jest.fn(),
17:   })),
18: });
19: // Mock ResizeObserver
20: global.ResizeObserver = class ResizeObserver {
21:   observe = jest.fn();
22:   unobserve = jest.fn();
23:   disconnect = jest.fn();
24: };
25: // Mock IntersectionObserver
26: global.IntersectionObserver = jest.fn().mockImplementation(() => ({
27:   root: null,
28:   rootMargin: '',
29:   thresholds: [],
30:   disconnect: jest.fn(),
31:   observe: jest.fn(),
32:   takeRecords: jest.fn(),
33:   unobserve: jest.fn(),
34: }));

================
File: src/assets/favicon.svg
================
1: <svg xmlns="http://www.w3.org/2000/svg" width="512" height="512" viewBox="0 0 512 512">
2:   <rect width="512" height="512" rx="50" fill="#4a86e8" />
3:   <rect x="100" y="150" width="312" height="50" rx="10" fill="white" />
4:   <rect x="100" y="230" width="312" height="50" rx="10" fill="white" />
5:   <rect x="100" y="310" width="312" height="50" rx="10" fill="white" />
6:   <circle cx="140" cy="175" r="15" fill="#ff9900" />
7:   <circle cx="140" cy="255" r="15" fill="#ff9900" />
8:   <circle cx="140" cy="335" r="15" fill="#ff9900" />
9: </svg>

================
File: src/components/__tests__/IgnorePatterns.test.tsx
================
 1: // Imports commented out since they're not used in the current test implementation
 2: // import React from 'react';
 3: // import { render } from '@testing-library/react';
 4: // import IgnorePatterns from '../IgnorePatterns';
 5: // Mock implementation to disable tests for now
 6: describe('IgnorePatterns component', () => {
 7:   it('should be temporarily disabled', () => {
 8:     // Skip tests until we update the testing library
 9:     expect(true).toBe(true);
10:   });
11: });

================
File: src/components/ui/Button/Button.module.css
================
  1: .button {
  2:   display: inline-flex;
  3:   align-items: center;
  4:   justify-content: center;
  5:   cursor: pointer;
  6:   font-family: inherit;
  7:   font-size: 13px;
  8:   gap: 8px;
  9:   padding: 0 12px;
 10:   border-radius: 6px;
 11:   transition: all 0.15s ease;
 12:   white-space: nowrap;
 13:   font-weight: 500;
 14:   height: 32px;
 15:   background-color: var(--background-primary);
 16:   color: var(--text-primary);
 17:   border: 1px solid var(--border-color);
 18: }
 19: .button:hover:not(:disabled) {
 20:   background-color: var(--hover-color);
 21: }
 22: .button:active:not(:disabled) {
 23:   background-color: var(--secondary-button-active);
 24: }
 25: .button:disabled {
 26:   opacity: 0.5;
 27:   cursor: not-allowed;
 28: }
 29: /* Variants */
 30: .ghost {
 31:   background-color: transparent;
 32:   border: 1px solid var(--border-color);
 33:   color: var(--text-primary);
 34: }
 35: .ghost:hover:not(:disabled) {
 36:   background-color: var(--hover-color);
 37: }
 38: .ghost:active:not(:disabled) {
 39:   background-color: var(--secondary-button-active);
 40: }
 41: .secondary {
 42:   background-color: transparent;
 43:   border: 1px solid var(--border-color);
 44:   color: var(--text-primary);
 45: }
 46: .secondary:hover:not(:disabled) {
 47:   background-color: var(--hover-color);
 48: }
 49: .secondary:active:not(:disabled) {
 50:   background-color: var(--secondary-button-active);
 51: }
 52: /* Icon styles */
 53: .startIcon {
 54:   margin-right: 4px;
 55:   display: flex;
 56:   align-items: center;
 57: }
 58: .endIcon {
 59:   margin-left: 4px;
 60:   display: flex;
 61:   align-items: center;
 62: }
 63: /* Variants */
 64: .primary {
 65:   background-color: var(--primary-button-background);
 66:   color: var(--primary-button-text);
 67:   border: 1px solid var(--primary-button-border);
 68: }
 69: .primary:hover:not(:disabled) {
 70:   background-color: var(--primary-button-hover);
 71:   border-color: var(--primary-button-border);
 72: }
 73: .primary:active:not(:disabled) {
 74:   background-color: var(--primary-button-active);
 75:   border-color: var(--primary-button-border);
 76: }
 77: .destructive {
 78:   background-color: var(--error-color);
 79:   color: white;
 80:   border: 1px solid var(--error-color);
 81: }
 82: .destructive:hover:not(:disabled) {
 83:   opacity: 0.9;
 84: }
 85: .destructive:active:not(:disabled) {
 86:   opacity: 0.8;
 87: }
 88: /* Sizes */
 89: .sm {
 90:   font-size: 12px;
 91:   padding: 0 12px;
 92:   height: var(--button-height-sm);
 93: }
 94: .md {
 95:   font-size: 14px;
 96:   padding: 0 16px;
 97:   height: var(--button-height-md);
 98: }
 99: .lg {
100:   font-size: 16px;
101:   padding: 0 20px;
102:   height: var(--button-height-lg);
103: }
104: /* Icon styles */
105: .startIcon {
106:   margin-right: 4px;
107:   display: flex;
108:   align-items: center;
109: }
110: .endIcon {
111:   margin-left: 4px;
112:   display: flex;
113:   align-items: center;
114: }
115: .iconOnly {
116:   padding: 0;
117:   aspect-ratio: 1/1;
118:   justify-content: center;
119: }
120: .iconOnly.sm {
121:   width: var(--button-height-sm);
122: }
123: .iconOnly.md {
124:   width: var(--button-height-md);
125: }
126: .iconOnly.lg {
127:   width: var(--button-height-lg);
128: }
129: /* Pill shape - just the border radius */
130: .pillShaped {
131:   border-radius: var(--radius-full);
132: }
133: /* Pill variant - tag/badge style button */
134: .pill {
135:   border-radius: var(--radius-full);
136:   background-color: var(--background-primary-dark);
137:   color: white;
138:   border: none;
139:   padding: 0 12px;
140:   font-size: 12px;
141:   font-weight: 500;
142:   height: 24px;
143:   letter-spacing: 0.01em;
144:   text-transform: capitalize;
145:   transition: opacity 0.2s ease;
146: }
147: .pill:hover:not(:disabled) {
148:   background-color: var(--background-primary-dark);
149:   opacity: 0.9;
150: }
151: .pill:active:not(:disabled) {
152:   background-color: var(--background-primary-dark);
153:   opacity: 0.8;
154: }
155: /* Dark mode support for pill */
156: :global(.dark-mode) .pill {
157:   background-color: hsl(240, 5%, 84.9%);
158:   color: var(--background-primary-dark);
159: }
160: :global(.dark-mode) .pill:hover:not(:disabled),
161: :global(.dark-mode) .pill:active:not(:disabled) {
162:   background-color: hsl(240, 5%, 84.9%);
163: }
164: /* Round variant - inherits from primary but with enhancements */
165: .round {
166:   background-color: var(--primary-button-background);
167:   color: var(--primary-button-text);
168:   border-color: var(--primary-button-background);
169:   padding: 0 20px;
170:   border-width: 1.5px;
171:   font-weight: 600;
172:   letter-spacing: 0.01em;
173: }
174: .round:hover:not(:disabled) {
175:   background-color: var(--primary-button-hover);
176:   border-color: var(--primary-button-hover);
177:   box-shadow: var(--shadow-sm);
178: }
179: .round:active:not(:disabled) {
180:   background-color: var(--primary-button-active);
181:   border-color: var(--primary-button-active);
182: }
183: .round.iconOnly {
184:   padding: 0;
185:   width: var(--button-height-md);
186:   height: var(--button-height-md);
187: }
188: .round.sm.iconOnly {
189:   width: var(--button-height-sm);
190:   height: var(--button-height-sm);
191: }
192: .round.lg.iconOnly {
193:   width: var(--button-height-lg);
194:   height: var(--button-height-lg);
195: }
196: /* Adjust icon spacing for round variant */
197: .round .startIcon {
198:   margin-right: 8px;
199: }
200: .round .endIcon {
201:   margin-left: 8px;
202: }
203: .round.iconOnly .startIcon,
204: .round.iconOnly .endIcon {
205:   margin: 0;
206: }
207: /* Icon variant - for icon-only buttons without background effects */
208: .icon {
209:   background-color: transparent;
210:   border: none;
211:   color: var(--icon-color);
212:   padding: 0;
213:   transition: transform 0.2s ease, color 0.2s ease;
214: }
215: .icon:hover:not(:disabled) {
216:   background-color: transparent;
217:   color: var(--text-primary);
218:   opacity: 0.8;
219:   transform: scale(1.1);
220: }
221: .icon:active:not(:disabled) {
222:   background-color: transparent;
223:   opacity: 0.9;
224:   transform: scale(1.05);
225: }

================
File: src/components/ui/Button/Button.tsx
================
 1: import React from 'react';
 2: import { cn } from '../../../utils/cn';
 3: import styles from './Button.module.css';
 4: export type ButtonVariant = 'primary' | 'secondary' | 'ghost' | 'destructive' | 'round' | 'icon' | 'pill';
 5: export type ButtonSize = 'sm' | 'md' | 'lg';
 6: export interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
 7:   /**
 8:    * Button visual variant
 9:    * @default 'primary'
10:    */
11:   variant?: ButtonVariant;
12:   /**
13:    * Button size
14:    * @default 'md'
15:    */
16:   size?: ButtonSize;
17:   /**
18:    * Optional icon to display before the button text
19:    */
20:   startIcon?: React.ReactNode;
21:   /**
22:    * Optional icon to display after the button text
23:    */
24:   endIcon?: React.ReactNode;
25:   /**
26:    * If true, button will have equal width and height, and padding will be adjusted
27:    * Useful for icon-only buttons
28:    * @default false
29:    */
30:   iconOnly?: boolean;
31:   /**
32:    * If true, button will have fully rounded corners (pill shape)
33:    * Note: This is different from the 'pill' variant which has specific styling
34:    * @default false
35:    */
36:   pill?: boolean;
37:   /**
38:    * Button children (text content or other elements)
39:    */
40:   children?: React.ReactNode;
41: }
42: /**
43:  * Primary UI component for user interaction.
44:  * Supports multiple variants (primary, secondary, ghost, destructive, round, pill, icon) and sizes.
45:  * Round variant is always pill-shaped and inherits primary colors with enhanced styling.
46:  * Pill variant is a compact, high-contrast tag-like button (similar to the Platform badge in the reference).
47:  */
48: export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
49:   (
50:     {
51:       className,
52:       variant = 'primary',
53:       size = 'md',
54:       startIcon,
55:       endIcon,
56:       iconOnly = false,
57:       pill = false,
58:       children,
59:       ...props
60:     },
61:     ref
62:   ) => {
63:     // Force pill shape for round variant and pill variant
64:     const isPillShaped = variant === 'round' || variant === 'pill' || pill;
65:     return (
66:       <button
67:         className={cn(
68:           styles.button,
69:           styles[variant],
70:           styles[size],
71:           iconOnly && styles.iconOnly,
72:           isPillShaped && !variant.includes('pill') && styles.pillShaped, // Apply pill shape but not pill styling
73:           className
74:         )}
75:         ref={ref}
76:         {...props}
77:       >
78:         {startIcon && <span className={styles.startIcon}>{startIcon}</span>}
79:         {children}
80:         {endIcon && <span className={styles.endIcon}>{endIcon}</span>}
81:       </button>
82:     );
83:   }
84: );
85: Button.displayName = 'Button';

================
File: src/components/ui/Button/index.ts
================
1: export * from './Button';

================
File: src/components/ui/ButtonGroup/ButtonGroup.module.css
================
 1: .buttonGroup {
 2:   display: flex;
 3:   align-items: center;
 4: }
 5: /* Horizontal variant - default */
 6: .horizontal {
 7:   display: flex;
 8:   flex-direction: row;
 9: }
10: /* Vertical variant */
11: .vertical {
12:   display: flex;
13:   flex-direction: column;
14: }
15: /* Position-based styles for horizontal variant */
16: .first {
17:   border-top-right-radius: 0;
18:   border-bottom-right-radius: 0;
19:   border-right: none;
20: }
21: .middle {
22:   border-radius: 0;
23:   border-right: none;
24: }
25: .last {
26:   border-top-left-radius: 0;
27:   border-bottom-left-radius: 0;
28:   border-left: 1px solid var(--border-color);
29: }
30: /* Position-based styles for vertical variant */
31: .top {
32:   border-bottom-left-radius: 0;
33:   border-bottom-right-radius: 0;
34:   border-bottom: none;
35: }
36: .center {
37:   border-radius: 0;
38:   border-bottom: none;
39: }
40: .bottom {
41:   border-top-left-radius: 0;
42:   border-top-right-radius: 0;
43:   border-top: 1px solid var(--border-color);
44: }
45: /* Handle hover and active states - ensure proper z-index */
46: .buttonGroup button:hover:not(:disabled) {
47:   z-index: 1;
48: }
49: .buttonGroup button:active:not(:disabled) {
50:   z-index: 2;
51: }
52: /* Sizes */
53: .xs {
54:   gap: 0;
55: }
56: .xs button {
57:   height: 22px;
58:   font-size: 9px;
59:   padding: 2px 6px;
60: }
61: .sm {
62:   gap: 0;
63: }
64: .sm button {
65:   height: 26px;
66:   font-size: 10px;
67:   padding: 3px 8px;
68: }
69: .md {
70:   gap: 0;
71: }
72: .md button {
73:   height: 30px;
74:   font-size: 11px;
75: }
76: .lg {
77:   gap: 0;
78: }

================
File: src/components/ui/ButtonGroup/ButtonGroup.tsx
================
 1: import React from 'react';
 2: import { Button } from '../Button';
 3: import styles from './ButtonGroup.module.css';
 4: interface ButtonGroupProps {
 5:   children: React.ReactNode;
 6:   className?: string;
 7:   variant?: 'horizontal' | 'vertical';
 8:   size?: 'xs' | 'sm' | 'md' | 'lg';
 9: }
10: const ButtonGroup: React.FC<ButtonGroupProps> = ({
11:   children,
12:   className = '',
13:   variant = 'horizontal',
14:   size = 'md'
15: }) => {
16:   // Apply the buttonGroup class and any additional className
17:   const groupClassName = `${styles.buttonGroup} ${styles[variant]} ${styles[size]} ${className}`;
18:   // Apply styling to children to connect them
19:   const childrenWithProps = React.Children.map(children, (child, index) => {
20:     // Skip non-Button children
21:     if (!React.isValidElement(child) || (child.type as any) !== Button) {
22:       console.warn("ButtonGroup should only contain Button components.");
23:       return child;
24:     }
25:     const isFirst = index === 0;
26:     const isLast = index === React.Children.count(children) - 1;
27:     // Calculate the position classes
28:     let positionClass = '';
29:     if (variant === 'horizontal') {
30:       if (isFirst) positionClass = styles.first;
31:       else if (isLast) positionClass = styles.last;
32:       else positionClass = styles.middle;
33:     } else { // vertical
34:       if (isFirst) positionClass = styles.top;
35:       else if (isLast) positionClass = styles.bottom;
36:       else positionClass = styles.center;
37:     }
38:     // Clone the child with additional className
39:     const childClassName = child.props.className || '';
40:     return React.cloneElement(child, {
41:       ...child.props,
42:       className: `${childClassName} ${positionClass}`,
43:       size: child.props.size || size, // Pass down size if not specified
44:     });
45:   });
46:   return (
47:     <div className={groupClassName}>
48:       {childrenWithProps}
49:     </div>
50:   );
51: };
52: ButtonGroup.displayName = 'ButtonGroup';
53: export { ButtonGroup };

================
File: src/components/ui/ButtonGroup/index.ts
================
1: export { ButtonGroup } from './ButtonGroup';

================
File: src/components/ui/Card/Card.module.css
================
 1: .card {
 2:   border: 1px solid var(--border-color);
 3:   border-radius: var(--radius);
 4:   background-color: var(--card-background);
 5:   color: var(--text-primary);
 6:   transition: border-color 0.2s ease, box-shadow 0.2s ease;
 7: }
 8: .card:hover {
 9:   border-color: var(--accent-color);
10:   box-shadow: var(--shadow-sm);
11: }
12: .cardSelected {
13:   border-color: var(--accent-color);
14:   box-shadow: var(--shadow-md);
15: }
16: .cardInteractive {
17:   cursor: pointer;
18: }
19: .cardInteractive:hover {
20:   box-shadow: var(--shadow-md);
21: }
22: .cardHeader {
23:   display: flex;
24:   align-items: center;
25:   justify-content: space-between;
26:   padding: 12px 16px;
27:   border-bottom: 1px solid var(--border-color);
28: }
29: .cardTitle {
30:   font-weight: 600;
31:   font-size: 16px;
32:   margin: 0;
33:   color: var(--text-primary);
34: }
35: .cardDescription {
36:   color: var(--text-secondary);
37:   font-size: 14px;
38:   margin-top: 4px;
39: }
40: .cardContent {
41:   padding: 16px;
42: }
43: .cardFooter {
44:   display: flex;
45:   align-items: center;
46:   justify-content: flex-end;
47:   padding: 12px 16px;
48:   border-top: 1px solid var(--border-color);
49: }

================
File: src/components/ui/Card/Card.tsx
================
  1: import React from 'react';
  2: import { cn } from '../../../utils/cn';
  3: import styles from './Card.module.css';
  4: // Card component types
  5: export interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  6:   /**
  7:    * Whether the card is selected
  8:    */
  9:   selected?: boolean;
 10:   /**
 11:    * Makes the card interactive (clickable)
 12:    */
 13:   interactive?: boolean;
 14: }
 15: /**
 16:  * Card component container
 17:  */
 18: export const Card = React.forwardRef<HTMLDivElement, CardProps>(
 19:   ({ className, selected = false, interactive = false, ...props }, ref) => {
 20:     return (
 21:       <div
 22:         className={cn(
 23:           styles.card,
 24:           selected && styles.cardSelected,
 25:           interactive && styles.cardInteractive,
 26:           className
 27:         )}
 28:         ref={ref}
 29:         {...props}
 30:       />
 31:     );
 32:   }
 33: );
 34: Card.displayName = 'Card';
 35: // Card Header types
 36: export interface CardHeaderProps extends React.HTMLAttributes<HTMLDivElement> {}
 37: /**
 38:  * Card header section
 39:  */
 40: export const CardHeader = React.forwardRef<HTMLDivElement, CardHeaderProps>(
 41:   ({ className, ...props }, ref) => {
 42:     return (
 43:       <div
 44:         className={cn(styles.cardHeader, className)}
 45:         ref={ref}
 46:         {...props}
 47:       />
 48:     );
 49:   }
 50: );
 51: CardHeader.displayName = 'CardHeader';
 52: // Card Title types
 53: export interface CardTitleProps extends React.HTMLAttributes<HTMLHeadingElement> {}
 54: /**
 55:  * Card title element
 56:  */
 57: export const CardTitle = React.forwardRef<HTMLHeadingElement, CardTitleProps>(
 58:   ({ className, ...props }, ref) => {
 59:     return (
 60:       <h3
 61:         className={cn(styles.cardTitle, className)}
 62:         ref={ref}
 63:         {...props}
 64:       />
 65:     );
 66:   }
 67: );
 68: CardTitle.displayName = 'CardTitle';
 69: // Card Description types
 70: export interface CardDescriptionProps extends React.HTMLAttributes<HTMLParagraphElement> {}
 71: /**
 72:  * Card description element
 73:  */
 74: export const CardDescription = React.forwardRef<HTMLParagraphElement, CardDescriptionProps>(
 75:   ({ className, ...props }, ref) => {
 76:     return (
 77:       <p
 78:         className={cn(styles.cardDescription, className)}
 79:         ref={ref}
 80:         {...props}
 81:       />
 82:     );
 83:   }
 84: );
 85: CardDescription.displayName = 'CardDescription';
 86: // Card Content types
 87: export interface CardContentProps extends React.HTMLAttributes<HTMLDivElement> {}
 88: /**
 89:  * Card content section
 90:  */
 91: export const CardContent = React.forwardRef<HTMLDivElement, CardContentProps>(
 92:   ({ className, ...props }, ref) => {
 93:     return (
 94:       <div
 95:         className={cn(styles.cardContent, className)}
 96:         ref={ref}
 97:         {...props}
 98:       />
 99:     );
100:   }
101: );
102: CardContent.displayName = 'CardContent';
103: // Card Footer types
104: export interface CardFooterProps extends React.HTMLAttributes<HTMLDivElement> {}
105: /**
106:  * Card footer section
107:  */
108: export const CardFooter = React.forwardRef<HTMLDivElement, CardFooterProps>(
109:   ({ className, ...props }, ref) => {
110:     return (
111:       <div
112:         className={cn(styles.cardFooter, className)}
113:         ref={ref}
114:         {...props}
115:       />
116:     );
117:   }
118: );
119: CardFooter.displayName = 'CardFooter';

================
File: src/components/ui/Card/index.ts
================
1: export * from './Card';

================
File: src/components/ui/Dialog/Dialog.module.css
================
 1: .backdrop {
 2:   position: fixed;
 3:   top: 0;
 4:   left: 0;
 5:   right: 0;
 6:   bottom: 0;
 7:   background-color: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
 8:   display: flex;
 9:   justify-content: center;
10:   align-items: center;
11:   z-index: var(--z-index-modal, 50);
12:   backdrop-filter: blur(4px); /* Background blur */
13:   animation: fadeIn 0.15s ease-out;
14: }
15: .dialog { /* Style the main dialog container */
16:   background-color: var(--background-primary);
17:   border: 1px solid var(--border-color); /* Added border */
18:   border-radius: var(--radius-lg, 8px); /* Use variable or default */
19:   box-shadow: var(--shadow-lg);
20:   width: 90vw; /* Responsive width */
21:   max-width: 500px; /* Default max-width (size 'md') */
22:   max-height: 85vh;
23:   display: flex; /* Use flexbox for layout */
24:   flex-direction: column;
25:   overflow: hidden; /* Prevent content overflow issues */
26:   animation: slideIn 0.2s cubic-bezier(0.16, 1, 0.3, 1); /* Optional: entry animation */
27: }
28: /* Remove fixed positioning and transform, rely on backdrop flexbox for centering */
29: /* .dialogContent { ... } */
30: /* Size variants for .dialog */
31: .sm {
32:   max-width: 400px;
33: }
34: .md {
35:   max-width: 500px; /* Consistent with above */
36: }
37: .lg {
38:   max-width: 800px;
39: }
40: .header {
41:   display: flex;
42:   justify-content: space-between;
43:   align-items: center;
44:   padding: 16px 20px;
45:   border-bottom: 1px solid var(--border-color);
46:   flex-shrink: 0; /* Prevent header from shrinking */
47: }
48: .title {
49:   margin: 0;
50:   font-size: 18px;
51:   font-weight: 600;
52:   color: var(--text-primary);
53:   line-height: 1.4;
54: }
55: /* Removed .closeButton - handled by Button component */
56: .description {
57:   padding: 12px 20px 0;
58:   font-size: 14px;
59:   color: var(--text-secondary);
60:   line-height: 1.5;
61:   flex-shrink: 0; /* Prevent shrinking */
62: }
63: .content {
64:   padding: 20px;
65:   overflow-y: auto; /* Allow content to scroll if needed */
66:   flex-grow: 1; /* Allow content to take available space */
67: }
68: .footer {
69:   display: flex;
70:   justify-content: center; /* Center buttons */
71:   align-items: center;
72:   gap: 12px;
73:   padding: 16px 20px;
74:   border-top: 1px solid var(--border-color);
75:   background-color: var(--background-secondary);
76:   flex-shrink: 0; /* Prevent footer from shrinking */
77: }
78: /* Animations */
79: @keyframes fadeIn {
80:   from { opacity: 0; }
81:   to { opacity: 1; }
82: }
83: @keyframes slideIn {
84:   from {
85:     opacity: 0;
86:     transform: translateY(10px) scale(0.98);
87:   }
88:   to {
89:     opacity: 1;
90:     transform: translateY(0) scale(1);
91:   }
92: }

================
File: src/components/ui/Dialog/Dialog.tsx
================
  1: import React, { useEffect, useRef } from 'react';
  2: import { X } from 'lucide-react';
  3: import { Button } from '../Button';
  4: import { cn } from '../../../utils/cn';
  5: import styles from './Dialog.module.css';
  6: export interface DialogProps {
  7:   /**
  8:    * Whether the dialog is open
  9:    */
 10:   isOpen: boolean;
 11:   /**
 12:    * Callback when the dialog should close
 13:    */
 14:   onClose: () => void;
 15:   /**
 16:    * Dialog title
 17:    */
 18:   title: string;
 19:   /**
 20:    * Optional description text below the title
 21:    */
 22:   description?: string;
 23:   /**
 24:    * Dialog content
 25:    */
 26:   children: React.ReactNode;
 27:   /**
 28:    * Optional footer content (usually action buttons)
 29:    */
 30:   footer?: React.ReactNode;
 31:   /**
 32:    * Optional size variant
 33:    * @default 'md'
 34:    */
 35:   size?: 'sm' | 'md' | 'lg';
 36:   /**
 37:    * Optional custom class name
 38:    */
 39:   className?: string;
 40: }
 41: /**
 42:  * Dialog component for modal interactions
 43:  * Handles focus trapping, keyboard interactions, and animations
 44:  */
 45: export const Dialog: React.FC<DialogProps> = ({
 46:   isOpen,
 47:   onClose,
 48:   title,
 49:   description,
 50:   children,
 51:   footer,
 52:   size = 'md',
 53:   className,
 54: }) => {
 55:   const dialogRef = useRef<HTMLDivElement>(null);
 56:   const backdropRef = useRef<HTMLDivElement>(null); // Ref for the backdrop
 57:   // Handle ESC key to close dialog
 58:   useEffect(() => {
 59:     const handleKeyDown = (e: KeyboardEvent) => {
 60:       if (e.key === 'Escape' && isOpen) {
 61:         onClose();
 62:       }
 63:     };
 64:     window.addEventListener('keydown', handleKeyDown);
 65:     return () => window.removeEventListener('keydown', handleKeyDown);
 66:   }, [isOpen, onClose]);
 67:   // Handle click outside (on backdrop) to close
 68:   useEffect(() => {
 69:     const handleClickOutside = (e: MouseEvent) => {
 70:       // Only close if clicking directly on the backdrop
 71:       if (backdropRef.current === e.target) {
 72:         onClose();
 73:       }
 74:     };
 75:     if (isOpen) {
 76:       document.addEventListener('mousedown', handleClickOutside);
 77:       return () => document.removeEventListener('mousedown', handleClickOutside);
 78:     }
 79:   }, [isOpen, onClose]);
 80:   // Prevent body scroll when dialog is open
 81:   useEffect(() => {
 82:     if (isOpen) {
 83:       document.body.style.overflow = 'hidden';
 84:       // Focus the dialog container or first focusable element on open
 85:       dialogRef.current?.focus();
 86:       return () => {
 87:         document.body.style.overflow = 'unset';
 88:       };
 89:     }
 90:   }, [isOpen]);
 91:   if (!isOpen) return null;
 92:   return (
 93:     <div
 94:       ref={backdropRef} // Add ref to backdrop
 95:       className={styles.backdrop}
 96:       role="presentation" // Backdrop is presentational
 97:     >
 98:       <div
 99:         ref={dialogRef}
100:         className={cn(
101:           styles.dialog, // Use .dialog for the main container
102:           styles[size],
103:           className
104:         )}
105:         role="dialog"
106:         aria-modal="true"
107:         aria-labelledby="dialog-title"
108:         tabIndex={-1} // Make the dialog focusable
109:       >
110:         <div className={styles.header}>
111:           <h2 id="dialog-title" className={styles.title}>{title}</h2>
112:           <Button
113:             variant="ghost"
114:             size="sm"
115:             iconOnly
116:             onClick={onClose}
117:             startIcon={<X size={16} />} // Correctly uses Button component
118:             title="Close dialog"
119:             aria-label="Close dialog" // Add aria-label
120:           />
121:         </div>
122:         {description && (
123:           <div className={styles.description}>
124:             {description}
125:           </div>
126:         )}
127:         <div className={styles.content}>
128:           {children}
129:         </div>
130:         {footer && (
131:           <div className={styles.footer}>
132:             {footer}
133:           </div>
134:         )}
135:       </div>
136:     </div>
137:   );
138: };

================
File: src/components/ui/Dialog/index.ts
================
1: export * from './Dialog';

================
File: src/components/ui/Dropdown/Dropdown.tsx
================
  1: import React, { useEffect, useRef, useState, useCallback } from 'react';
  2: import { ChevronDown } from 'lucide-react';
  3: import { cn } from '../../../utils/cn';
  4: import styles from './Dropdown.module.css';
  5: export interface DropdownOption {
  6:   label: string;
  7:   value: string;
  8:   icon?: React.ReactNode;
  9:   disabled?: boolean;
 10: }
 11: export interface DropdownProps {
 12:   /**
 13:    * Array of options to display in the dropdown
 14:    */
 15:   options: DropdownOption[];
 16:   /**
 17:    * Currently selected value(s)
 18:    */
 19:   value?: string | string[];
 20:   /**
 21:    * Callback when selection changes
 22:    */
 23:   onChange: (value: string | string[]) => void;
 24:   /**
 25:    * Optional placeholder text when no option is selected
 26:    */
 27:   placeholder?: string;
 28:   /**
 29:    * Whether the dropdown supports multiple selections
 30:    * @default false
 31:    */
 32:   multiple?: boolean;
 33:   /**
 34:    * Optional title for the dropdown button (for accessibility)
 35:    */
 36:   title?: string;
 37:   /**
 38:    * Optional custom trigger element
 39:    */
 40:   trigger?: React.ReactNode;
 41:   /**
 42:    * Optional custom class name for the dropdown container
 43:    */
 44:   className?: string;
 45:   /**
 46:    * Optional custom class name for the dropdown menu
 47:    */
 48:   menuClassName?: string;
 49:   /**
 50:    * Optional size variant
 51:    * @default 'md'
 52:    */
 53:   size?: 'sm' | 'md' | 'lg';
 54:   /**
 55:    * Optional style variant
 56:    * @default 'default'
 57:    */
 58:   variant?: string;
 59:   /**
 60:    * Optional icon to display in the dropdown
 61:    */
 62:   icon?: React.ReactNode;
 63:   /**
 64:    * Whether the dropdown is disabled
 65:    * @default false
 66:    */
 67:   disabled?: boolean;
 68:   /**
 69:    * Optional maximum height for the dropdown menu in pixels
 70:    * @default 300
 71:    */
 72:   maxHeight?: number;
 73: }
 74: export const Dropdown: React.FC<DropdownProps> = ({
 75:   options,
 76:   value,
 77:   onChange,
 78:   placeholder = 'Select option',
 79:   multiple = false,
 80:   title,
 81:   trigger,
 82:   className,
 83:   menuClassName,
 84:   size = 'md',
 85:   disabled = false,
 86:   maxHeight = 300,
 87: }) => {
 88:   const [isOpen, setIsOpen] = useState(false);
 89:   const dropdownRef = useRef<HTMLDivElement>(null);
 90:   const menuRef = useRef<HTMLDivElement>(null);
 91:   // Handle click outside to close dropdown
 92:   useEffect(() => {
 93:     const handleClickOutside = (event: MouseEvent) => {
 94:       if (
 95:         dropdownRef.current &&
 96:         !dropdownRef.current.contains(event.target as Node)
 97:       ) {
 98:         setIsOpen(false);
 99:       }
100:     };
101:     if (isOpen) {
102:       document.addEventListener('mousedown', handleClickOutside);
103:       return () => document.removeEventListener('mousedown', handleClickOutside);
104:     }
105:   }, [isOpen]);
106:   const handleSelect = useCallback((option: DropdownOption) => {
107:     if (!option.disabled) {
108:       onChange(option.value);
109:       setIsOpen(false);
110:     }
111:   }, [onChange]);
112:   const handleKeyDown = useCallback((event: KeyboardEvent) => {
113:     const optionElements = Array.from(dropdownRef.current?.querySelectorAll('[role="option"]') || []);
114:     const currentIndex = optionElements.findIndex(opt => opt === document.activeElement);
115:     switch (event.key) {
116:       case 'ArrowDown': {
117:         event.preventDefault();
118:         const nextIndex = currentIndex + 1 < optionElements.length ? currentIndex + 1 : 0;
119:         (optionElements[nextIndex] as HTMLElement).focus();
120:         break;
121:       }
122:       case 'ArrowUp': {
123:         event.preventDefault();
124:         const prevIndex = currentIndex > 0 ? currentIndex - 1 : optionElements.length - 1;
125:         (optionElements[prevIndex] as HTMLElement).focus();
126:         break;
127:       }
128:       case 'Enter':
129:       case 'Space': {
130:         event.preventDefault();
131:         const focusedOption = document.activeElement as HTMLDivElement;
132:         if (focusedOption?.dataset?.value) {
133:           const optionValue = focusedOption.dataset.value;
134:           const foundOption = options.find(opt => opt.value === optionValue);
135:           if (foundOption) {
136:             handleSelect(foundOption);
137:           }
138:         }
139:         break;
140:       }
141:       case 'Escape': {
142:         event.preventDefault();
143:         setIsOpen(false);
144:         break;
145:       }
146:     }
147:   }, [handleSelect, options]);
148:   useEffect(() => {
149:     if (isOpen) {
150:       document.addEventListener('keydown', handleKeyDown);
151:       return () => document.removeEventListener('keydown', handleKeyDown);
152:     }
153:   }, [isOpen, handleKeyDown]);
154:   const getSelectedLabel = () => {
155:     if (multiple) {
156:       const selectedCount = Array.isArray(value) ? value.length : 0;
157:       return selectedCount > 0
158:         ? `${selectedCount} selected`
159:         : placeholder;
160:     }
161:     const selectedOption = options.find(opt => opt.value === value);
162:     return selectedOption ? selectedOption.label : placeholder;
163:   };
164:   const isSelected = (optionValue: string) => {
165:     if (multiple) {
166:       return Array.isArray(value) && value.includes(optionValue);
167:     }
168:     return value === optionValue;
169:   };
170:   return (
171:     <div
172:       ref={dropdownRef}
173:       className={cn(
174:         styles.dropdown,
175:         styles[size],
176:         disabled && styles.disabled,
177:         className
178:       )}
179:     >
180:       {trigger ? (
181:         <div
182:           onClick={() => !disabled && setIsOpen(!isOpen)}
183:           className={cn(styles.trigger, isOpen && styles.active)}
184:         >
185:           {trigger}
186:         </div>
187:       ) : (
188:         <button
189:           type="button"
190:           className={cn(
191:             styles.button,
192:             isOpen && styles.active,
193:             size && styles[size],
194:             disabled && styles.disabled,
195:             className
196:           )}
197:           onClick={() => !disabled && setIsOpen(!isOpen)}
198:           aria-haspopup="listbox"
199:           aria-expanded={isOpen}
200:           disabled={disabled}
201:           title={title}
202:         >
203:           <span className={styles.buttonLabel}>{getSelectedLabel()}</span>
204:           <ChevronDown
205:             size={16}
206:             className={cn(styles.chevron, isOpen && styles.chevronOpen)}
207:           />
208:         </button>
209:       )}
210:       {isOpen && (
211:         <div
212:           ref={menuRef}
213:           className={cn(styles.menu, menuClassName)}
214:           style={{ maxHeight }}
215:           role="listbox"
216:           aria-multiselectable={multiple}
217:         >
218:           {options.map((option) => (
219:             <div
220:               key={option.value}
221:               className={cn(
222:                 styles.option,
223:                 isSelected(option.value) && styles.selected,
224:                 option.disabled && styles.disabled
225:               )}
226:               onClick={() => handleSelect(option)}
227:               role="option"
228:               aria-selected={isSelected(option.value)}
229:               tabIndex={0}
230:               data-value={option.value}
231:             >
232:               {option.icon && (
233:                 <span className={styles.optionIcon}>{option.icon}</span>
234:               )}
235:               <span className={styles.optionLabel}>{option.label}</span>
236:               {multiple && isSelected(option.value) && (
237:                 <span className={styles.checkmark}>✓</span>
238:               )}
239:             </div>
240:           ))}
241:         </div>
242:       )}
243:     </div>
244:   );
245: };

================
File: src/components/ui/Dropdown/index.ts
================
1: export { Dropdown } from './Dropdown';
2: export type { DropdownOption, DropdownProps } from './Dropdown';

================
File: src/components/ui/DropdownMenu/DropdownAdapter.tsx
================
 1: import React from 'react';
 2: import { FileText, FileCode, Code } from 'lucide-react';
 3: import { DropdownMenu, DropdownMenuProps } from './DropdownMenu';
 4: import styles from './DropdownMenu.module.css';
 5: // Extend original props with renderHeader from DropdownMenuProps
 6: interface DropdownAdapterProps extends Omit<DropdownMenuProps, 'options' | 'onChange'> {
 7:   options: {
 8:     value: string;
 9:     label: string;
10:     description?: string;
11:     icon?: string;
12:     disabled?: boolean;
13:   }[];
14:   value?: string | undefined;
15:   onChange: (value: string | string[]) => void;
16:   placeholder?: string;
17:   multiple?: boolean;
18:   title?: string;
19:   className?: string;
20:   menuClassName?: string;
21:   size?: 'sm' | 'md' | 'lg';
22:   disabled?: boolean;
23:   side?: 'top' | 'bottom' | 'auto';
24:   sideOffset?: number;
25:   align?: 'start' | 'center' | 'end';
26:   renderHeader?: () => React.ReactNode;
27: }
28: export const DropdownAdapter: React.FC<DropdownAdapterProps> = ({
29:   options,
30:   value,
31:   onChange,
32:   placeholder = 'Select option',
33:   title,
34:   className,
35:   menuClassName,
36:   size = 'md',
37:   disabled = false,
38:   side = 'auto',
39:   sideOffset = 5,
40:   align = 'start',
41:   renderHeader,
42: }) => {
43:   // Map option icons to Lucide components
44:   const getIconForOption = (option: { value: string; icon?: string }) => {
45:     switch (option.value) {
46:       case 'xml':
47:         return <Code size={16} className={styles.itemIcon} aria-hidden="true" />;
48:       case 'markdown':
49:         return <FileCode size={16} className={styles.itemIcon} aria-hidden="true" />;
50:       case 'plain':
51:         return <FileText size={16} className={styles.itemIcon} aria-hidden="true" />;
52:       default:
53:         return null;
54:     }
55:   };
56:   // Convert options to the format expected by the new DropdownMenu
57:   const dropdownOptions = options.map(option => ({
58:     value: option.value,
59:     label: option.label,
60:     icon: getIconForOption(option),
61:     disabled: option.disabled,
62:   }));
63:   // Handle onChange adaptation if needed (string vs string[])
64:   // Assuming DropdownMenu now only handles single string value based on its reverted state
65:   const handleDropdownChange = (val: string) => {
66:     onChange(val);
67:   };
68:   return (
69:     <DropdownMenu
70:       options={dropdownOptions}
71:       value={value as string}
72:       onChange={handleDropdownChange}
73:       placeholder={placeholder}
74:       title={title}
75:       className={className}
76:       menuClassName={menuClassName}
77:       size={size}
78:       disabled={disabled}
79:       align={align}
80:       side={side}
81:       sideOffset={sideOffset}
82:       renderHeader={renderHeader}
83:     />
84:   );
85: };

================
File: src/components/ui/DropdownMenu/DropdownMenu.tsx
================
  1: import React, { useState, useRef, useEffect, useCallback } from 'react';
  2: import { createPortal } from 'react-dom';
  3: import { Plus } from 'lucide-react';
  4: import styles from './DropdownMenu.module.css';
  5: // Main types
  6: export interface DropdownMenuOption {
  7:   value: string;
  8:   label: string;
  9:   description?: string;
 10:   icon?: React.ReactNode;
 11:   disabled?: boolean;
 12: }
 13: export interface DropdownMenuProps {
 14:   /**
 15:    * Options to display in the dropdown menu
 16:    */
 17:   options: DropdownMenuOption[];
 18:   /**
 19:    * Currently selected value
 20:    */
 21:   value?: string;
 22:   /**
 23:    * Callback when selection changes
 24:    */
 25:   onChange: (value: string) => void;
 26:   /**
 27:    * Optional placeholder text when no option is selected
 28:    */
 29:   placeholder?: string;
 30:   /**
 31:    * Optional title for the dropdown button (for accessibility)
 32:    */
 33:   title?: string;
 34:   /**
 35:    * Optional custom class name for the dropdown container
 36:    */
 37:   className?: string;
 38:   /**
 39:    * Optional custom class name for the dropdown menu
 40:    */
 41:   menuClassName?: string;
 42:   /**
 43:    * Optional size variant
 44:    * @default 'md'
 45:    */
 46:   size?: 'sm' | 'md' | 'lg';
 47:   /**
 48:    * Whether the dropdown is disabled
 49:    * @default false
 50:    */
 51:   disabled?: boolean;
 52:   /**
 53:    * Custom alignment of the dropdown menu
 54:    * @default 'start'
 55:    */
 56:   align?: 'start' | 'center' | 'end';
 57:   /**
 58:    * Side to render the dropdown menu
 59:    * @default 'auto'
 60:    */
 61:   side?: 'top' | 'right' | 'bottom' | 'left' | 'auto';
 62:   /**
 63:    * Offset from the trigger element
 64:    * @default 5
 65:    */
 66:   sideOffset?: number;
 67:   /** Optional function to render custom content at the top of the menu */
 68:   renderHeader?: () => React.ReactNode;
 69: }
 70: export const DropdownMenu: React.FC<DropdownMenuProps> = ({
 71:   options,
 72:   value,
 73:   onChange,
 74:   placeholder = 'Select option',
 75:   title,
 76:   className,
 77:   menuClassName,
 78:   size = 'md',
 79:   disabled = false,
 80:   align = 'start',
 81:   side = 'auto',
 82:   sideOffset = 5,
 83:   renderHeader,
 84: }) => {
 85:   // State
 86:   const [isOpen, setIsOpen] = useState(false);
 87:   const [position, setPosition] = useState<React.CSSProperties>({});
 88:   const [dropdownSide, setDropdownSide] = useState<'top' | 'bottom'>('bottom');
 89:   const [isClosing, setIsClosing] = useState(false);
 90:   // Refs
 91:   const triggerRef = useRef<HTMLButtonElement>(null);
 92:   const menuRef = useRef<HTMLDivElement>(null);
 93:   const firstItemRef = useRef<HTMLDivElement>(null);
 94:   // Get the label of the selected option
 95:   const getSelectedLabel = () => {
 96:     const selectedOption = options.find(opt => opt.value === value);
 97:     return selectedOption ? selectedOption.label : placeholder;
 98:   };
 99:   // Define closeDropdown
100:   const closeDropdown = useCallback(() => {
101:     if (!isOpen) return;
102:     setIsClosing(true);
103:     setTimeout(() => {
104:       setIsOpen(false);
105:       setIsClosing(false);
106:     }, 150);
107:   }, [isOpen]);
108:   // Determine the best side for the dropdown based on available space
109:   const determineDropdownSide = useCallback(() => {
110:     if (side !== 'auto') return side;
111:     if (!triggerRef.current) return 'bottom';
112:     const rect = triggerRef.current.getBoundingClientRect();
113:     const spaceBelow = window.innerHeight - rect.bottom;
114:     const spaceAbove = rect.top;
115:     const menuHeight = menuRef.current?.getBoundingClientRect().height || 200; // Default height estimate
116:     // If there's not enough space below and more space above, flip to top
117:     if (spaceBelow < menuHeight && spaceAbove > spaceBelow) {
118:       return 'top';
119:     }
120:     return 'bottom';
121:   }, [side]);
122:   // Calculate position of the dropdown menu
123:   const calculatePosition = useCallback(() => {
124:     if (!triggerRef.current || !menuRef.current) return {};
125:     const triggerRect = triggerRef.current.getBoundingClientRect();
126:     const menuRect = menuRef.current.getBoundingClientRect();
127:     const { top, left, bottom, right, width } = triggerRect;
128:     const { innerWidth, innerHeight } = window;
129:     const scrollY = window.scrollY || document.documentElement.scrollTop;
130:     const scrollX = window.scrollX || document.documentElement.scrollLeft;
131:     const positionStyles: React.CSSProperties = {};
132:     const determinedSide = determineDropdownSide();
133:     setDropdownSide(determinedSide === 'top' ? 'top' : 'bottom');
134:     // Vertical positioning
135:     if (determinedSide === 'top') {
136:       positionStyles.bottom = innerHeight - top + sideOffset;
137:     } else if (determinedSide === 'bottom') {
138:       positionStyles.top = bottom + scrollY + sideOffset;
139:     } else if (determinedSide === 'right') {
140:       positionStyles.left = right + scrollX + sideOffset;
141:     } else if (determinedSide === 'left') {
142:       positionStyles.right = innerWidth - left + scrollX + sideOffset;
143:     }
144:     // Horizontal alignment
145:     if ((determinedSide === 'top' || determinedSide === 'bottom') && !positionStyles.left && !positionStyles.right) {
146:       switch (align) {
147:         case 'start':
148:           positionStyles.left = left + scrollX;
149:           break;
150:         case 'center':
151:           positionStyles.left = left + scrollX + (width / 2) - (menuRect.width / 2);
152:           break;
153:         case 'end':
154:           positionStyles.left = left + scrollX + width - menuRect.width;
155:           break;
156:       }
157:     }
158:     // Ensure the menu stays within viewport bounds
159:     if (positionStyles.left !== undefined) {
160:       const leftPos = positionStyles.left as number;
161:       positionStyles.left = Math.max(sideOffset, Math.min(leftPos, innerWidth - menuRect.width - sideOffset));
162:     }
163:     if (positionStyles.top !== undefined) {
164:       const topPos = positionStyles.top as number;
165:       positionStyles.top = Math.max(sideOffset, Math.min(topPos, innerHeight - menuRect.height - sideOffset + scrollY));
166:     }
167:     return positionStyles;
168:   }, [align, determineDropdownSide, sideOffset]);
169:   // Update position when needed
170:   const updatePosition = useCallback(() => {
171:     if (isOpen) {
172:       setPosition(calculatePosition());
173:     }
174:   }, [isOpen, calculatePosition]);
175:   // Handle outside clicks
176:   useEffect(() => {
177:     const handleClickOutside = (event: MouseEvent) => {
178:       if (menuRef.current && !menuRef.current.contains(event.target as Node) &&
179:           triggerRef.current && !triggerRef.current.contains(event.target as Node)) {
180:         closeDropdown();
181:       }
182:     };
183:     if (isOpen) {
184:       document.addEventListener('mousedown', handleClickOutside);
185:       return () => document.removeEventListener('mousedown', handleClickOutside);
186:     }
187:   }, [isOpen, closeDropdown]);
188:   // Handle window resize and scroll
189:   useEffect(() => {
190:     if (isOpen) {
191:       window.addEventListener('resize', updatePosition);
192:       window.addEventListener('scroll', updatePosition, true);
193:       return () => {
194:         window.removeEventListener('resize', updatePosition);
195:         window.removeEventListener('scroll', updatePosition, true);
196:       };
197:     }
198:   }, [isOpen, updatePosition]);
199:   // Update position and focus first item when opening
200:   useEffect(() => {
201:     if (isOpen) {
202:       updatePosition();
203:       // Focus the first non-disabled item
204:       setTimeout(() => {
205:         firstItemRef.current?.focus();
206:       }, 10); 
207:     }
208:   }, [isOpen, updatePosition]);
209:   // Handle keyboard navigation on trigger button
210:   const handleKeyDown = (e: React.KeyboardEvent) => {
211:     if (disabled) return;
212:     switch (e.key) {
213:       case 'Enter':
214:       case ' ':
215:         e.preventDefault();
216:         setIsOpen(prev => !prev);
217:         break;
218:       case 'Escape':
219:         e.preventDefault();
220:         closeDropdown();
221:         break;
222:       case 'ArrowDown':
223:       case 'ArrowUp':
224:         if (!isOpen) {
225:           e.preventDefault();
226:           setIsOpen(true);
227:         } else {
228:             const menuItems = menuRef.current?.querySelectorAll('[role="menuitem"]:not([aria-disabled="true"])');
229:             if (menuItems && menuItems.length > 0) {
230:                 e.preventDefault();
231:                 const targetIndex = e.key === 'ArrowUp' ? menuItems.length - 1 : 0;
232:                 (menuItems[targetIndex] as HTMLElement)?.focus();
233:             }
234:         }
235:         break;
236:     }
237:   };
238:   // Handle key navigation within the menu
239:   const handleMenuKeyDown = (e: React.KeyboardEvent, option: DropdownMenuOption) => {
240:     if (option.disabled) return;
241:     switch (e.key) {
242:       case 'Enter':
243:       case ' ':
244:         e.preventDefault();
245:         handleSelect(option);
246:         break;
247:       case 'Escape':
248:         e.preventDefault();
249:         closeDropdown();
250:         triggerRef.current?.focus();
251:         break;
252:       case 'ArrowDown':
253:         e.preventDefault();
254:         focusNextItem();
255:         break;
256:       case 'ArrowUp':
257:         e.preventDefault();
258:         focusPreviousItem();
259:         break;
260:       case 'Tab':
261:         closeDropdown();
262:         break;
263:     }
264:   };
265:   // Focus the next menu item
266:   const focusNextItem = () => {
267:     const menuItems = menuRef.current?.querySelectorAll('[role="menuitem"]:not([aria-disabled="true"])');
268:     if (!menuItems || menuItems.length === 0) return;
269:     const activeElement = document.activeElement;
270:     const currentIndex = Array.from(menuItems).findIndex(item => item === activeElement);
271:     const nextIndex = currentIndex + 1 < menuItems.length ? currentIndex + 1 : 0;
272:     (menuItems[nextIndex] as HTMLElement)?.focus();
273:   };
274:   // Focus the previous menu item
275:   const focusPreviousItem = () => {
276:     const menuItems = menuRef.current?.querySelectorAll('[role="menuitem"]:not([aria-disabled="true"])');
277:     if (!menuItems || menuItems.length === 0) return;
278:     const activeElement = document.activeElement;
279:     const currentIndex = Array.from(menuItems).findIndex(item => item === activeElement);
280:     const prevIndex = currentIndex > 0 ? currentIndex - 1 : menuItems.length - 1;
281:     (menuItems[prevIndex] as HTMLElement)?.focus();
282:   };
283:   // Handle option selection
284:   const handleSelect = (option: DropdownMenuOption) => {
285:     if (option.disabled) return;
286:     onChange(option.value);
287:     closeDropdown();
288:     triggerRef.current?.focus();
289:   };
290:   // Toggle the dropdown
291:   const toggleDropdown = () => {
292:     if (!disabled) {
293:       if (isOpen) {
294:         closeDropdown();
295:       } else {
296:         setIsOpen(true);
297:       }
298:     }
299:   };
300:   return (
301:     <div className={`${styles.dropdownMenu} ${className || ''}`}>
302:       <button
303:         ref={triggerRef}
304:         className={`${styles.dropdownTrigger} ${isOpen ? styles.dropdownTriggerOpen : ''} ${size ? styles[size] : ''}`}
305:         onClick={toggleDropdown}
306:         onKeyDown={handleKeyDown}
307:         aria-haspopup="listbox"
308:         aria-expanded={isOpen}
309:         aria-labelledby={title}
310:         disabled={disabled}
311:         type="button"
312:       >
313:         <span className={styles.buttonLabel}>{getSelectedLabel()}</span>
314:         <Plus 
315:           size={16} 
316:           className={`${styles.accordionIcon} ${isOpen ? styles.rotated : ''}`} 
317:           aria-hidden="true" 
318:         />
319:       </button>
320:       {(isOpen || isClosing) && createPortal(
321:         <div 
322:           ref={menuRef}
323:           className={`${styles.dropdownContent} ${isClosing ? styles.closing : ''} ${menuClassName || ''}`}
324:           style={{
325:             ...position,
326:             width: triggerRef.current ? `${triggerRef.current.offsetWidth}px` : undefined
327:           }}
328:           role="listbox"
329:           aria-orientation="vertical"
330:           data-side={dropdownSide}
331:         >
332:           {renderHeader && renderHeader()}
333:           {options.map((option, index) => {
334:             const isSelected = option.value === value;
335:             const isFirstNonDisabled = !option.disabled && options.findIndex(o => !o.disabled) === index;
336:             return (
337:               <div
338:                 key={option.value}
339:                 ref={isFirstNonDisabled ? firstItemRef : undefined}
340:                 className={`${styles.dropdownItem} ${option.disabled ? styles.disabled : ''} ${isSelected ? styles.selected : ''}`}
341:                 onClick={() => handleSelect(option)}
342:                 onKeyDown={(e) => handleMenuKeyDown(e, option)}
343:                 role="option"
344:                 aria-selected={isSelected}
345:                 aria-disabled={option.disabled}
346:                 tabIndex={option.disabled ? -1 : 0}
347:                 data-value={option.value}
348:               >
349:                 {option.icon && (
350:                   <span className={styles.itemIcon}>{option.icon}</span>
351:                 )}
352:                 <span className={styles.itemText}>{option.label}</span>
353:               </div>
354:             );
355:           })}
356:         </div>,
357:         document.body
358:       )}
359:     </div>
360:   );
361: };

================
File: src/components/ui/DropdownMenu/index.ts
================
1: export { DropdownMenu } from "./DropdownMenu";
2: export type { DropdownMenuProps, DropdownMenuOption } from "./DropdownMenu";
3: export { DropdownAdapter } from "./DropdownAdapter";

================
File: src/components/ui/DropdownMenu/TemplateDropdownAdapter.tsx
================
 1: import React from 'react';
 2: import { 
 3:   BookText, 
 4:   FileText, 
 5:   BarChart, 
 6:   TestTube, 
 7:   CheckCircle 
 8: } from 'lucide-react';
 9: import { DropdownMenu } from './DropdownMenu';
10: import { TemplateCategory } from '../../../constants/promptTemplates';
11: import styles from './DropdownMenu.module.css';
12: // Match the interface needed for the templateSelector
13: interface TemplateDropdownAdapterProps {
14:   options: {
15:     value: string;
16:     label: string;
17:     description?: string;
18:     category: TemplateCategory;
19:     icon?: string;
20:     disabled?: boolean;
21:   }[];
22:   value?: string;
23:   onChange: (value: string) => void;
24:   placeholder?: string;
25:   title?: string;
26:   className?: string;
27:   menuClassName?: string;
28:   size?: 'sm' | 'md' | 'lg';
29:   disabled?: boolean;
30:   align?: 'start' | 'center' | 'end';
31:   side?: 'top' | 'right' | 'bottom' | 'left' | 'auto';
32:   sideOffset?: number;
33: }
34: export const TemplateDropdownAdapter: React.FC<TemplateDropdownAdapterProps> = ({
35:   options,
36:   value,
37:   onChange,
38:   placeholder = 'Select template',
39:   title,
40:   className,
41:   menuClassName,
42:   size = 'md',
43:   disabled = false,
44:   align = 'start',
45:   side = 'bottom',
46:   sideOffset = 5,
47: }) => {
48:   // Map category to Lucide component icons with enhanced visibility
49:   const getIconForCategory = (category: TemplateCategory) => {
50:     const iconProps = {
51:       size: 18,
52:       className: `${styles.itemIcon} ${styles.categoryIcon}`,
53:       strokeWidth: 2,
54:       'aria-hidden': true,
55:     };
56:     switch (category) {
57:       case 'Code Review':
58:         return <BookText {...iconProps} />;
59:       case 'Documentation Generation':
60:         return <FileText {...iconProps} />;
61:       case 'Analysis and Improvement':
62:         return <BarChart {...iconProps} />;
63:       case 'Testing':
64:         return <TestTube {...iconProps} />;
65:       case 'Code Quality':
66:         return <CheckCircle {...iconProps} />;
67:       default:
68:         return null;
69:     }
70:   };
71:   // Convert options to the format expected by DropdownMenu
72:   const dropdownOptions = options.map(option => ({
73:     value: option.value,
74:     label: option.label,
75:     description: option.description,
76:     icon: getIconForCategory(option.category),
77:     disabled: option.disabled,
78:   }));
79:   return (
80:     <DropdownMenu
81:       options={dropdownOptions}
82:       value={value}
83:       onChange={onChange}
84:       placeholder={placeholder}
85:       title={title}
86:       className={`${styles.templateDropdown} ${className || ''}`}
87:       menuClassName={`${styles.templateDropdownMenu} ${menuClassName || ''}`}
88:       size={size}
89:       disabled={disabled}
90:       align={align}
91:       side={side}
92:       sideOffset={sideOffset}
93:     />
94:   );
95: };

================
File: src/components/ui/Input/index.ts
================
1: export * from './Input';

================
File: src/components/ui/Input/Input.module.css
================
 1: .inputWrapper {
 2:   position: relative;
 3:   display: flex;
 4:   width: 100%;
 5: }
 6: .input {
 7:   width: 100%;
 8:   height: var(--button-height-md);
 9:   padding: 0 12px;
10:   border: 1px solid var(--border-color);
11:   border-radius: var(--radius);
12:   font-family: inherit;
13:   font-size: 14px;
14:   outline: none;
15:   background-color: var(--background-primary);
16:   color: var(--text-primary);
17:   transition: all 0.2s ease;
18: }
19: .input:hover:not(:disabled) {
20:   border-color: var(--text-secondary);
21: }
22: .input:focus {
23:   outline: none;
24:   border-color: var(--ring-color);
25:   box-shadow: 0 0 0 2px var(--background-primary),
26:               0 0 0 4px var(--ring-color);
27: }
28: .input:disabled {
29:   opacity: 0.5;
30:   cursor: not-allowed;
31:   background-color: var(--background-secondary);
32: }
33: .withStartIcon {
34:   padding-left: 36px;
35: }
36: .withEndIcon {
37:   padding-right: 36px;
38: }
39: .startIcon,
40: .endIcon {
41:   position: absolute;
42:   top: 50%;
43:   transform: translateY(-50%);
44:   color: var(--text-secondary);
45:   display: flex;
46:   align-items: center;
47:   justify-content: center;
48:   pointer-events: none;
49:   width: 36px;
50: }
51: .startIcon {
52:   left: 0;
53: }
54: .endIcon {
55:   right: 0;
56: }
57: .inputError {
58:   border-color: var(--error-color);
59: }
60: .inputError:focus {
61:   border-color: var(--error-color);
62:   box-shadow: 0 0 0 2px var(--background-primary),
63:               0 0 0 4px var(--error-color);
64: }
65: /* Search input specific styles */
66: .searchInput {
67:   padding-left: 36px;
68:   background-color: var(--background-secondary);
69:   border-color: transparent;
70: }
71: .searchInput:focus {
72:   background-color: var(--background-primary);
73:   border-color: var(--ring-color);
74: }

================
File: src/components/ui/Input/Input.tsx
================
 1: import React from 'react';
 2: import { cn } from '../../../utils/cn';
 3: import styles from './Input.module.css';
 4: export interface InputProps extends Omit<React.InputHTMLAttributes<HTMLInputElement>, 'size'> {
 5:   /**
 6:    * Shows error styling
 7:    */
 8:   error?: boolean;
 9:   /**
10:    * Icon to display at the start of the input
11:    */
12:   startIcon?: React.ReactNode;
13:   /**
14:    * Icon to display at the end of the input
15:    */
16:   endIcon?: React.ReactNode;
17:   /**
18:    * Applies search input styling
19:    */
20:   isSearchInput?: boolean;
21: }
22: /**
23:  * Input component for text entry
24:  */
25: export const Input = React.forwardRef<HTMLInputElement, InputProps>(
26:   ({ className, error, startIcon, endIcon, isSearchInput, ...props }, ref) => {
27:     return (
28:       <div className={styles.inputWrapper}>
29:         {startIcon && <div className={styles.startIcon}>{startIcon}</div>}
30:         <input
31:           className={cn(
32:             styles.input,
33:             startIcon ? styles.withStartIcon : null,
34:             endIcon ? styles.withEndIcon : null,
35:             isSearchInput ? styles.searchInput : null,
36:             error ? styles.inputError : null,
37:             className
38:           )}
39:           ref={ref}
40:           {...props}
41:         />
42:         {endIcon && <div className={styles.endIcon}>{endIcon}</div>}
43:       </div>
44:     );
45:   }
46: );
47: Input.displayName = 'Input';

================
File: src/components/ui/Switch/index.ts
================
1: export * from './Switch';

================
File: src/components/ui/Switch/Switch.module.css
================
 1: .switchContainer {
 2:   display: inline-flex;
 3:   align-items: center;
 4: }
 5: .switchLabel {
 6:   margin-right: 8px;
 7:   font-size: 14px;
 8:   color: var(--text-primary);
 9: }
10: .switch {
11:   position: relative;
12:   display: inline-flex;
13:   width: 36px;
14:   height: 20px;
15:   border-radius: var(--radius-full);
16:   background-color: var(--text-disabled);
17:   transition: background-color 0.2s ease;
18:   cursor: pointer;
19: }
20: .switchChecked {
21:   background-color: var(--accent-color);
22: }
23: .switch:focus-visible {
24:   outline: none;
25:   box-shadow: 0 0 0 2px var(--background-primary),
26:               0 0 0 4px var(--ring-color);
27: }
28: .switchDisabled {
29:   opacity: 0.5;
30:   cursor: not-allowed;
31: }
32: .switchThumb {
33:   position: absolute;
34:   top: 3px;
35:   left: 3px;
36:   width: 14px;
37:   height: 14px;
38:   border-radius: var(--radius-full);
39:   background-color: var(--background-primary);
40:   box-shadow: var(--shadow-sm);
41:   transition: transform 0.2s ease;
42: }
43: .switchChecked .switchThumb {
44:   transform: translateX(16px);
45: }
46: /* Small size variant */
47: .switchSm {
48:   width: 28px;
49:   height: 16px;
50: }
51: .switchSm .switchThumb {
52:   width: 10px;
53:   height: 10px;
54:   top: 3px;
55:   left: 3px;
56: }
57: .switchSm.switchChecked .switchThumb {
58:   transform: translateX(12px);
59: }
60: /* Large size variant */
61: .switchLg {
62:   width: 44px;
63:   height: 24px;
64: }
65: .switchLg .switchThumb {
66:   width: 18px;
67:   height: 18px;
68:   top: 3px;
69:   left: 3px;
70: }
71: .switchLg.switchChecked .switchThumb {
72:   transform: translateX(20px);
73: }

================
File: src/components/ui/Switch/Switch.tsx
================
 1: import React from 'react';
 2: import { cn } from '../../../utils/cn';
 3: import styles from './Switch.module.css';
 4: export interface SwitchProps {
 5:   /**
 6:    * Whether the switch is checked
 7:    */
 8:   checked: boolean;
 9:   /**
10:    * Function called when the switch is toggled
11:    */
12:   onChange: (checked?: boolean) => void;
13:   /**
14:    * Optional label to display beside the switch
15:    */
16:   label?: string;
17:   /**
18:    * Disables the switch
19:    */
20:   disabled?: boolean;
21:   /**
22:    * Optional additional className
23:    */
24:   className?: string;
25:   /**
26:    * Optional ID for the switch
27:    */
28:   id?: string;
29:   /**
30:    * Optional title tooltip for the switch
31:    */
32:   title?: string;
33:   /**
34:    * Optional size for the switch (sm, md, lg)
35:    */
36:   size?: 'sm' | 'md' | 'lg';
37: }
38: /**
39:  * Switch component for toggling between two states
40:  */
41: export const Switch: React.FC<SwitchProps> = ({
42:   checked,
43:   onChange,
44:   label,
45:   disabled = false,
46:   className,
47:   id,
48:   size = 'md',
49:   title
50: }) => {
51:   const switchId = id || `switch-${Math.random().toString(36).substring(2, 9)}`;
52:   return (
53:     <div className={cn(styles.switchContainer, className)}>
54:       {label && (
55:         <label htmlFor={switchId} className={styles.switchLabel}>
56:           {label}
57:         </label>
58:       )}
59:       <div
60:         className={cn(
61:           styles.switch,
62:           checked && styles.switchChecked,
63:           disabled && styles.switchDisabled,
64:           size === 'sm' && styles.switchSm,
65:           size === 'lg' && styles.switchLg
66:         )}
67:         role="switch"
68:         aria-checked={checked}
69:         aria-disabled={disabled}
70:         tabIndex={disabled ? -1 : 0}
71:         onClick={disabled ? undefined : () => onChange(!checked)}
72:         onKeyDown={(e) => {
73:           if (disabled) return;
74:           if (e.key === 'Enter' || e.key === ' ') {
75:             e.preventDefault();
76:             onChange(!checked);
77:           }
78:         }}
79:         id={switchId}
80:         title={title}
81:       >
82:         <div className={styles.switchThumb} />
83:       </div>
84:     </div>
85:   );
86: };
87: Switch.displayName = 'Switch';

================
File: src/components/ui/Tabs/index.ts
================
1: export { Tabs } from './Tabs';
2: export { TabsList } from './TabsList';
3: export { TabsTrigger } from './TabsTrigger';
4: export { TabsContent } from './TabsContent';
5: export { useTabs } from './useTabs';
6: export type { TabsContextProps } from './useTabs';

================
File: src/components/ui/Tabs/Tabs.module.css
================
  1: /* Tabs component styling */
  2: .tabs {
  3:   width: 100%;
  4:   position: relative; /* Required for absolute positioning of children */
  5: }
  6: .tabsList {
  7:   display: flex;
  8:   align-items: center;
  9:   border-bottom: 1px solid var(--border-color);
 10:   margin-bottom: 0; /* Reduced margin for more compact layout */
 11:   background-color: var(--background-secondary);
 12:   border-top-left-radius: var(--radius);
 13:   border-top-right-radius: var(--radius);
 14:   padding: 4px 4px 0; /* Padding for tabs container */
 15:   gap: 2px; /* Small gap between tabs */
 16: }
 17: .tabsTrigger {
 18:   padding: 6px 12px;
 19:   background-color: var(--background-tertiary, rgba(0,0,0,0.05));
 20:   color: var(--text-secondary);
 21:   cursor: pointer;
 22:   font-size: 13px;
 23:   font-weight: 500;
 24:   transition: all 0.15s ease;
 25:   white-space: nowrap;
 26:   border-radius: 4px 4px 0 0;
 27:   border: 1px solid transparent;
 28:   border-bottom: none;
 29:   position: relative;
 30:   display: flex;
 31:   align-items: center;
 32:   justify-content: center;
 33:   user-select: none;
 34: }
 35: .tabsTrigger:hover:not(:disabled) {
 36:   color: var(--text-primary);
 37:   background-color: var(--background-hover, rgba(0,0,0,0.03));
 38: }
 39: .tabsTrigger.active {
 40:   color: var(--text-primary);
 41:   background-color: var(--background-primary);
 42:   border-color: var(--border-color);
 43:   border-bottom-color: var(--background-primary);
 44:   font-weight: 600;
 45:   z-index: 2; /* Ensure active tab is on top */
 46: }
 47: .tabsTrigger:focus-visible {
 48:   outline: 2px solid var(--accent-color);
 49:   outline-offset: -1px;
 50:   z-index: 3;
 51: }
 52: .tabsTrigger:disabled {
 53:   color: var(--text-disabled);
 54:   cursor: not-allowed;
 55:   opacity: 0.6;
 56: }
 57: /* Tab content container - establishes the positioning context */
 58: .tabsContentWrapper {
 59:   position: relative;
 60:   width: 100%;
 61:   border: 1px solid var(--border-color);
 62:   border-top: none;
 63:   background-color: var(--background-primary);
 64:   border-bottom-left-radius: var(--radius);
 65:   border-bottom-right-radius: var(--radius);
 66:   overflow: hidden; /* Prevent content from bleeding out */
 67: }
 68: /* Individual tab content panel */
 69: .tabsContent {
 70:   padding: 12px; /* Slightly reduced padding */
 71:   outline: none;
 72:   transition: opacity 150ms ease-in-out;
 73: }
 74: /* Styles for active/inactive tab content */
 75: .activeContent {
 76:   opacity: 1;
 77:   z-index: 2;
 78: }
 79: .inactiveContent {
 80:   opacity: 0;
 81:   z-index: 1;
 82:   /* Position absolute was causing issues - we'll fix it differently */
 83:   display: none;
 84:   pointer-events: none;
 85: }
 86: /* Style for subheadings within merged tabs */
 87: .subHeading {
 88:   font-size: 13px;
 89:   font-weight: 600;
 90:   color: var(--text-primary);
 91:   margin-top: 8px;
 92:   margin-bottom: 12px;
 93:   padding-bottom: 6px;
 94:   border-bottom: 1px dashed var(--border-color-subtle, rgba(128,128,128,0.3));
 95: }
 96: /* Style for divider within merged tabs */
 97: .divider {
 98:   border: none;
 99:   border-top: 1px solid var(--border-color);
100:   margin: 16px 0;
101: }
102: /* Add support for icons in tabs */
103: .tabIcon {
104:   margin-right: 6px;
105:   display: flex;
106:   align-items: center;
107: }

================
File: src/components/ui/Tabs/Tabs.tsx
================
 1: import React, { useState, ReactNode } from 'react';
 2: import { TabsContext } from './useTabs';
 3: import styles from './Tabs.module.css';
 4: interface TabsProps {
 5:   defaultValue: string;
 6:   children: ReactNode;
 7:   className?: string;
 8: }
 9: // Main Tabs component managing state
10: const Tabs: React.FC<TabsProps> = ({ defaultValue, children, className }) => {
11:   const [activeTab, setActiveTab] = useState<string>(defaultValue);
12:   return (
13:     <TabsContext.Provider value={{ activeTab, setActiveTab }}>
14:       <div className={`${styles.tabs} ${className || ''}`}>
15:         {children}
16:       </div>
17:     </TabsContext.Provider>
18:   );
19: };
20: // Add display name for better debugging and component type detection
21: Tabs.displayName = 'Tabs';
22: export { Tabs };

================
File: src/components/ui/Tabs/TabsContent.tsx
================
 1: import React, { ReactNode } from 'react';
 2: import { useTabs } from './useTabs';
 3: import styles from './Tabs.module.css';
 4: interface TabsContentProps {
 5:   value: string;
 6:   children: ReactNode;
 7:   className?: string;
 8: }
 9: // Content panel for each tab
10: const TabsContent: React.FC<TabsContentProps> = ({ value, children, className }) => {
11:   const { activeTab } = useTabs(); // Get state from context
12:   const isActive = activeTab === value;
13:   // Use display:none via CSS classes instead of absolute positioning
14:   // This avoids layout issues when tabs have different heights
15:   return (
16:     <div
17:       id={`tab-content-${value}`} // Linked from trigger
18:       role="tabpanel"
19:       aria-labelledby={`tab-trigger-${value}`} 
20:       aria-hidden={!isActive}
21:       tabIndex={isActive ? 0 : -1}
22:       className={`${styles.tabsContent} ${isActive ? styles.activeContent : styles.inactiveContent} ${className || ''}`}
23:     >
24:       {children}
25:     </div>
26:   );
27: };
28: // Add display name for better debugging and component type detection
29: TabsContent.displayName = 'TabsContent';
30: export { TabsContent };

================
File: src/components/ui/Tabs/TabsList.tsx
================
 1: import React, { ReactNode, Children, useRef, useEffect, KeyboardEvent } from 'react';
 2: import { useTabs } from './useTabs';
 3: import styles from './Tabs.module.css';
 4: interface TabsListProps {
 5:   children: ReactNode;
 6:   className?: string;
 7:   'aria-label'?: string;
 8: }
 9: // Container for the tab triggers
10: const TabsList: React.FC<TabsListProps> = ({ children, className, 'aria-label': ariaLabel }) => {
11:   const { activeTab, setActiveTab } = useTabs();
12:   const triggersRef = useRef<(HTMLButtonElement | null)[]>([]);
13:   const childrenArray = Children.toArray(children);
14:   // Ensure triggersRef array is the correct size
15:   useEffect(() => {
16:     triggersRef.current = triggersRef.current.slice(0, childrenArray.length);
17:   }, [childrenArray.length]);
18:   const handleKeyDown = (event: KeyboardEvent<HTMLDivElement>) => {
19:     const currentIndex = childrenArray.findIndex(
20:       (child) => React.isValidElement(child) && child.props.value === activeTab
21:     );
22:     if (currentIndex === -1) return;
23:     let nextIndex = -1;
24:     if (event.key === 'ArrowRight') {
25:       nextIndex = (currentIndex + 1) % childrenArray.length;
26:     } else if (event.key === 'ArrowLeft') {
27:       nextIndex = (currentIndex - 1 + childrenArray.length) % childrenArray.length;
28:     } else if (event.key === 'Home') {
29:       nextIndex = 0;
30:     } else if (event.key === 'End') {
31:       nextIndex = childrenArray.length - 1;
32:     }
33:     if (nextIndex !== -1) {
34:       event.preventDefault();
35:       const nextTrigger = triggersRef.current[nextIndex];
36:       if (nextTrigger) {
37:         nextTrigger.focus();
38:         // Optionally activate on arrow navigation (common pattern)
39:         const nextChild = childrenArray[nextIndex];
40:         if (React.isValidElement(nextChild)) {
41:           setActiveTab(nextChild.props.value);
42:         }
43:       }
44:     }
45:   };
46:   return (
47:     <div
48:       className={`${styles.tabsList} ${className || ''}`}
49:       role="tablist"
50:       aria-label={ariaLabel}
51:       onKeyDown={handleKeyDown}
52:     >
53:       {Children.map(childrenArray, (child, index) => {
54:         if (React.isValidElement(child)) {
55:           return React.cloneElement(child as React.ReactElement<any>, {
56:             ref: (el: HTMLButtonElement | null) => triggersRef.current[index] = el,
57:           });
58:         }
59:         return child;
60:       })}
61:     </div>
62:   );
63: };
64: // Add display name for better debugging and component type detection
65: TabsList.displayName = 'TabsList';
66: export { TabsList };

================
File: src/components/ui/Tabs/TabsTrigger.tsx
================
 1: import React, { ReactNode, forwardRef } from 'react';
 2: import { useTabs } from './useTabs';
 3: import styles from './Tabs.module.css';
 4: interface TabsTriggerProps {
 5:   value: string;
 6:   children: ReactNode;
 7:   className?: string;
 8:   disabled?: boolean;
 9:   icon?: ReactNode; // Add support for optional icon
10: }
11: // Clickable trigger for each tab
12: const TabsTrigger = forwardRef<HTMLButtonElement, TabsTriggerProps>(
13:   ({ value, children, className, disabled, icon }, ref) => {
14:     const { activeTab, setActiveTab } = useTabs(); // Get state from context
15:     const isActive = activeTab === value;
16:     const handleClick = () => {
17:       if (!disabled) {
18:         setActiveTab(value);
19:       }
20:     };
21:     return (
22:       <button
23:         ref={ref} // Assign the forwarded ref
24:         type="button"
25:         id={`tab-trigger-${value}`} // Add ID for ARIA linkage
26:         role="tab"
27:         aria-selected={isActive}
28:         aria-controls={`tab-content-${value}`} // Link to content panel
29:         tabIndex={isActive ? 0 : -1} // Manage focus
30:         className={`${styles.tabsTrigger} ${isActive ? styles.active : ''} ${className || ''}`}
31:         onClick={handleClick}
32:         disabled={disabled}
33:       >
34:         {icon && <span className={styles.tabIcon}>{icon}</span>}
35:         {children}
36:       </button>
37:     );
38:   }
39: );
40: // Add display name for better debugging
41: TabsTrigger.displayName = 'TabsTrigger';
42: export { TabsTrigger };

================
File: src/components/ui/Tabs/useTabs.ts
================
 1: import { createContext, useContext } from 'react';
 2: export interface TabsContextProps {
 3:   activeTab: string;
 4:   setActiveTab: (value: string) => void;
 5: }
 6: // Create context for sharing tab state
 7: export const TabsContext = createContext<TabsContextProps | undefined>(undefined);
 8: // Hook to access tab context
 9: export const useTabs = (): TabsContextProps => {
10:   const context = useContext(TabsContext);
11:   if (!context) {
12:     throw new Error('useTabs must be used within a Tabs component');
13:   }
14:   return context;
15: };

================
File: src/components/ui/ConfirmationDialog.tsx
================
 1: import React from 'react';
 2: import { Dialog } from './Dialog'; // Use the updated Dialog
 3: import { Button } from './Button';
 4: interface ConfirmationDialogProps {
 5:   isOpen: boolean;
 6:   onClose: () => void;
 7:   onConfirm: () => void;
 8:   title: string;
 9:   description: string;
10:   confirmLabel?: string;
11:   cancelLabel?: string;
12:   variant?: 'default' | 'destructive'; // Semantic variant for the dialog itself
13: }
14: export function ConfirmationDialog({
15:   isOpen,
16:   onClose,
17:   onConfirm,
18:   title,
19:   description,
20:   confirmLabel = 'Confirm',
21:   cancelLabel = 'Cancel',
22:   variant = 'default' // This prop influences the overall dialog but not buttons directly here
23: }: ConfirmationDialogProps) {
24:   const handleConfirm = () => {
25:     onConfirm();
26:     onClose(); // Typically close after confirm
27:   };
28:   // Determine the button variant based on the dialog variant
29:   const buttonVariant = variant === 'destructive' ? 'destructive' : 'primary';
30:   return (
31:     <Dialog
32:       isOpen={isOpen}
33:       onClose={onClose}
34:       title={title}
35:       description={description}
36:       size="sm" // Keep it small for confirmations
37:       footer={ // Pass buttons as the footer content
38:         <>
39:           <Button
40:             variant="ghost" // Standard cancel button
41:             size="sm"
42:             onClick={onClose}
43:           >
44:             {cancelLabel}
45:           </Button>
46:           <Button
47:             variant={buttonVariant} // Use destructive or primary variant based on dialog variant
48:             size="sm"
49:             onClick={handleConfirm}
50:           >
51:             {confirmLabel}
52:           </Button>
53:         </>
54:       }
55:     >
56:       {/* No children needed if description covers the content */}
57:       {/* If there was more complex content, it would go here */}
58:       <div style={{ minHeight: '20px' }}></div> {/* Add some minimal height if description is short */}
59:     </Dialog>
60:   );
61: }

================
File: src/components/ui/index.ts
================
 1: export { Button } from './Button';
 2: export { Card } from './Card';
 3: export { Switch } from './Switch';
 4: export { ButtonGroup } from './ButtonGroup';
 5: export { DropdownAdapter } from './DropdownMenu/DropdownAdapter';
 6: export { Dropdown } from './Dropdown/Dropdown';
 7: export { ConfirmationDialog } from './ConfirmationDialog';
 8: export { CardHeader, CardTitle, CardDescription, CardContent, CardFooter } from './Card/Card';
 9: // Re-export Tabs components from TabsComponents
10: export { Tabs, TabsList, TabsTrigger, TabsContent } from './TabsComponents';
11: export * from './Toast';

================
File: src/components/ControlContainer.module.css
================
  1: .controlContainer {
  2:   border: 1px solid var(--border-color);
  3:   border-radius: var(--radius);
  4:   margin-bottom: 12px;
  5:   background-color: var(--background-primary);
  6:   display: flex;
  7:   flex-direction: column;
  8:   box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
  9:   overflow: hidden; /* Ensure shadows don't leak */
 10:   /* Add macOS-like vibrancy effect */
 11:   backdrop-filter: var(--backdrop-blur-md);
 12:   -webkit-backdrop-filter: var(--backdrop-blur-md);
 13: }
 14: .controlContainerHeader {
 15:   background-color: var(--background-secondary);
 16:   padding: 6px 8px; /* Smaller padding */
 17:   font-weight: 600;
 18:   color: var(--text-primary);
 19:   border-bottom: 1px solid var(--border-color);
 20:   font-size: 12px; /* Reduced from 15px */
 21:   letter-spacing: -0.01em;
 22:   display: flex; /* Enable flexbox */
 23:   align-items: center; /* Vertically center items */
 24:   justify-content: space-between; /* Space between left section and centered buttons */
 25:   height: 30px; /* Fixed height for smaller header */
 26:   /* Add macOS-like vibrancy effect */
 27:   backdrop-filter: var(--backdrop-blur-sm);
 28:   -webkit-backdrop-filter: var(--backdrop-blur-sm);
 29: }
 30: /* Left part of header with Controls text and toggle */
 31: .controlHeaderLeft {
 32:   display: flex;
 33:   align-items: center;
 34:   gap: 8px;
 35: }
 36: /* Header actions - now on the left */
 37: .headerActionButtons {
 38:   display: flex;
 39:   margin-left: 6px;
 40: }
 41: /* Instructions section at the top */
 42: .controlInstructions {
 43:   padding: 6px 10px; /* Reduced padding */
 44:   border-bottom: 1px solid var(--border-color);
 45:   background-color: var(--background-primary);
 46:   font-size: var(--font-size-xs); /* Smaller font */
 47: }
 48: /* Tabs container */
 49: .controlTabs {
 50:   width: 100%;
 51: }
 52: .tabsContainer {
 53:   padding: 0;
 54: }
 55: .tabsContentWrapper {
 56:   padding: 10px; /* Reduced from 16px */
 57:   background-color: var(--background-primary);
 58:   border-bottom-left-radius: var(--radius);
 59:   border-bottom-right-radius: var(--radius);
 60: }
 61: /* Individual control items */
 62: .controlItem {
 63:   display: flex;
 64:   align-items: center;
 65:   gap: 8px;
 66:   margin-bottom: 8px; /* Smaller bottom margin */
 67:   width: 100%;
 68: }
 69: .controlItem:last-child {
 70:   margin-bottom: 0;
 71: }
 72: /* Control labels */
 73: .controlLabel {
 74:   min-width: 60px; /* Reduced from 70px */
 75:   font-weight: 500;
 76:   font-size: 10px; /* Reduced from 12px */
 77:   color: var(--text-secondary);
 78: }
 79: /* Control sizes for different importance levels */
 80: .controlPrimary {
 81:   font-weight: 500;
 82:   font-size: 11px; /* Reduced from 12px */
 83: }
 84: .controlSecondary, 
 85: .controlHelp {
 86:   font-size: 9px; /* Reduced from 10px */
 87:   color: var(--text-secondary);
 88: }
 89: /* Token usage styling */
 90: .tokenBarContainer {
 91:   height: 3px;
 92:   width: 100%;
 93:   background-color: hsl(240, 5.9%, 90%);
 94:   border-radius: 9999px;
 95:   overflow: hidden;
 96:   margin-top: 0.5rem;
 97:   position: relative;
 98: }
 99: .tokenBar {
100:   height: 100%;
101:   width: 0;
102:   background: var(--accent-color);
103:   transition: width 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
104:   border-radius: 9999px;
105: }
106: .dark .tokenBarContainer {
107:   background-color: hsl(240, 3.7%, 25%);
108: }
109: /* Token warnings */
110: .tokenWarning {
111:   color: var(--warning-color, #f59e0b);
112:   display: flex;
113:   align-items: center;
114:   font-size: 10px;
115:   margin-top: 6px; /* Reduced from 8px */
116:   font-weight: 500;
117:   padding: 4px 8px; /* Reduced padding */
118:   background-color: var(--warning-bg-color, rgba(245, 158, 11, 0.1));
119:   border-radius: var(--radius);
120: }
121: .tokenLimitWarning {
122:   margin-top: 8px; /* Reduced from 10px */
123: }
124: /* Token count text */
125: .tokenCountText {
126:   margin: 4px 0 6px 0; /* Reduced margins */
127:   font-size: 10px; /* Explicit small size */
128: }
129: /* Token usage bar */
130: .tokenUsageBar {
131:   height: 3px; /* Reduced from 4px */
132:   width: 100%;
133:   background-color: var(--background-tertiary, rgba(0, 0, 0, 0.1));
134:   border-radius: 2px;
135:   margin-bottom: 0;
136:   overflow: hidden;
137: }
138: .tokenUsageFill {
139:   height: 100%;
140:   transition: width 0.3s ease;
141: }
142: /* Token usage colors */
143: .tokenGood {
144:   color: var(--success-color, #10b981);
145: }
146: .tokenWarning {
147:   color: var(--warning-color, #f59e0b);
148: }
149: .tokenDanger {
150:   color: var(--error-color, #ef4444);
151: }
152: /* Token header */
153: .tokenHeader {
154:   display: flex;
155:   justify-content: space-between;
156:   align-items: center;
157:   margin-bottom: 6px; /* Reduced from 8px */
158:   font-size: 12px; /* Reduced from 14px */
159: }
160: /* Tiny switch class */
161: .tinySwitch {
162:   transform: scale(0.65) !important;
163:   transform-origin: left center !important;
164: }
165: /* Switch with label layout */
166: .switchWithLabel {
167:   display: flex;
168:   align-items: flex-start;
169:   gap: 6px;
170:   width: 100%;
171:   margin-bottom: 8px;
172: }
173: .switchWithLabel:last-child {
174:   margin-bottom: 0;
175: }
176: /* Model selector container */
177: .modelSelectorContainer {
178:   display: flex;
179:   align-items: center;
180:   gap: 6px;
181:   width: 100%;
182: }
183: /* Search container for local dropdowns */
184: .searchContainerLocal {
185:   display: flex;
186:   align-items: center;
187:   padding: 6px 8px;
188:   background-color: var(--background-secondary);
189:   border: 1px solid var(--border-color);
190:   border-radius: var(--radius);
191:   margin-bottom: 4px;
192:   transition: border-color 0.2s ease, box-shadow 0.2s ease;
193: }
194: .searchIconLocal {
195:   color: var(--icon-color);
196:   margin-right: 6px;
197:   flex-shrink: 0;
198:   opacity: 0.7;
199:   transition: opacity 0.2s ease;
200:   display: flex;
201:   align-items: center;
202:   justify-content: center;
203:   width: 14px;
204:   height: 14px;
205: }
206: .searchInputLocal {
207:   flex: 1;
208:   font-size: 11px;
209:   border: none;
210:   outline: none;
211:   background-color: transparent;
212:   color: var(--text-primary);
213:   padding: 2px 0;
214:   width: 100%;
215:   height: 18px;
216: }
217: .searchInputLocal:focus {
218:   border-color: var(--accent-color);
219:   box-shadow: 0 0 0 1px var(--accent-color);
220: }
221: /* Simple tabs implementation */
222: .simpleTabs {
223:   width: 100%;
224: }
225: .simpleTabsList {
226:   display: flex;
227:   border-bottom: 1px solid var(--border-color);
228:   background-color: var(--background-secondary);
229: }
230: .simpleTabsTrigger {
231:   flex: 1;
232:   display: flex;
233:   align-items: center;
234:   justify-content: center;
235:   gap: 4px;
236:   padding: 5px 8px;
237:   background: none;
238:   border: none;
239:   cursor: pointer;
240:   color: var(--text-secondary);
241:   font-size: 11px;
242:   position: relative;
243:   transition: color 0.2s;
244: }
245: .simpleTabsTrigger:hover {
246:   color: var(--text-primary);
247:   background-color: var(--hover-color);
248: }
249: .simpleTabsTriggerActive {
250:   color: var(--text-primary);
251:   font-weight: 500;
252: }
253: .simpleTabsTriggerActive::after {
254:   content: '';
255:   position: absolute;
256:   bottom: -1px;
257:   left: 0;
258:   right: 0;
259:   height: 2px;
260:   background-color: var(--accent-color);
261:   transform: scaleX(0.8);
262:   transition: transform 0.2s;
263: }
264: .simpleTabsTrigger:hover::after {
265:   transform: scaleX(1);
266: }
267: .simpleTabsContent {
268:   padding: 10px;
269: }
270: .smallerDropdown {
271:   font-size: 11px;
272:   width: auto;
273:   min-width: 120px;
274:   max-width: 160px;
275: }
276: /* Wider dropdown for model selection */
277: .modelDropdown {
278:   font-size: 11px;
279:   width: auto;
280:   min-width: 220px;
281:   max-width: 280px;
282: }
283: /* Fixed-width dropdown for consistent sizing in configure tab */
284: .configureDropdown {
285:   font-size: 11px;
286:   width: 140px;
287:   min-width: 140px;
288:   max-width: 140px;
289: }
290: .controlGroup {
291:   margin-bottom: 10px;
292:   padding-bottom: 6px;
293:   border-bottom: 1px solid var(--border-color);
294: }
295: .controlGroup:last-child {
296:   margin-bottom: 0;
297:   padding-bottom: 0;
298:   border-bottom: none;
299: }
300: .controlGroupLabel {
301:   font-size: 10px;
302:   font-weight: 600;
303:   margin-bottom: 4px;
304:   color: var(--text-secondary);
305:   text-transform: uppercase;
306:   letter-spacing: 0.02em;
307: }
308: .container {
309:   width: 100%;
310:   display: flex;
311:   flex-direction: column;
312:   height: 100%;
313:   overflow: hidden;
314: }
315: .controlHeader {
316:   display: flex;
317:   justify-content: space-between;
318:   align-items: center;
319:   padding: 0.5rem;
320: }
321: .instructionsToggle {
322:   display: flex;
323:   align-items: center;
324: }
325: .smallSwitch {
326:   height: 28px;
327: }
328: .switchContainer {
329:   width: 100%;
330:   margin-bottom: 0.75rem;
331: }
332: .switchDescription {
333:   margin-left: 36px;
334:   margin-top: 2px;
335:   font-size: 0.8rem;
336:   color: var(--text-secondary);
337: }
338: .controlRow {
339:   display: flex;
340:   align-items: center;
341:   gap: 0.5rem;
342:   margin-bottom: 0.75rem;
343: }
344: .formatDropdown {
345:   width: 100%;
346: }
347: .tokenInfo {
348:   width: 100%;
349: }
350: .tokenInfoRow {
351:   display: flex;
352:   justify-content: space-between;
353:   align-items: center;
354:   margin-bottom: 4px;
355:   font-size: 11px;
356: }
357: .tokenBarContainer {
358:   width: 100%;
359:   height: 4px; /* Reduced from 6px */
360:   background-color: var(--background-secondary);
361:   border-radius: 2px;
362:   overflow: hidden;
363:   margin-bottom: 6px;
364: }
365: .tokenBar {
366:   height: 100%;
367:   background-color: var(--success-color);
368:   border-radius: 3px;
369:   transition: width 0.3s ease;
370: }
371: .tokenGood {
372:   color: var(--success-color);
373: }
374: .tokenWarning {
375:   color: var(--warning-color);
376: }
377: .tokenDanger {
378:   color: var(--error-color);
379: }
380: .tokenBar.tokenWarning {
381:   background-color: var(--warning-color);
382: }
383: .tokenBar.tokenDanger {
384:   background-color: var(--error-color);
385: }
386: .tokenWarningMessage {
387:   display: flex;
388:   align-items: center;
389:   gap: 4px;
390:   font-size: 10px; /* Reduced from 0.85rem */
391:   color: var(--error-color);
392:   margin-bottom: 4px;
393: }
394: .optimizationInfo {
395:   display: flex;
396:   align-items: flex-start;
397:   gap: 4px;
398:   padding: 6px;
399:   background-color: var(--background-secondary);
400:   border-radius: var(--radius);
401:   font-size: 10px;
402:   color: var(--text-secondary);
403:   margin-top: 4px;
404: }
405: .infoIcon {
406:   color: var(--accent-color);
407:   flex-shrink: 0;
408:   margin-top: 1px;
409: }
410: .controlActions {
411:   display: flex;
412:   flex-wrap: wrap;
413:   gap: 0.5rem;
414: }
415: .actionButton {
416:   flex: 1;
417:   min-width: 80px;
418: }
419: .refreshButton {
420:   color: var(--text-secondary);
421: }
422: .spinner {
423:   animation: spin 1s linear infinite;
424: }
425: @keyframes spin {
426:   from {
427:     transform: rotate(0deg);
428:   }
429:   to {
430:     transform: rotate(360deg);
431:   }
432: }
433: /* Search styling improvements */
434: .searchContainerLocal:focus-within {
435:   border-color: var(--accent-color);
436:   box-shadow: 0 0 0 1px var(--accent-color);
437: }
438: .searchInputLocal::placeholder {
439:   color: var(--text-secondary);
440:   opacity: 0.7;
441: }
442: .searchContainerLocal:focus-within .searchIconLocal {
443:   opacity: 1;
444: }
445: /* Styles for new compression UI elements */
446: .numberInput {
447:   width: 80px;
448:   padding: 4px 6px;
449:   border: 1px solid var(--border-color);
450:   border-radius: var(--radius);
451:   background-color: var(--background-secondary);
452:   color: var(--text-primary);
453:   font-size: 11px;
454:   height: 24px;
455: }
456: .patternsTextarea {
457:   width: 100%;
458:   min-height: 60px;
459:   max-height: 120px;
460:   resize: vertical;
461:   padding: 6px 8px;
462:   border: 1px solid var(--border-color);
463:   border-radius: var(--radius);
464:   background-color: var(--background-secondary);
465:   color: var(--text-primary);
466:   font-size: 11px;
467:   font-family: var(--font-mono, monospace);
468:   margin-bottom: 4px;
469:   line-height: 1.4;
470:   white-space: pre;
471:   tab-size: 2;
472:   letter-spacing: normal;
473:   text-rendering: auto;
474: }

================
File: src/components/ErrorBoundary.tsx
================
 1: import React, { Component, ErrorInfo } from 'react';
 2: interface Props {
 3:   children: React.ReactNode;
 4:   fallback?: React.ReactNode;
 5: }
 6: interface State {
 7:   hasError: boolean;
 8:   error: Error | null;
 9: }
10: /**
11:  * Error Boundary component for catching and handling React component errors.
12:  * Provides a fallback UI when child components throw errors.
13:  */
14: export class ErrorBoundary extends Component<Props, State> {
15:   constructor(props: Props) {
16:     super(props);
17:     this.state = {
18:       hasError: false,
19:       error: null
20:     };
21:   }
22:   static getDerivedStateFromError(error: Error): State {
23:     return {
24:       hasError: true,
25:       error
26:     };
27:   }
28:   componentDidCatch(error: Error, errorInfo: ErrorInfo) {
29:     console.error('Error caught by boundary:', error);
30:     console.error('Component stack:', errorInfo.componentStack);
31:   }
32:   render() {
33:     if (this.state.hasError) {
34:       return this.props.fallback || (
35:         <div className="error-boundary">
36:           <h3>Something went wrong</h3>
37:           <p>{this.state.error?.message}</p>
38:           <button onClick={() => this.setState({ hasError: false, error: null })}>
39:             Try again
40:           </button>
41:         </div>
42:       );
43:     }
44:     return this.props.children;
45:   }
46: }

================
File: src/components/FileCard.module.css
================
  1: .fileCard {
  2:   display: flex;
  3:   flex-direction: column;
  4:   margin-bottom: 4px;
  5:   transition: all 0.2s ease;
  6:   border: 1px solid var(--border-color);
  7:   border-radius: var(--radius);
  8:   position: relative;
  9:   height: auto;
 10:   min-height: 70px;
 11:   background-color: var(--card-background);
 12:   color: var(--card-foreground);
 13:   box-shadow: 0 1px 2px rgba(0, 0, 0, 0.02);
 14:   backdrop-filter: var(--backdrop-blur-sm);
 15:   -webkit-backdrop-filter: var(--backdrop-blur-sm);
 16: }
 17: .fileCard:hover {
 18:   background-color: var(--card-background);
 19:   box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
 20:   border-color: var(--border-color);
 21:   transform: translateY(-1px);
 22: }
 23: .fileCard.selected {
 24:   border-color: var(--file-card-selected-border);
 25:   box-shadow: 0 0 0 1px var(--file-card-selected-border);
 26:   background-color: rgba(255, 255, 255, 0.07);
 27: }
 28: .fileCardContent {
 29:   padding: 6px !important;
 30: }
 31: .fileCardHeader {
 32:   display: flex;
 33:   align-items: center;
 34:   gap: 3px;
 35:   margin-bottom: 3px;
 36: }
 37: .fileCardIcon {
 38:   color: var(--text-secondary);
 39:   display: flex;
 40:   align-items: center;
 41:   margin-right: 0.2rem;
 42:   flex-shrink: 0;
 43: }
 44: .fileCardName {
 45:   flex: 1;
 46:   font-family: monospace;
 47:   white-space: nowrap;
 48:   overflow: hidden;
 49:   text-overflow: ellipsis;
 50:   font-weight: 500;
 51:   color: var(--card-foreground);
 52:   font-size: 11px;
 53: }
 54: .fileCardInfo {
 55:   display: flex;
 56:   flex-direction: column;
 57:   margin-bottom: 10px;
 58:   flex-grow: 1;
 59: }
 60: .fileCardTokens {
 61:   font-size: 10px;
 62:   color: var(--text-secondary);
 63:   margin-bottom: 3px;
 64: }
 65: .fileCardStatus {
 66:   font-size: 11px;
 67:   color: var(--text-secondary);
 68: }
 69: .tokenBarContainer {
 70:   width: 100%;
 71:   height: 3px;
 72:   background-color: var(--background-secondary);
 73:   border-radius: 1.5px;
 74:   overflow: hidden;
 75: }
 76: .tokenBar {
 77:   height: 100%;
 78:   background-color: var(--accent-color);
 79:   border-radius: 1.5px;
 80:   transition: width 0.3s ease;
 81: }
 82: .fileCardActions {
 83:   display: flex;
 84:   gap: 2px;
 85:   position: absolute;
 86:   bottom: 4px;
 87:   right: 8px;
 88:   opacity: 0;
 89:   transition: opacity 0.2s ease;
 90: }
 91: .fileCard:hover .fileCardActions {
 92:   opacity: 1;
 93: }
 94: .fileCardAction {
 95:   width: 20px !important;
 96:   height: 20px !important;
 97:   padding: 0 !important;
 98:   color: var(--text-secondary);
 99:   transition: color 0.2s ease !important;
100: }
101: .fileCardAction:hover {
102:   background-color: transparent !important;
103:   color: var(--text-primary) !important;
104: }
105: .copySuccess {
106:   color: var(--success-color);
107:   animation: pulse 1s ease-in-out;
108: }
109: .compressedIcon {
110:   color: var(--text-secondary);
111:   opacity: 0.7;
112:   margin-left: 2px;
113: }
114: @keyframes pulse {
115:   0% {
116:     transform: scale(1);
117:   }
118:   50% {
119:     transform: scale(1.2);
120:   }
121:   100% {
122:     transform: scale(1);
123:   }
124: }

================
File: src/components/FileCard.tsx
================
  1: import React, { useEffect, useState } from "react";
  2: import { Plus, X, FileText, Copy, Minimize2 } from "lucide-react";
  3: import { Card, CardContent, Button } from "./ui";
  4: import styles from "./FileCard.module.css";
  5: interface FileCardComponentProps {
  6:   file: {
  7:     name: string;
  8:     path: string;
  9:     tokenCount: number;
 10:     content: string;
 11:     isCompressed: boolean;
 12:   };
 13:   isSelected: boolean;
 14:   toggleSelection: (path: string) => void;
 15:   maxTokenCount?: number; // Maximum token count among all displayed files
 16: }
 17: const FileCard = ({
 18:   file,
 19:   isSelected,
 20:   toggleSelection,
 21:   maxTokenCount = 5000, // Default if not provided
 22: }: FileCardComponentProps) => {
 23:   const { name, path: filePath, tokenCount, content, isCompressed } = file;
 24:   const [barWidth, setBarWidth] = useState(0);
 25:   const [copied, setCopied] = useState(false);
 26:   // Format token count for display
 27:   const formattedTokens = tokenCount.toLocaleString();
 28:   // Calculate the percentage width for the token bar based on the highest token count
 29:   useEffect(() => {
 30:     // Start with 0 width
 31:     setBarWidth(0);
 32:     // Animate to the correct width with a slight delay for visual appeal
 33:     const timer = setTimeout(() => {
 34:       // If token count is very small compared to max, ensure it has at least some visible width
 35:       let percentage;
 36:       if (maxTokenCount <= 0) {
 37:         percentage = 0;
 38:       } else {
 39:         // Use relative scaling with a minimum percentage to ensure visibility
 40:         const minPercentage = 5; // Ensure even small files have a visible bar
 41:         percentage = Math.max(
 42:           minPercentage,
 43:           Math.min((tokenCount / maxTokenCount) * 100, 100)
 44:         );
 45:       }
 46:       setBarWidth(percentage);
 47:     }, 50);
 48:     return () => clearTimeout(timer);
 49:   }, [tokenCount, maxTokenCount]);
 50:   const handleCopy = async () => {
 51:     try {
 52:       await navigator.clipboard.writeText(content);
 53:       setCopied(true);
 54:       setTimeout(() => setCopied(false), 2000);
 55:     } catch (err) {
 56:       console.error("Failed to copy:", err);
 57:     }
 58:   };
 59:   return (
 60:     <Card 
 61:       selected={isSelected} 
 62:       className={styles.fileCard}
 63:     >
 64:       <CardContent className={styles.fileCardContent}>
 65:         <div className={styles.fileCardHeader}>
 66:           <div className={styles.fileCardIcon}>
 67:             <FileText size={14} />
 68:           </div>
 69:           <div className={styles.fileCardName}>{name}</div>
 70:           {isCompressed && (
 71:             <div className={styles.compressedIcon} title="Function bodies removed">
 72:               <Minimize2 size={10} />
 73:             </div>
 74:           )}
 75:         </div>
 76:         <div className={styles.fileCardInfo}>
 77:           <div className={styles.fileCardTokens}>~{formattedTokens} tokens</div>
 78:           <div className={styles.tokenBarContainer}>
 79:             <div 
 80:               className={styles.tokenBar} 
 81:               style={{ width: `${barWidth}%` }}
 82:               title={`${tokenCount} tokens (${Math.round(barWidth)}% of largest file)`}
 83:             ></div>
 84:           </div>
 85:         </div>
 86:         <div className={styles.fileCardActions}>
 87:           <Button
 88:             variant="icon"
 89:             size="sm"
 90:             iconOnly
 91:             onClick={() => toggleSelection(filePath)}
 92:             title={isSelected ? "Remove from selection" : "Add to selection"}
 93:             startIcon={isSelected ? <X size={12} /> : <Plus size={12} />}
 94:             className={styles.fileCardAction}
 95:           />
 96:           <Button
 97:             variant="icon"
 98:             size="sm"
 99:             iconOnly
100:             onClick={handleCopy}
101:             title={copied ? "Copied!" : "Copy to clipboard"}
102:             startIcon={copied ? <Copy size={12} className={styles.copySuccess} /> : <Copy size={12} />}
103:             className={styles.fileCardAction}
104:           />
105:         </div>
106:       </CardContent>
107:     </Card>
108:   );
109: };
110: export default FileCard;

================
File: src/components/FileList.module.css
================
 1: .fileListContainer {
 2:   flex: 1;
 3:   overflow: hidden;
 4:   display: flex;
 5:   flex-direction: column;
 6: }
 7: .fileList {
 8:   flex: 1;
 9:   overflow-y: auto;
10:   padding: 1rem;
11:   display: grid;
12:   grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
13:   grid-auto-rows: max-content;
14:   align-content: start;
15:   gap: 0.5rem;
16:   background-color: var(--background-primary);
17: }
18: /* Specific scrollbar styling for file list */
19: .fileList::-webkit-scrollbar-track {
20:   background-color: var(--scrollbar-track-color);
21: }
22: .fileList::-webkit-scrollbar-thumb {
23:   background-color: var(--scrollbar-thumb-color);
24:   border-radius: var(--radius-full);
25: }
26: .fileList::-webkit-scrollbar-thumb:hover {
27:   background-color: var(--scrollbar-thumb-hover-color);
28: }
29: .fileListEmpty {
30:   display: flex;
31:   align-items: center;
32:   justify-content: center;
33:   height: 100%;
34:   color: var(--text-secondary);
35:   font-size: 16px;
36:   padding: 32px;
37:   text-align: center;
38: }

================
File: src/components/FileList.tsx
================
 1: import React, { useState, useEffect } from "react";
 2: import { FileListProps, FileData } from "../types/FileTypes";
 3: import FileCard from "./FileCard";
 4: import { arePathsEqual } from "../utils/pathUtils";
 5: import styles from "./FileList.module.css";
 6: const FileList = ({
 7:   files,
 8:   selectedFiles,
 9:   toggleFileSelection,
10: }: FileListProps) => {
11:   const [fileContents, setFileContents] = useState<Record<string, string>>({});
12:   // Only show files that are in the selectedFiles array and not binary/skipped
13:   const displayableFiles = files.filter(
14:     (file: FileData) =>
15:       selectedFiles.some(selectedPath => arePathsEqual(selectedPath, file.path)) && 
16:       !file.isBinary && 
17:       !file.isSkipped,
18:   );
19:   // Find the maximum token count for relative scaling
20:   const maxTokenCount = displayableFiles.length > 0
21:     ? Math.max(...displayableFiles.map(file => file.tokenCount))
22:     : 5000; // Default if no files
23:   // Fetch file contents when needed
24:   useEffect(() => {
25:     const fetchContents = async () => {
26:       const newContents: Record<string, string> = {};
27:       for (const file of displayableFiles) {
28:         if (!fileContents[file.path]) {
29:           try {
30:             const content = await window.electron.readFile(file.path);
31:             newContents[file.path] = content ?? "Error: File content is null";
32:           } catch (error) {
33:             console.error(`Error reading file ${file.path}:`, error);
34:             newContents[file.path] = "Error loading file content";
35:           }
36:         }
37:       }
38:       if (Object.keys(newContents).length > 0) {
39:         setFileContents(prev => ({ ...prev, ...newContents }));
40:       }
41:     };
42:     fetchContents();
43:   }, [displayableFiles, fileContents]);
44:   return (
45:     <div className={styles.fileListContainer}>
46:       {displayableFiles.length > 0 ? (
47:         <div className={styles.fileList}>
48:           {displayableFiles.map((file) => (
49:             <FileCard
50:               key={file.path}
51:               file={{
52:                 ...file,
53:                 content: fileContents[file.path] || "Loading..."
54:               }}
55:               isSelected={true} // Always true since we're already filtering for selected files
56:               toggleSelection={toggleFileSelection}
57:               maxTokenCount={maxTokenCount}
58:             />
59:           ))}
60:         </div>
61:       ) : (
62:         <div className={styles.fileListEmpty}>
63:           No files selected. Select files from the sidebar to see them here.
64:         </div>
65:       )}
66:     </div>
67:   );
68: };
69: export default FileList;

================
File: src/components/FileTreeHeader.module.css
================
 1: .fileTreeHeader {
 2:   display: flex;
 3:   align-items: center;
 4:   gap: 0.5rem;
 5:   padding: 0.5rem;
 6:   background: var(--background-primary);
 7:   border-bottom: 1px solid var(--border-color);
 8:   height: 46px;
 9:   justify-content: center;
10: }
11: .fileTreeBtn:focus-visible {
12:   outline: 2px solid var(--focus-ring);
13:   outline-offset: -1px;
14: }
15: .dropdownContainer {
16:   position: relative;
17:   display: inline-flex;
18:   align-items: center;
19:   height: 32px;
20: }
21: .excludedFilesCount {
22:   padding: 0.5rem;
23:   font-size: 0.7rem;
24:   color: var(--text-secondary);
25:   background: var(--bg-secondary);
26:   border-bottom: 1px solid var(--border-color);
27: }

================
File: src/components/FileTreeHeader.tsx
================
 1: import React, { useCallback } from "react"; // Import useCallback
 2: import { Folder, Filter, X, RefreshCw } from "lucide-react"; // Removed unused sort icons
 3: import { SortOrder } from "../types/FileTypes";
 4: import { Button } from "./ui";
 5: import { Dropdown } from "./ui/Dropdown";
 6: import { getSortIcon } from "../utils/sortIcons"; // Keep this utility
 7: import styles from "./FileTreeHeader.module.css";
 8: // Removed unused sortIconMap and iconComponents
 9: interface FileTreeHeaderProps {
10:   onOpenFolder: () => void;
11:   onSortChange: (sortOrder: SortOrder) => void;
12:   onClearSelection: () => void; // Should trigger dialog in App
13:   onRemoveAllFolders: () => void; // Should trigger dialog in App
14:   onReloadFileTree: () => void;
15:   onOpenIgnorePatterns: () => void; // Simplified: always opens modal
16:   excludedFilesCount?: number;
17:   currentSortOrder?: SortOrder;
18: }
19: // Keep sortOptions definition
20: const sortOptions = [
21:   { value: "name-ascending", label: "Name (A to Z)" },
22:   { value: "name-descending", label: "Name (Z to A)" },
23:   { value: "tokens-ascending", label: "Tokens (Asc)" }, // Updated labels for brevity if desired
24:   { value: "tokens-descending", label: "Tokens (Desc)" },
25:   { value: "date-ascending", label: "Date (Oldest)" },
26:   { value: "date-descending", label: "Date (Newest)" }
27: ];
28: // Keep clearOptions definition
29: const clearOptions = [
30:   { value: "clear", label: "Clear selection" },
31:   { value: "removeAll", label: "Remove All Folders" },
32: ];
33: const FileTreeHeader: React.FC<FileTreeHeaderProps> = ({ // Use React.FC for consistency
34:   onOpenFolder,
35:   onSortChange,
36:   onClearSelection,
37:   onRemoveAllFolders,
38:   onReloadFileTree,
39:   onOpenIgnorePatterns,
40:   excludedFilesCount,
41:   currentSortOrder,
42: }) => {
43:   // Use useCallback for handlers passed to Dropdown
44:   const handleSortSelect = useCallback((value: string | string[]) => {
45:     if (typeof value === 'string') {
46:         onSortChange(value as SortOrder);
47:     }
48:   }, [onSortChange]);
49:   const handleClearSelect = useCallback((value: string | string[]) => {
50:     if (typeof value === 'string') {
51:       if (value === 'clear') onClearSelection();
52:       else if (value === 'removeAll') onRemoveAllFolders();
53:     }
54:   }, [onClearSelection, onRemoveAllFolders]);
55:   return (
56:     <>
57:       <div className={styles.fileTreeHeader}>
58:         <Button variant="icon" size="sm" iconOnly startIcon={<Folder size={16} />} onClick={onOpenFolder} title="Select Folder" className={styles.fileTreeBtn} />
59:         <div className={styles.dropdownContainer}>
60:           <Dropdown
61:             options={sortOptions}
62:             onChange={handleSortSelect}
63:             value={currentSortOrder}
64:             trigger={<Button variant="icon" size="sm" iconOnly startIcon={getSortIcon(currentSortOrder)} title="Sort By" className={styles.fileTreeBtn} />}
65:             menuClassName={styles.headerDropdownMenu} // Ensure this class exists or remove
66:           />
67:         </div>
68:         <Button variant="icon" size="sm" iconOnly startIcon={<Filter size={16} />} onClick={onOpenIgnorePatterns} title="Ignore Patterns" className={styles.fileTreeBtn} />
69:         <div className={styles.dropdownContainer}>
70:           <Dropdown
71:             options={clearOptions}
72:             onChange={handleClearSelect}
73:             trigger={<Button variant="icon" size="sm" iconOnly startIcon={<X size={16} />} title="Clear Actions" className={styles.fileTreeBtn} />}
74:             menuClassName={styles.headerDropdownMenu} // Ensure this class exists or remove
75:           />
76:         </div>
77:         <Button variant="icon" size="sm" iconOnly startIcon={<RefreshCw size={16} />} onClick={onReloadFileTree} title="Reload" className={styles.fileTreeBtn} />
78:       </div>
79:       {excludedFilesCount !== undefined && excludedFilesCount > 0 && (
80:         <div className={styles.excludedFilesCount}>
81:           {excludedFilesCount} {excludedFilesCount === 1 ? 'file' : 'files'} excluded
82:         </div>
83:       )}
84:     </>
85:   );
86: };
87: export default FileTreeHeader; // Add default export if not already present

================
File: src/components/SearchBar.module.css
================
 1: .searchBarWrapper {
 2:   width: 100%;
 3:   position: relative;
 4:   display: flex;
 5:   align-items: center;
 6:   background-color: var(--background-primary);
 7:   border: 1px solid var(--border-color);
 8:   border-radius: var(--radius);
 9:   height: 28px; /* Fixed height to fit in sidebar */
10:   transition: border-color 0.2s, box-shadow 0.2s;
11: }
12: .searchBarWrapper.focused {
13:   border-color: var(--accent-color);
14: }
15: .searchContainer {
16:   position: relative;
17:   display: flex;
18:   align-items: center;
19:   width: 100%;
20: }
21: .searchIcon {
22:   position: absolute;
23:   left: 8px;
24:   color: var(--text-secondary);
25:   pointer-events: none;
26:   width: 14px;
27:   height: 14px;
28: }
29: .searchInput {
30:   width: 100%;
31:   padding: 4px 10px 4px 26px;
32:   border: 1px solid var(--border-color);
33:   border-radius: 16px;
34:   font-size: 0.75rem;
35:   background: var(--background-secondary);
36:   color: var(--text-primary);
37:   transition: all 0.15s ease;
38:   outline: none;
39:   height: 24px;
40:   line-height: 1;
41: }
42: .searchInput:focus {
43:   border-color: var(--accent-color);
44:   box-shadow: 0 0 0 1px rgba(var(--accent-rgb), 0.2);
45: }
46: .searchInput::placeholder {
47:   color: var(--text-tertiary, var(--text-secondary));
48:   opacity: 0.6;
49: }
50: .clearButton {
51:   position: absolute;
52:   right: 6px;
53:   top: 50%;
54:   transform: translateY(-50%);
55:   background: none;
56:   border: none;
57:   padding: 2px;
58:   color: var(--text-secondary);
59:   display: flex;
60:   align-items: center;
61:   justify-content: center;
62:   border-radius: 50%;
63:   cursor: pointer;
64:   z-index: 2;
65:   width: 16px;
66:   height: 16px;
67:   transition: color 0.2s ease, background-color 0.2s ease;
68: }
69: .clearButton:hover {
70:   color: var(--text-primary);
71:   background-color: var(--hover-color);
72: }

================
File: src/components/SearchBar.tsx
================
 1: import React from "react";
 2: import { Search } from "lucide-react";
 3: import styles from "./SearchBar.module.css";
 4: interface SearchBarProps {
 5:   searchTerm: string;
 6:   onSearchChange: (term: string) => void;
 7: }
 8: const SearchBar: React.FC<SearchBarProps> = ({ searchTerm, onSearchChange }) => {
 9:   return (
10:     <div className={styles.searchContainer}>
11:       <Search size={14} className={styles.searchIcon} />
12:       <input
13:         type="text"
14:         value={searchTerm}
15:         onChange={(e) => onSearchChange(e.target.value)}
16:         placeholder="Search files..."
17:         className={styles.searchInput}
18:       />
19:     </div>
20:   );
21: };
22: export default SearchBar;

================
File: src/components/Sidebar.module.css
================
  1: .sidebar {
  2:   display: flex;
  3:   flex-direction: column;
  4:   height: 100%;
  5:   border-right: 1px solid var(--border-color);
  6:   background: var(--background-primary);
  7:   position: relative;
  8:   /* Add macOS-like vibrancy effect */
  9:   backdrop-filter: var(--backdrop-blur-md);
 10:   -webkit-backdrop-filter: var(--backdrop-blur-md);
 11: }
 12: .sidebarSearch {
 13:   padding: 6px 12px;
 14:   border-bottom: 1px solid var(--border-color);
 15:   display: flex;
 16:   align-items: center;
 17:   height: 36px;
 18:   background-color: var(--background-secondary);
 19:   backdrop-filter: var(--backdrop-blur-sm);
 20:   -webkit-backdrop-filter: var(--backdrop-blur-sm);
 21: }
 22: .sidebarActions {
 23:   display: flex;
 24:   padding: 6px 8px;
 25:   gap: 8px;
 26:   border-bottom: 1px solid var(--border-color);
 27:   justify-content: center;
 28:   align-items: center;
 29:   height: 40px;
 30:   background-color: var(--background-secondary);
 31:   backdrop-filter: var(--backdrop-blur-sm);
 32:   -webkit-backdrop-filter: var(--backdrop-blur-sm);
 33: }
 34: .fileTree {
 35:   flex: 1;
 36:   overflow-y: auto;
 37:   padding: 8px 0;
 38: }
 39: .treeEmpty {
 40:   padding: 16px;
 41:   text-align: center;
 42:   color: var(--text-secondary);
 43: }
 44: .treeLoading {
 45:   display: flex;
 46:   flex-direction: column;
 47:   align-items: center;
 48:   justify-content: center;
 49:   padding: 32px;
 50:   gap: 16px;
 51:   color: var(--text-secondary);
 52: }
 53: .spinner {
 54:   border: 2px solid var(--border-color);
 55:   border-top: 2px solid var(--text-primary);
 56:   border-radius: 50%;
 57:   width: 24px;
 58:   height: 24px;
 59:   animation: spin 1s linear infinite;
 60: }
 61: .sidebarEmptyState {
 62:   display: flex;
 63:   flex-direction: column;
 64:   align-items: center;
 65:   justify-content: center;
 66:   height: 100%;
 67:   padding: 32px;
 68:   text-align: center;
 69:   gap: 16px;
 70:   color: var(--text-secondary);
 71: }
 72: .sidebarEmptyIcon {
 73:   color: var(--text-secondary);
 74:   opacity: 0.5;
 75: }
 76: .sidebarResizeHandle {
 77:   position: absolute;
 78:   right: -4px;
 79:   top: 0;
 80:   bottom: 0;
 81:   width: 8px;
 82:   cursor: col-resize;
 83:   background: transparent;
 84:   transition: background-color 0.2s;
 85: }
 86: .sidebarResizeHandle:hover {
 87:   background: var(--accent);
 88: }
 89: @keyframes spin {
 90:   0% { transform: rotate(0deg); }
 91:   100% { transform: rotate(360deg); }
 92: }
 93: .excludedFilesIndicator {
 94:   font-size: 0.75rem;
 95:   color: var(--text-secondary);
 96:   padding: 6px 8px;
 97:   margin: 4px 8px;
 98:   text-align: center;
 99:   font-style: italic;
100:   opacity: 0.7;
101:   background-color: var(--background-secondary);
102:   border-radius: var(--radius);
103: }
104: .excludedFilesMessage {
105:   font-size: 0.75rem;
106:   color: var(--text-secondary);
107:   padding: 4px 8px;
108:   text-align: center;
109:   font-style: italic;
110:   opacity: 0.7;
111:   border-bottom: 1px solid var(--border-color);
112: }

================
File: src/components/Sidebar.module.css.d.ts
================
 1: declare const styles: {
 2:   readonly sidebar: string;
 3:   readonly sidebarSearch: string;
 4:   readonly sidebarActions: string;
 5:   readonly fileTree: string;
 6:   readonly treeEmpty: string;
 7:   readonly treeLoading: string;
 8:   readonly spinner: string;
 9:   readonly sidebarEmptyState: string;
10:   readonly sidebarEmptyIcon: string;
11:   readonly sidebarResizeHandle: string;
12: };
13: export default styles;

================
File: src/components/ThemeToggle.module.css
================
 1: .themeSegmentedControl {
 2:   display: flex;
 3:   background-color: var(--background-secondary);
 4:   border-radius: 9999px;
 5:   padding: 2px;
 6:   width: fit-content;
 7:   position: relative;
 8:   height: 28px;
 9:   border: 1px solid hsla(240, 6%, 90%, 0.6);
10:   gap: 1px;
11:   box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), inset 0 0 0 1px rgba(255, 255, 255, 0.03);
12:   overflow: hidden;
13: }
14: .themeSegmentsBackground {
15:   position: absolute;
16:   top: 2px;
17:   left: 2px;
18:   width: calc(33.33% - 2px);
19:   height: calc(100% - 4px);
20:   background-color: var(--background-primary);
21:   border-radius: 9999px;
22:   box-shadow: 0 1px 3px rgba(0, 0, 0, 0.056), 0 0 0 1px rgba(0, 0, 0, 0.04);
23:   z-index: 0;
24:   transform: translateX(0);
25: }
26: .themeSegmentsBackground.animated {
27:   transition-property: transform, box-shadow;
28: }
29: .themeSegmentsBackground.light {
30:   transform: translateX(0);
31: }
32: .themeSegmentsBackground.dark {
33:   transform: translateX(100%);
34: }
35: .themeSegmentsBackground.system {
36:   transform: translateX(200%);
37: }
38: .themeSegment {
39:   display: flex;
40:   align-items: center;
41:   justify-content: center;
42:   width: 28px;
43:   height: 24px;
44:   border: none;
45:   background: none;
46:   color: var(--text-secondary);
47:   position: relative;
48:   z-index: 1;
49:   transition: color 0.2s ease;
50:   border-radius: 9999px;
51:   cursor: pointer;
52:   padding: 0;
53: }
54: .themeSegment:hover {
55:   color: var(--text-primary);
56:   background: none;
57: }
58: .themeSegment:focus {
59:   outline: none;
60:   box-shadow: none;
61: }
62: .themeSegment:focus-visible {
63:   outline: none;
64:   box-shadow: 0 0 0 1px var(--accent-color);
65: }
66: .themeSegment.active {
67:   color: var(--text-primary);
68: }
69: /* Dark mode adjustments */
70: :global(.dark-mode) .themeSegmentedControl {
71:   border-color: hsla(240, 3.7%, 25%, 0.3);
72:   box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), inset 0 0 0 1px rgba(255, 255, 255, 0.02);
73: }
74: :global(.dark-mode) .themeSegmentsBackground {
75:   background-color: var(--background-selected);
76:   box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2), 0 0 0 1px rgba(255, 255, 255, 0.05);
77: }

================
File: src/components/ThemeToggle.tsx
================
 1: import React, { useEffect, useState } from 'react';
 2: import { useTheme } from '../hooks/useTheme';
 3: import { Sun, Moon, Monitor } from 'lucide-react';
 4: import styles from './ThemeToggle.module.css';
 5: const ThemeToggle: React.FC = () => {
 6:   const { theme, setTheme } = useTheme();
 7:   const [isAnimated, setIsAnimated] = useState(false);
 8:   useEffect(() => {
 9:     // Add animation class after initial render
10:     const timer = setTimeout(() => setIsAnimated(true), 0);
11:     return () => clearTimeout(timer);
12:   }, []);
13:   return (
14:     <div className={styles.themeSegmentedControl}>
15:       <div
16:         className={`${styles.themeSegmentsBackground} ${styles[theme]} ${
17:           isAnimated ? styles.animated : ''
18:         }`}
19:       />
20:       <button
21:         className={`${styles.themeSegment} ${theme === 'light' ? styles.active : ''}`}
22:         onClick={() => setTheme('light')}
23:         title="Light theme"
24:       >
25:         <Sun size={16} />
26:       </button>
27:       <button
28:         className={`${styles.themeSegment} ${theme === 'dark' ? styles.active : ''}`}
29:         onClick={() => setTheme('dark')}
30:         title="Dark theme"
31:       >
32:         <Moon size={16} />
33:       </button>
34:       <button
35:         className={`${styles.themeSegment} ${theme === 'system' ? styles.active : ''}`}
36:         onClick={() => setTheme('system')}
37:         title="System theme"
38:       >
39:         <Monitor size={16} />
40:       </button>
41:     </div>
42:   );
43: };
44: export default ThemeToggle;

================
File: src/components/TreeItem.module.css
================
 1: .treeItem {
 2:   display: flex;
 3:   align-items: center;
 4:   padding: 4px 8px;
 5:   cursor: pointer;
 6:   font-size: 14px;
 7:   position: relative;
 8:   color: var(--text-primary);
 9:   transition: background-color 0.1s ease;
10:   border-radius: 4px;
11: }
12: .treeItem:hover {
13:   background-color: var(--hover-color);
14: }
15: .treeItemSelected {
16:   background-color: var(--background-selected);
17: }
18: /* When selected, extend background to full width */
19: .treeItemSelected,
20: .treeItem:hover {
21:   margin-left: -8px;
22:   margin-right: -8px;
23:   padding-left: 16px;
24:   padding-right: 16px;
25:   width: calc(100% + 16px);
26: }
27: .treeItemContent {
28:   display: flex;
29:   align-items: center;
30:   width: 100%;
31:   min-width: 0;
32:   overflow: hidden;
33: }
34: .treeItemIndent {
35:   display: inline-block;
36:   width: 16px;
37:   flex-shrink: 0;
38: }
39: .treeItemIcon {
40:   display: flex;
41:   align-items: center;
42:   margin-right: 4px;
43:   color: var(--icon-color);
44:   flex-shrink: 0;
45: }
46: .treeItemCheckbox {
47:   margin-right: 4px;
48:   cursor: pointer;
49:   accent-color: var(--accent-color);
50: }
51: .treeItemName {
52:   overflow: hidden;
53:   text-overflow: ellipsis;
54:   white-space: nowrap;
55:   flex-grow: 1;
56:   font-size: 0.85rem;
57: }
58: .treeItemTokens {
59:   margin-left: 4px;
60:   color: var(--text-secondary);
61:   font-size: 0.75rem;
62:   white-space: nowrap;
63: }
64: .treeItemExpander {
65:   cursor: pointer;
66:   display: flex;
67:   align-items: center;
68:   justify-content: center;
69:   width: 20px;
70:   height: 20px;
71:   margin-right: 4px;
72:   transition: transform 0.15s ease-in-out;
73:   color: var(--icon-color);
74:   z-index: 2;
75: }
76: .treeItemExpanderRotated {
77:   transform: rotate(90deg);
78: }
79: .fileIcon {
80:   color: var(--text-secondary);
81: }
82: .folderIcon {
83:   color: var(--accent-color);
84: }
85: .disabledItem {
86:   opacity: 0.5;
87:   cursor: not-allowed;
88: }
89: .treeItemBadge {
90:   font-size: 10px;
91:   padding: 1px 5px;
92:   border-radius: var(--radius);
93:   background-color: var(--hover-color);
94:   color: var(--text-secondary);
95:   margin-left: 6px;
96:   white-space: nowrap;
97: }

================
File: src/components/TreeItem.tsx
================
  1: import React, { useRef, useEffect, useMemo, memo } from "react";
  2: import { TreeItemProps, TreeNode } from "../types/FileTypes";
  3: import { ChevronRight, File, Folder } from "lucide-react";
  4: import { arePathsEqual } from "../utils/pathUtils";
  5: import styles from "./TreeItem.module.css";
  6: /**
  7:  * TreeItem component that renders a file or directory in the file tree.
  8:  * Optimized with memoization to prevent unnecessary re-renders.
  9:  */
 10: const TreeItem = memo(({
 11:   node,
 12:   selectedFiles,
 13:   toggleFileSelection,
 14:   toggleFolderSelection,
 15:   toggleExpanded,
 16: }: TreeItemProps) => {
 17:   const { id, name, path, type, depth, isExpanded, fileData } = node;
 18:   const checkboxRef = useRef<HTMLInputElement>(null);
 19:   // Check if file is selected - optimized with useMemo
 20:   const isSelected = useMemo(() => {
 21:     if (type === "file") {
 22:       return selectedFiles.some(selectedPath => arePathsEqual(selectedPath, path));
 23:     }
 24:     return false;
 25:   }, [type, path, selectedFiles]);
 26:   // Check if file is disabled (excluded by patterns)
 27:   const isDisabled = fileData?.excluded || false;
 28:   // Optimize directory selection calculations
 29:   const { isDirectorySelected, isDirectoryPartiallySelected } = useMemo(() => {
 30:     if (type !== "directory" || !node.children || node.children.length === 0) {
 31:       return { isDirectorySelected: false, isDirectoryPartiallySelected: false };
 32:     }
 33:     // Use a more efficient approach to determine selection state
 34:     const counts = {
 35:       total: 0,
 36:       selected: 0
 37:     };
 38:     // Recursive function to count files
 39:     const countFiles = (node: TreeNode) => {
 40:       if (node.type === "file") {
 41:         if (node.fileData?.excluded) return; // Skip excluded files
 42:         counts.total++;
 43:         if (selectedFiles.some(path => arePathsEqual(path, node.path))) {
 44:           counts.selected++;
 45:         }
 46:       } else if (node.type === "directory" && node.children) {
 47:         node.children.forEach(countFiles);
 48:       }
 49:     };
 50:     // Count all files in this directory
 51:     node.children.forEach(countFiles);
 52:     // Determine selection state
 53:     const isAllSelected = counts.total > 0 && counts.selected === counts.total;
 54:     const isPartiallySelected = counts.selected > 0 && counts.selected < counts.total;
 55:     return {
 56:       isDirectorySelected: isAllSelected,
 57:       isDirectoryPartiallySelected: isPartiallySelected
 58:     };
 59:   }, [node, type, selectedFiles]);
 60:   // Update the indeterminate state of the checkbox
 61:   useEffect(() => {
 62:     if (checkboxRef.current) {
 63:       checkboxRef.current.indeterminate = isDirectoryPartiallySelected;
 64:     }
 65:   }, [isDirectoryPartiallySelected]);
 66:   // Event handlers - using inline functions for better clarity
 67:   const handleToggle = (e: React.MouseEvent<HTMLDivElement>) => {
 68:     e.stopPropagation();
 69:     toggleExpanded(id);
 70:   };
 71:   const handleItemClick = (e: React.MouseEvent<HTMLDivElement>) => {
 72:     e.stopPropagation();
 73:     if (type === "directory") {
 74:       toggleExpanded(id);
 75:     } else if (type === "file" && !isDisabled) {
 76:       toggleFileSelection(path);
 77:     }
 78:   };
 79:   const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
 80:     e.stopPropagation();
 81:     if (type === "file") {
 82:       toggleFileSelection(path);
 83:     } else if (type === "directory") {
 84:       toggleFolderSelection(path, e.target.checked);
 85:     }
 86:   };
 87:   const handleCheckboxClick = (e: React.MouseEvent<HTMLInputElement>) => {
 88:     e.stopPropagation();
 89:   };
 90:   // Generate indentation for nested levels - memoized
 91:   const indentation = useMemo(() => {
 92:     const result = [];
 93:     for (let i = 0; i < depth; i++) {
 94:       result.push(
 95:         <span key={`indent-${i}`} className={styles.treeItemIndent} />
 96:       );
 97:     }
 98:     return result;
 99:   }, [depth]);
100:   return (
101:     <div
102:       className={`${styles.treeItem} ${
103:         (isSelected || isDirectorySelected) ? styles.treeItemSelected : ""
104:       } ${isDisabled ? styles.disabledItem : ""}`}
105:       onClick={handleItemClick}
106:       data-testid={`tree-item-${name}`}
107:     >
108:       <div className={styles.treeItemContent}>
109:         {indentation}
110:         {type === "directory" && (
111:           <div
112:             className={`${styles.treeItemExpander} ${
113:               isExpanded ? styles.treeItemExpanderRotated : ""
114:             }`}
115:             onClick={handleToggle}
116:           >
117:             <ChevronRight size={14} />
118:           </div>
119:         )}
120:         <input
121:           type="checkbox"
122:           checked={isSelected || isDirectorySelected}
123:           onChange={handleCheckboxChange}
124:           onClick={handleCheckboxClick}
125:           ref={type === "directory" ? checkboxRef : null}
126:           className={styles.treeItemCheckbox}
127:           disabled={isDisabled}
128:         />
129:         <div className={styles.treeItemIcon}>
130:           {type === "directory" ? (
131:             <Folder size={16} className={styles.folderIcon} />
132:           ) : (
133:             <File size={16} className={styles.fileIcon} />
134:           )}
135:         </div>
136:         <span
137:           className={styles.treeItemName}
138:           title={path}
139:           onClick={(e) => {
140:             e.stopPropagation();
141:             if (type === "file" && !isDisabled) {
142:               toggleFileSelection(path);
143:             } else if (type === "directory") {
144:               toggleExpanded(id);
145:             }
146:           }}
147:         >
148:           {name}
149:         </span>
150:         {/* Display token count or excluded label */}
151:         {type === "file" && fileData && (
152:           <span className={styles.treeItemTokens}>
153:             {isDisabled ? "Excluded" : fileData.tokenCount > 0 ? `(${fileData.tokenCount.toLocaleString()})` : ""}
154:           </span>
155:         )}
156:       </div>
157:     </div>
158:   );
159: });
160: TreeItem.displayName = "TreeItem";
161: export default TreeItem;

================
File: src/components/UserInstructionsWithTemplates.module.css
================
  1: .container {
  2:   display: flex;
  3:   flex-direction: column;
  4:   gap: 1rem;
  5:   width: 100%;
  6:   height: 100%;
  7:   min-height: 200px;
  8:   border: 1px solid var(--border-color);
  9:   border-radius: var(--radius);
 10:   padding: 1rem;
 11:   background-color: var(--background-primary);
 12:   box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
 13:   margin-bottom: 1rem;
 14: }
 15: .header {
 16:   display: flex;
 17:   justify-content: space-between;
 18:   align-items: center;
 19:   gap: 1rem;
 20:   padding-bottom: 0.75rem;
 21:   border-bottom: 1px solid var(--border-color);
 22:   margin-bottom: 0.75rem;
 23: }
 24: .header::before {
 25:   content: "Template";
 26:   font-weight: 500;
 27:   font-size: 0.9rem;
 28:   color: var(--text-primary);
 29: }
 30: .templateSelector {
 31:   width: 400px;
 32:   max-width: 100%;
 33: }
 34: .textareaContainer {
 35:   flex: 1;
 36:   min-height: 150px;
 37:   position: relative;
 38: }
 39: .textareaContainer::before {
 40:   content: "Instructions";
 41:   display: block;
 42:   font-weight: 500;
 43:   font-size: 0.9rem;
 44:   color: var(--text-primary);
 45:   margin-bottom: 0.5rem;
 46: }
 47: .textarea {
 48:   width: 100%;
 49:   height: 100%;
 50:   min-height: 150px;
 51:   padding: 0.75rem;
 52:   border: 1px solid var(--border-color);
 53:   border-radius: 0.375rem;
 54:   background-color: var(--input-bg);
 55:   color: var(--text-color);
 56:   font-family: var(--font-mono);
 57:   font-size: 0.875rem;
 58:   line-height: 1.5;
 59:   resize: vertical;
 60:   transition: border-color 0.2s ease, box-shadow 0.2s ease;
 61: }
 62: .textarea:focus {
 63:   outline: none;
 64:   border-color: var(--primary-color);
 65:   box-shadow: 0 0 0 2px var(--primary-color-alpha);
 66: }
 67: .templatePreview {
 68:   padding: 1rem;
 69:   border: 1px solid var(--border-color);
 70:   border-radius: 0.375rem;
 71:   background-color: var(--surface-color);
 72:   margin-top: 1rem;
 73:   box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
 74: }
 75: .templatePreview h4 {
 76:   margin: 0 0 0.5rem 0;
 77:   font-size: 1rem;
 78:   font-weight: 600;
 79:   color: var(--heading-color);
 80: }
 81: .templateDescription {
 82:   margin: 0 0 1rem 0;
 83:   font-size: 0.875rem;
 84:   color: var(--text-color-secondary);
 85: }
 86: .templateContent {
 87:   margin: 0;
 88:   padding: 0.75rem;
 89:   background-color: var(--code-bg);
 90:   border-radius: 0.25rem;
 91:   font-family: var(--font-mono);
 92:   font-size: 0.875rem;
 93:   line-height: 1.5;
 94:   white-space: pre-wrap;
 95:   color: var(--code-color);
 96:   border: 1px solid rgba(0, 0, 0, 0.1);
 97: }
 98: .insertModeOptions {
 99:   display: flex;
100:   gap: 0.5rem;
101:   justify-content: center;
102:   margin-top: 1rem;
103: }
104: /* Responsive adjustments */
105: @media (max-width: 640px) {
106:   .templateSelector {
107:     width: 100%;
108:   }
109:   .header {
110:     flex-direction: column;
111:     align-items: stretch;
112:   }
113: }

================
File: src/components/UserInstructionsWithTemplates.tsx
================
  1: import React, { useState, useCallback, useMemo } from 'react';
  2: import { ConfirmationDialog } from './ui/ConfirmationDialog';
  3: import { TemplateDropdownAdapter } from './ui/DropdownMenu/TemplateDropdownAdapter';
  4: import {
  5:   PromptTemplate,
  6:   PROMPT_TEMPLATES,
  7:   TEMPLATE_STORAGE_KEY,
  8:   TEMPLATE_INSERT_MODE_KEY,
  9:   TemplateInsertMode,
 10:   TemplateCategory
 11: } from '../constants/promptTemplates';
 12: import styles from './UserInstructionsWithTemplates.module.css';
 13: interface UserInstructionsWithTemplatesProps {
 14:   instructions: string;
 15:   setInstructions: (value: string | ((prev: string) => string)) => void;
 16: }
 17: interface TemplateOption {
 18:   value: string;
 19:   label: string;
 20:   category: TemplateCategory;
 21:   icon?: string;
 22:   description?: string;
 23:   disabled?: boolean;
 24: }
 25: export const UserInstructionsWithTemplates: React.FC<UserInstructionsWithTemplatesProps> = ({
 26:   instructions,
 27:   setInstructions,
 28: }) => {
 29:   // State for selected template and preview
 30:   const [selectedTemplate, setSelectedTemplate] = useState<string | null>(() => {
 31:     return localStorage.getItem(TEMPLATE_STORAGE_KEY);
 32:   });
 33:   const [previewTemplate, setPreviewTemplate] = useState<PromptTemplate | null>(null);
 34:   // State for confirmation dialog
 35:   const [showConfirmDialog, setShowConfirmDialog] = useState(false);
 36:   const [pendingTemplate, setPendingTemplate] = useState<PromptTemplate | null>(null);
 37:   // State for insertion mode
 38:   const [insertMode, setInsertMode] = useState<TemplateInsertMode>(() => {
 39:     return (localStorage.getItem(TEMPLATE_INSERT_MODE_KEY) as TemplateInsertMode) || 'replace';
 40:   });
 41:   // Create template options for the dropdown
 42:   const templateOptions = useMemo<TemplateOption[]>(() => {
 43:     return PROMPT_TEMPLATES.map(template => ({
 44:       value: template.id,
 45:       label: template.name,
 46:       description: template.description,
 47:       icon: template.icon,
 48:       category: template.category
 49:     }));
 50:   }, []);
 51:   // Handle template selection
 52:   const handleTemplateSelect = useCallback((value: string) => {
 53:     const template = PROMPT_TEMPLATES.find(t => t.id === value);
 54:     if (!template) return;
 55:     // Save last selected template
 56:     localStorage.setItem(TEMPLATE_STORAGE_KEY, value);
 57:     setSelectedTemplate(value);
 58:     // Also update the preview template when selected
 59:     setPreviewTemplate(template);
 60:     // If instructions are empty, directly insert
 61:     if (!instructions.trim()) {
 62:       setInstructions(template.content);
 63:       return;
 64:     }
 65:     // Otherwise, show confirmation dialog
 66:     setPendingTemplate(template);
 67:     setShowConfirmDialog(true);
 68:   }, [instructions, setInstructions]);
 69:   // Handle template insertion
 70:   const insertTemplate = useCallback((template: PromptTemplate, mode: TemplateInsertMode) => {
 71:     // Save insertion mode preference
 72:     localStorage.setItem(TEMPLATE_INSERT_MODE_KEY, mode);
 73:     setInsertMode(mode);
 74:     if (mode === 'replace') {
 75:       setInstructions(template.content);
 76:     } else {
 77:       setInstructions((prev: string) => {
 78:         if (prev.trim()) {
 79:           return `${prev.trim()}\n\n${template.content}`;
 80:         }
 81:         return template.content;
 82:       });
 83:     }
 84:   }, [setInstructions]);
 85:   // Get the selected template name
 86:   const getSelectedTemplateName = () => {
 87:     if (!selectedTemplate) return null;
 88:     const template = PROMPT_TEMPLATES.find(t => t.id === selectedTemplate);
 89:     return template ? template.name : null;
 90:   };
 91:   return (
 92:     <div className={styles.container}>
 93:       <div className={styles.header}>
 94:         <div className={styles.templateSelector}>
 95:           <TemplateDropdownAdapter
 96:             options={templateOptions}
 97:             value={selectedTemplate || undefined}
 98:             onChange={handleTemplateSelect}
 99:             placeholder="Select a prompt template..."
100:             title="Select a prompt template"
101:           />
102:         </div>
103:       </div>
104:       <div className={styles.textareaContainer}>
105:         <textarea
106:           value={instructions}
107:           onChange={(e) => setInstructions(e.target.value)}
108:           placeholder="Enter your instructions here to guide the AI response..."
109:           className={styles.textarea}
110:           aria-label="User instructions"
111:         />
112:       </div>
113:       {selectedTemplate && (
114:         <div className={styles.templatePreview} role="complementary" aria-label="Template preview">
115:           <h4>Selected Template: {getSelectedTemplateName()}</h4>
116:           {previewTemplate && (
117:             <>
118:               <p className={styles.templateDescription}>{previewTemplate.description}</p>
119:             </>
120:           )}
121:         </div>
122:       )}
123:       <ConfirmationDialog
124:         isOpen={showConfirmDialog}
125:         onClose={() => {
126:           setShowConfirmDialog(false);
127:           setPendingTemplate(null);
128:         }}
129:         onConfirm={() => {
130:           if (pendingTemplate) {
131:             insertTemplate(pendingTemplate, insertMode);
132:           }
133:           setShowConfirmDialog(false);
134:           setPendingTemplate(null);
135:         }}
136:         title="Insert Template"
137:         description="Would you like to replace your current instructions or append the template?"
138:         confirmLabel={insertMode === 'replace' ? 'Replace' : 'Append'}
139:         cancelLabel="Cancel"
140:       />
141:     </div>
142:   );
143: };

================
File: src/constants/api.ts
================
1: // API Endpoints
2: export const OPENROUTER_MODELS_API_URL = "https://openrouter.ai/api/v1/models";
3: // Add other API-related constants here as needed

================
File: src/constants/outputFormats.ts
================
 1: export type OutputFormatType = 'xml' | 'markdown' | 'plain';
 2: export const OUTPUT_FORMAT_OPTIONS = [
 3:   { 
 4:     value: 'xml', 
 5:     label: 'XML', 
 6:     description: 'XML format with tags for file content',
 7:     icon: '🔰'
 8:   },
 9:   { 
10:     value: 'markdown', 
11:     label: 'Markdown', 
12:     description: 'Markdown format with code blocks',
13:     icon: '📝'
14:   },
15:   { 
16:     value: 'plain', 
17:     label: 'Plain Text', 
18:     description: 'Plain text with ASCII separators',
19:     icon: '📄'
20:   },
21: ];
22: export const OUTPUT_FORMAT_STORAGE_KEY = 'pastemax-output-format';

================
File: src/constants/theme.ts
================
1: // export const STORAGE_KEY = "pastemax-theme";

================
File: src/context/ThemeContext.tsx
================
 1: import React, { useState, useEffect } from "react";
 2: import { ThemeType, ThemeContext } from "./ThemeContextType";
 3: export const ThemeProvider = ({
 4:   children,
 5: }: {
 6:   children: React.ReactNode;
 7: }): JSX.Element => {
 8:   // Initialize theme from localStorage or default to "system"
 9:   const [theme, setThemeState] = useState<ThemeType>(() => {
10:     const savedTheme = localStorage.getItem("theme") as ThemeType;
11:     return savedTheme && ["light", "dark", "system"].includes(savedTheme) ? savedTheme : "system";
12:   });
13:   const [currentTheme, setCurrentTheme] = useState<"light" | "dark">("light");
14:   // Function to set theme and save to localStorage
15:   const setTheme = (newTheme: ThemeType) => {
16:     setThemeState(newTheme);
17:     localStorage.setItem("theme", newTheme);
18:   };
19:   // Effect to apply the correct theme based on selection or system preference
20:   useEffect(() => {
21:     const applyTheme = (themeName: "light" | "dark") => {
22:       setCurrentTheme(themeName);
23:       if (themeName === "dark") {
24:         document.body.classList.add("dark-mode");
25:       } else {
26:         document.body.classList.remove("dark-mode");
27:       }
28:     };
29:     // Check for system preference
30:     const prefersDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
31:     // Apply theme based on selection or system preference
32:     if (theme === "system") {
33:       applyTheme(prefersDark ? "dark" : "light");
34:     } else {
35:       applyTheme(theme as "light" | "dark");
36:     }
37:     // Listen for system preference changes if in auto mode
38:     const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
39:     const handleSystemThemeChange = (e: MediaQueryListEvent) => {
40:       if (theme === "system") {
41:         applyTheme(e.matches ? "dark" : "light");
42:       }
43:     };
44:     mediaQuery.addEventListener("change", handleSystemThemeChange);
45:     return () => mediaQuery.removeEventListener("change", handleSystemThemeChange);
46:   }, [theme]);
47:   return (
48:     <ThemeContext.Provider value={{ theme, currentTheme, setTheme }}>
49:       {children}
50:     </ThemeContext.Provider>
51:   );
52: };

================
File: src/context/ThemeContextType.ts
================
 1: import { createContext } from "react";
 2: export type ThemeType = "light" | "dark" | "system";
 3: export interface ThemeContextType {
 4:   theme: ThemeType;
 5:   currentTheme: "light" | "dark"; // The actual applied theme
 6:   setTheme: (theme: ThemeType) => void;
 7: }
 8: // Create context with proper typing
 9: const defaultThemeContext: ThemeContextType = {
10:   theme: "system",
11:   currentTheme: "light",
12:   setTheme: () => {},
13: };
14: export const ThemeContext = createContext(defaultThemeContext);

================
File: src/hooks/useTheme.ts
================
1: import { useContext } from "react";
2: import { ThemeContext } from "../context/ThemeContextType";
3: export const useTheme = () => {
4:   const context = useContext(ThemeContext);
5:   if (context === undefined) {
6:     throw new Error("useTheme must be used within a ThemeProvider");
7:   }
8:   return context;
9: };

================
File: src/renderer/components/FileExplorer/FileSystemManager.jsx
================
 1: import React, { useEffect, useState, useCallback, useRef } from "react";
 2: // ... existing imports ...
 3: // Import any UI components needed for notifications (if available in your codebase)
 4: import { toast } from 'react-hot-toast'; // Assuming you use react-hot-toast for notifications
 5: // ... existing code ...
 6: export const FileSystemManager = React.memo(({ onFilesUpdate, ...props }) => {
 7:   // ... existing state ...
 8:   const [processingStatus, setProcessingStatus] = useState({ status: null, message: null });
 9:   // ... existing code ...
10:   // Subscribe to file processing status updates
11:   useEffect(() => {
12:     // Setup listener for file processing status messages
13:     const handleFileProcessingStatus = (statusData) => {
14:       setProcessingStatus(statusData);
15:       // Display notifications for warnings and errors
16:       if (statusData.status === 'warning' || statusData.status === 'error') {
17:         toast[statusData.status === 'error' ? 'error' : 'warning'](
18:           statusData.message || 'An issue occurred while processing files'
19:         );
20:       }
21:     };
22:     window.electron.onFileProcessingStatus(handleFileProcessingStatus);
23:     return () => {
24:       // Clean up listener (if needed)
25:       // This depends on how your electron API is implemented
26:     };
27:   }, []);
28:   // ... existing code ...
29:   // You might want to display a status indicator somewhere in your UI based on processingStatus
30:   // Add this where appropriate in your render function
31:   return (
32:     <div className="file-explorer">
33:       {/* ... existing UI ... */}
34:       {processingStatus.status === 'warning' && (
35:         <div className="file-processing-warning">
36:           <span className="warning-icon">⚠️</span>
37:           <span className="warning-message">{processingStatus.message}</span>
38:         </div>
39:       )}
40:       {/* ... rest of your UI ... */}
41:     </div>
42:   );
43: });

================
File: src/styles/globals.css
================
 1: :root {
 2:   /* Base colors */
 3:   --background: #ffffff;
 4:   --background-primary: #ffffff;
 5:   --background-secondary: #f1f5f9;
 6:   --background-selected: #f8fafc;
 7:   --foreground: #0f172a;
 8:   /* Text colors */
 9:   --text-primary: #0f172a;
10:   --text-secondary: #64748b;
11:   --text-muted: #94a3b8;
12:   /* Border colors */
13:   --border-color: #e2e8f0;
14:   --border-hover: #cbd5e1;
15:   /* Component colors */
16:   --accent-color: #0ea5e9;
17:   --accent-hover: #0284c7;
18:   --accent-muted: #e0f2fe;
19:   /* Status colors */
20:   --success: #22c55e;
21:   --warning: #f59e0b;
22:   --error: #ef4444;
23:   /* Shadows */
24:   --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
25:   --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
26:   --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
27:   /* Radii */
28:   --radius: 6px;
29:   --radius-lg: 8px;
30:   --radius-full: 9999px;
31: }
32: .dark-mode {
33:   /* Base colors */
34:   --background: #0f172a;
35:   --background-primary: #1e293b;
36:   --background-secondary: #0f172a;
37:   --background-selected: #334155;
38:   --foreground: #f8fafc;
39:   /* Text colors */
40:   --text-primary: #f8fafc;
41:   --text-secondary: #94a3b8;
42:   --text-muted: #64748b;
43:   /* Border colors */
44:   --border-color: #1e293b;
45:   --border-hover: #334155;
46:   /* Component colors */
47:   --accent-color: #0ea5e9;
48:   --accent-hover: #38bdf8;
49:   --accent-muted: #0c4a6e;
50:   /* Status colors */
51:   --success: #22c55e;
52:   --warning: #f59e0b;
53:   --error: #ef4444;
54:   /* Shadows */
55:   --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.3);
56:   --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.4);
57:   --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4);
58: }
59: /* ... rest of the existing styles ... */

================
File: src/styles/index.css
================
  1: :root {
  2:   /* Refined monochrome Zinc theme with improved contrasts */
  3:   --background-primary: hsl(0, 0%, 100%);
  4:   --background-primary-dark: hsl(240, 10%, 3.9%);
  5:   --background-secondary: hsla(240, 4.8%, 95.9%, 0.92);
  6:   --background-selected: hsla(216, 12%, 92%, 0.85);
  7:   --card-background: hsla(0, 0%, 100%, 0.92);
  8:   --card-foreground: hsl(240, 10%, 3.9%);
  9:   --accent-color: hsl(215, 25%, 27%);
 10:   --border-color: hsla(240, 5.9%, 90%, 0.85);
 11:   --hover-color: hsla(210, 8%, 90%, 0.85);
 12:   --text-primary: hsl(240, 10%, 3.9%);
 13:   --text-secondary: hsl(215, 14%, 34%);
 14:   --text-disabled: hsl(240, 3.8%, 70%);
 15:   --icon-color: hsl(215, 14%, 34%);
 16:   --success-color: hsl(142, 72%, 29%);
 17:   --warning-color: hsl(40, 92%, 40%);
 18:   --error-color: hsl(0, 84.2%, 60.2%);
 19:   --primary-button-background: transparent;
 20:   --primary-button-text: var(--text-primary);
 21:   --primary-button-border: var(--border-color);
 22:   --primary-button-hover: var(--hover-color);
 23:   --primary-button-active: var(--secondary-button-active);
 24:   --secondary-button-background: hsla(240, 4.8%, 95.9%, 0.9);
 25:   --secondary-button-hover: hsla(210, 8%, 90%, 0.9);
 26:   --secondary-button-active: hsla(210, 8%, 85%, 0.9);
 27:   --file-card-selected-border: hsla(211, 100%, 50%, 0.4);
 28:   --popover: hsla(0, 0%, 100%, 0.95);
 29:   --popover-foreground: hsl(0, 0%, 0%);
 30:   /* Component Sizing */
 31:   --button-height-sm: 22px;
 32:   --button-height-md: 26px;
 33:   --button-height-lg: 30px;
 34:   /* Border radius */
 35:   --radius: 0.4rem;
 36:   --radius-full: 9999px;
 37:   /* Focus ring */
 38:   --ring-color: hsl(211, 100%, 50%);
 39:   /* Scrollbar */
 40:   --scrollbar-width: 6px;
 41:   --scrollbar-height: 6px;
 42:   --scrollbar-track-color: transparent;
 43:   --scrollbar-thumb-color: hsla(215, 14%, 80%, 0.6);
 44:   --scrollbar-thumb-hover-color: hsla(215, 14%, 70%, 0.8);
 45:   /* Z-index layers */
 46:   --z-index-modal: 1000;
 47:   --z-index-dropdown: 100;
 48:   --z-index-tooltip: 50;
 49:   /* Elevation (box-shadows) */
 50:   --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
 51:   --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.08);
 52:   --shadow-lg: 0 4px 12px rgba(0, 0, 0, 0.1);
 53:   --shadow-xl: 0 8px 16px rgba(0, 0, 0, 0.15);
 54:   /* Backdrop blur for vibrancy */
 55:   --backdrop-blur-sm: blur(8px);
 56:   --backdrop-blur-md: blur(12px);
 57:   --backdrop-blur-lg: blur(16px);
 58:   /* Font Sizes (reduced by ~25%) */
 59:   --font-size-xs: 0.65rem;
 60:   --font-size-sm: 0.75rem;
 61:   --font-size-md: 0.85rem;
 62:   --font-size-lg: 1rem;
 63:   --font-size-xl: 1.15rem;
 64:   /* Component Spacing */
 65:   --spacing-xs: 0.25rem;
 66:   --spacing-sm: 0.5rem;
 67:   --spacing-md: 0.75rem;
 68:   --spacing-lg: 1rem;
 69: }
 70: /* Dark theme variables - enhanced for better contrast and modern feel */
 71: .dark-mode {
 72:   --background-primary: hsla(220, 13%, 9%, 0.9);
 73:   --background-primary-dark: hsla(220, 13%, 9%, 0.95);
 74:   --background-secondary: hsla(220, 13%, 14%, 0.85);
 75:   --background-selected: hsla(222, 15%, 19%, 0.75);
 76:   --card-background: hsla(220, 13%, 9%, 0.85);
 77:   --card-foreground: hsl(0, 0%, 98%);
 78:   --accent-color: hsl(213, 30%, 60%);
 79:   --border-color: hsla(220, 13%, 18%, 0.8);
 80:   --hover-color: hsla(222, 15%, 22%, 0.8);
 81:   --text-primary: hsl(0, 0%, 98%);
 82:   --text-secondary: hsl(214, 15%, 72%);
 83:   --text-disabled: hsl(214, 15%, 50%);
 84:   --icon-color: hsl(214, 15%, 72%);
 85:   --primary-button-background: transparent;
 86:   --primary-button-text: var(--text-primary);
 87:   --primary-button-border: var(--border-color);
 88:   --primary-button-hover: var(--hover-color);
 89:   --primary-button-active: var(--secondary-button-active);
 90:   --secondary-button-background: hsla(222, 15%, 18%, 0.9);
 91:   --secondary-button-hover: hsla(222, 15%, 22%, 0.9);
 92:   --secondary-button-active: hsla(222, 15%, 27%, 0.9);
 93:   --file-card-selected-border: hsla(211, 100%, 65%, 0.5);
 94:   --scrollbar-thumb-color: hsla(220, 13%, 25%, 0.6);
 95:   --scrollbar-thumb-hover-color: hsla(220, 13%, 35%, 0.8);
 96:   --popover-foreground: hsl(0, 0%, 98%);
 97:   --dropdown-menu-background: hsla(220, 13%, 9%, 0.95);
 98:   --dropdown-item-hover: hsla(222, 15%, 18%, 0.9);
 99:   --ring-color: hsl(211, 100%, 65%);
100: }
101: /* Reset and base styles */
102: * {
103:   margin: 0;
104:   padding: 0;
105:   box-sizing: border-box;
106: }
107: :root,
108: .dark-mode {
109:   transition: 
110:     color 0.15s ease-out,
111:     background-color 0.15s ease-out,
112:     border-color 0.15s ease-out,
113:     box-shadow 0.15s ease-out;
114: }
115: body {
116:   font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
117:   -webkit-font-smoothing: antialiased;
118:   -moz-osx-font-smoothing: grayscale;
119:   background-color: var(--background-primary);
120:   color: var(--text-primary);
121:   transition: background-color 0.15s ease-out, color 0.15s ease-out;
122:   font-size: var(--font-size-sm);
123:   line-height: 1.4;
124: }
125: #root {
126:   min-height: 100vh;
127:   display: flex;
128:   flex-direction: column;
129: }
130: /* Global scrollbar styling */
131: ::-webkit-scrollbar {
132:   width: var(--scrollbar-width);
133:   height: var(--scrollbar-height);
134: }
135: ::-webkit-scrollbar-track {
136:   background: var(--scrollbar-track-color);
137: }
138: ::-webkit-scrollbar-thumb {
139:   background: var(--scrollbar-thumb-color);
140:   border-radius: var(--radius-full);
141: }
142: ::-webkit-scrollbar-thumb:hover {
143:   background: var(--scrollbar-thumb-hover-color);
144: }
145: ::-webkit-scrollbar-corner {
146:   background: transparent;
147: }
148: /* Global button style adjustments */
149: button, 
150: .button {
151:   font-size: var(--font-size-sm);
152:   line-height: 1;
153:   padding: 0.35rem 0.6rem;
154: }
155: /* Input fields */
156: input, 
157: textarea, 
158: select {
159:   font-size: var(--font-size-sm);
160:   padding: 0.25rem 0.5rem;
161:   line-height: 1.4;
162:   letter-spacing: normal;
163:   text-rendering: auto;
164: }
165: /* Headings */
166: h1 { font-size: var(--font-size-xl); }
167: h2 { font-size: var(--font-size-lg); }
168: h3 { font-size: var(--font-size-md); }
169: h4, h5, h6 { font-size: var(--font-size-sm); }
170: /* List items */
171: li { font-size: var(--font-size-sm); }
172: /* Tables */
173: table { font-size: var(--font-size-sm); }
174: /* Dialog/modal content */
175: dialog, 
176: .modal {
177:   font-size: var(--font-size-sm);
178: }

================
File: src/types/css.d.ts
================
1: declare module '*.module.css' {
2:   const classes: { [key: string]: string };
3:   export default classes;
4: }

================
File: src/types/electron.d.ts
================
 1: declare global {
 2:   interface Window {
 3:     /**
 4:      * Electron API exposed through contextBridge in preload.js
 5:      */
 6:     electron: {
 7:       /**
 8:        * IPC Renderer interface for communication with the main process
 9:        */
10:       ipcRenderer: {
11:         /**
12:          * Send a message to the main process
13:          * @param channel - The channel to send the message on
14:          * @param data - Optional data to send with the message
15:          */
16:         send: (channel: string, data?: any) => void;
17:         /**
18:          * Register a listener for messages from the main process
19:          * @param channel - The channel to listen on
20:          * @param func - The callback function to handle the message
21:          */
22:         on: (channel: string, func: (...args: any[]) => void) => void;
23:         /**
24:          * Remove a listener for messages from the main process
25:          * @param channel - The channel to remove the listener from
26:          * @param func - The callback function to remove
27:          */
28:         removeListener: (channel: string, func: (...args: any[]) => void) => void;
29:         /**
30:          * Invoke a method in the main process and get a response
31:          * @param channel - The channel to invoke the method on
32:          * @param data - Optional data to send with the invocation
33:          * @returns A promise that resolves with the result from the main process
34:          */
35:         invoke: <T = any>(channel: string, data?: any) => Promise<T>;
36:         /**
37:          * Set the maximum number of listeners for a channel
38:          * @param n - The maximum number of listeners
39:          */
40:         setMaxListeners?: (n: number) => void;
41:       };
42:       // Specific invoke methods
43:       openFolder: () => Promise<string | null>;
44:       readFile: (filePath: string) => Promise<string | null>;
45:       requestFileList: (data: { path: string; forceRefresh?: boolean }) => Promise<any>; // Consider defining a stricter return type
46:       saveIgnorePatterns: (data: { patterns: string; isGlobal: boolean; folderPath?: string }) => Promise<{ success: boolean; error?: string }>;
47:       loadIgnorePatterns: (data: { folderPath?: string; isGlobal: boolean }) => Promise<{ success: boolean; patterns: string; systemPatterns: string[]; excludedPatterns: string[]; error?: string }>;
48:       resetIgnorePatterns: (data: { folderPath?: string; isGlobal: boolean }) => Promise<{ success: boolean; patterns?: string; systemPatterns?: string[]; error?: string }>;
49:       clearLocalIgnorePatterns: (data: { folderPath: string }) => Promise<{ success: boolean; error?: string }>;
50:       getFileContent: (filePath: string) => Promise<{ success: boolean; content?: string; size?: number; lastModified?: number; error?: string }>;
51:       testIgnorePatterns: (data: { folderPath: string; patterns: string }) => Promise<{ success: boolean; ignoredCount?: number; ignoredFiles?: string[]; totalFilesChecked?: number; error?: string }>;
52:       compressCode: (source: string, language: string) => Promise<string | null>;
53:       removeComments: (source: string, language: string, keepDocstrings?: boolean) => Promise<string | null>;
54:       countTokens: (text: string) => Promise<number>; // Added based on error messages
55:       getFileMetadata: (filePath: string) => Promise<{ 
56:         success: boolean; 
57:         fileData?: { 
58:           name: string; 
59:           path: string; 
60:           size: number; 
61:           lastModified: number; 
62:           isBinary: boolean; 
63:           excludedByDefault: boolean; 
64:           excluded: boolean; 
65:           isSkipped: boolean; 
66:           tokenCount: number; 
67:           uncompressedTokenCount: number;
68:           error?: string;
69:         }; 
70:         error?: string 
71:       }>;
72:       // Send method (if still needed - prefer specific invokes)
73:       send: (channel: string, data?: any) => void;
74:       // Receive method (if still needed)
75:       receive: (channel: string, func: (...args: any[]) => void) => void;
76:       // Optional: Keep generic ipcRenderer if absolutely necessary, but discourage use
77:       ipcRenderer?: {
78:         send: (channel: string, data?: any) => void;
79:         invoke: (channel: string, data?: any) => Promise<any>;
80:         on: (channel: string, func: (...args: any[]) => void) => any; // Return type might vary
81:         removeListener: (channel: string, func: (...args: any[]) => void) => void;
82:         removeAllListeners: (channel: string) => void;
83:       };
84:     };
85:   }
86: }
87: export {};

================
File: src/types/FileInfo.ts
================
 1: // Commenting out the unused FileInfo type
 2: /*
 3: export interface FileInfo {
 4:   name: string;
 5:   path: string;
 6:   size: number;
 7:   lastModified: number;
 8:   isBinary: boolean;
 9:   tokenCount: number; 
10:   excludedByDefault: boolean;
11:   excluded: boolean;
12:   isSkipped: boolean; 
13: }
14: */
15: export {}; // Keep this if the file becomes empty

================
File: src/types/GlobalPatternsState.ts
================
1: // Commenting out the unused GlobalPatternsState type
2: /*
3: export interface GlobalPatternsState {
4:   patterns: string;
5:   excludedSystemPatterns: string[];
6: }
7: */
8: export {}; // Keep this if the file becomes empty

================
File: src/types/index.ts
================
1: // Re-export all types from FileTypes.ts
2: export * from './FileTypes';

================
File: src/types/ModelTypes.ts
================
 1: /**
 2:  * Represents the information structure for an AI model,
 3:  * typically fetched from an API like OpenRouter.
 4:  */
 5: export interface ModelInfo {
 6:   id: string;           // Unique identifier for the model (e.g., "openai/gpt-4o")
 7:   name: string;         // User-friendly display name (e.g., "GPT-4o")
 8:   context_length: number; // Maximum context window size in tokens
 9:   // Add other relevant properties from the API if needed, e.g.:
10:   // description?: string;
11:   // pricing?: { prompt: number; completion: number; };
12: }

================
File: src/types/SortOrder.ts
================
 1: // Commenting out the unused SortOrder type
 2: /*
 3: export type SortOrder = 
 4:   | "name-ascending"
 5:   | "name-descending"
 6:   | "tokens-ascending"
 7:   | "tokens-descending"
 8:   | "date-ascending"
 9:   | "date-descending";
10: */
11: export {}; // Keep this if the file becomes empty

================
File: src/utils/cn.ts
================
 1: /**
 2:  * Merges class names conditionally
 3:  * @param classes - Array of class names or objects with class names as keys and booleans as values
 4:  * @returns Merged class names string
 5:  */
 6: export function cn(...classes: (string | boolean | undefined | null | { [key: string]: boolean })[]): string {
 7:   return classes
 8:     .filter(Boolean)
 9:     .map((item) => {
10:       if (typeof item === 'string') return item;
11:       if (typeof item === 'object' && item !== null) {
12:         return Object.entries(item)
13:           .filter(([, value]) => value)
14:           .map(([key]) => key)
15:           .join(' ');
16:       }
17:       return '';
18:     })
19:     .join(' ')
20:     .trim();
21: }

================
File: src/utils/compressionUtils.ts
================
  1: // This file now acts as a bridge to the main process for heavy compression tasks.
  2: // Global type definition is now in src/types/electron.d.ts
  3: /**
  4:  * Asynchronously removes comments from source code by calling the main process.
  5:  *
  6:  * @param source The source code string.
  7:  * @param language The programming language.
  8:  * @param keepDocstrings Whether to preserve documentation comments.
  9:  * @returns A Promise resolving to the source code with comments removed, or null on failure.
 10:  */
 11: export async function removeComments(source: string, language: string, keepDocstrings: boolean = true): Promise<string | null> {
 12:   if (!source || !language) {
 13:     console.warn("Source and language required for comment removal.");
 14:     return source; // Return original if inputs are invalid
 15:   }
 16:   try {
 17:     const result = await window.electron.removeComments(source, language, keepDocstrings);
 18:     return result;
 19:   } catch (error) {
 20:     console.error(`Error calling main process for comment removal (${language}):`, error);
 21:     return null; // Indicate failure
 22:   }
 23: }
 24: /**
 25:  * Asynchronously compresses source code by replacing function bodies via the main process.
 26:  *
 27:  * @param source The source code string.
 28:  * @param language The programming language (e.g., 'javascript', 'python').
 29:  * @returns A Promise resolving to the compressed source code string, or null if compression failed or is not supported.
 30:  */
 31: export async function compressCode(source: string, language: string): Promise<string | null> {
 32:   if (!source || !language) {
 33:     console.warn("Source and language required for code compression.");
 34:     return source; // Return original if inputs are invalid
 35:   }
 36:   try {
 37:     const result = await window.electron.compressCode(source, language);
 38:     // If result is null, it means main process failed or didn't support it
 39:     // If result is same as source, it means nothing was compressed (no bodies found)
 40:     return result; 
 41:   } catch (error) {
 42:     console.error(`Error calling main process for code compression (${language}):`, error);
 43:     return null; // Indicate failure
 44:   }
 45: }
 46: // Keep any other utility functions here that DON'T depend on tree-sitter
 47: // For example, if you had functions for determining language from filename,
 48: // they could stay here.
 49: /**
 50:  * Gets a simple language identifier from a filename.
 51:  * @param filename The filename (e.g., 'myComponent.tsx')
 52:  * @returns A language string (e.g., 'typescript', 'python') or null.
 53:  */
 54: export function getLanguageFromFilename(filename: string): string | null {
 55:   if (!filename) return null;
 56:   // More reliable extension extraction
 57:   const lastDotIndex = filename.lastIndexOf('.');
 58:   const extension = lastDotIndex !== -1 ? filename.slice(lastDotIndex + 1).toLowerCase() : '';
 59:   if (!extension) return null;
 60:   switch (extension) {
 61:     case 'js':
 62:     case 'jsx':
 63:       return 'javascript';
 64:     case 'ts':
 65:     case 'tsx':
 66:       return 'typescript';
 67:     case 'py':
 68:       return 'python';
 69:     case 'css':
 70:       return 'css';
 71:     case 'html':
 72:     case 'htm':
 73:       return 'html';
 74:     // Add more mappings as needed
 75:     default:
 76:       return null; // Or return the extension itself if you want to attempt unsupported types
 77:   }
 78: }
 79: // --- Example Usage (for testing) ---
 80: /*
 81: const jsCode = `
 82: function hello(name) {
 83:   console.log("Hello, " + name);
 84:   return true;
 85: }
 86: const add = (a, b) => {
 87:   const result = a + b;
 88:   return result;
 89: };
 90: class Greeter {
 91:   constructor(greeting) {
 92:     this.greeting = greeting;
 93:   }
 94:   greet() {
 95:     console.log(this.greeting);
 96:   }
 97: }
 98: `;
 99: const pyCode = `
100: def greet(name):
101:     print(f"Hello, {name}!")
102:     return f"Hi, {name}"
103: class Calculator:
104:     def add(self, a, b):
105:         # Adds two numbers
106:         return a + b
107: `;
108: const compressedJs = compressCode(jsCode, 'javascript');
109: console.log("--- Compressed JS ---\n", compressedJs);
110: const compressedPy = compressCode(pyCode, 'python');
111: console.log("--- Compressed Python ---", compressedPy);
112: */

================
File: src/utils/create-variants.ts
================
 1: /**
 2:  * Creates a map of variant classes for a component.
 3:  * Based on the concept of class-variance-authority but simplified.
 4:  */
 5: export function createVariants<T extends string>(
 6:   baseClass: string,
 7:   variantMap: Record<T, string>
 8: ): {
 9:   base: string;
10:   variants: Record<T, string>;
11:   getVariantClass: (variant: T) => string;
12: } {
13:   return {
14:     base: baseClass,
15:     variants: variantMap,
16:     getVariantClass: (variant: T) => variantMap[variant] || ''
17:   };
18: }

================
File: src/utils/modelUtils.ts
================
  1: import { OPENROUTER_MODELS_API_URL } from '../constants/api';
  2: import { ModelInfo } from '../types/ModelTypes';
  3: // Constants for localStorage
  4: const MODELS_CACHE_KEY = 'pastemax-cached-models';
  5: const MODELS_CACHE_TIMESTAMP_KEY = 'pastemax-models-cache-timestamp';
  6: const CACHE_EXPIRY_TIME = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
  7: /**
  8:  * Fetches the list of available models from the OpenRouter API.
  9:  * @param {boolean} forceRefresh - Whether to force fetching from API instead of using cache
 10:  * @returns {Promise<ModelInfo[] | null>} A promise that resolves to an array of model objects or null if an error occurs.
 11:  */
 12: export async function fetchModels(forceRefresh = false): Promise<ModelInfo[] | null> {
 13:   // Try to get models from cache first, unless forceRefresh is true
 14:   if (!forceRefresh) {
 15:     const cachedModels = getCachedModels();
 16:     if (cachedModels) {
 17:       console.log(`Using ${cachedModels.length} cached models.`);
 18:       return cachedModels;
 19:     }
 20:   }
 21:   console.log(`Fetching models from ${OPENROUTER_MODELS_API_URL}...`);
 22:   try {
 23:     const response = await fetch(OPENROUTER_MODELS_API_URL);
 24:     if (!response.ok) {
 25:       console.error(`Error fetching models: ${response.status} ${response.statusText}`);
 26:       // Consider more specific error handling or returning an empty array
 27:       // depending on how the caller should react to fetch failures.
 28:       return null;
 29:     }
 30:     const data = await response.json();
 31:     // Assuming the API returns an object with a 'data' property containing the array of models
 32:     // Adjust this based on the actual API response structure
 33:     if (data && Array.isArray(data.data)) {
 34:        console.log(`Successfully fetched ${data.data.length} models.`);
 35:       const models = data.data as ModelInfo[];
 36:       // Cache the fetched models
 37:       cacheModels(models);
 38:       return models;
 39:     } else {
 40:       console.error("Error fetching models: Invalid response format. Expected object with 'data' array.", data);
 41:       return null;
 42:     }
 43:   } catch (error) {
 44:     console.error('Error fetching models:', error);
 45:     return null; // Return null or throw the error based on desired handling
 46:   }
 47: }
 48: /**
 49:  * Saves models to localStorage cache with timestamp
 50:  * @param models The models to cache
 51:  */
 52: function cacheModels(models: ModelInfo[]): void {
 53:   try {
 54:     localStorage.setItem(MODELS_CACHE_KEY, JSON.stringify(models));
 55:     localStorage.setItem(MODELS_CACHE_TIMESTAMP_KEY, Date.now().toString());
 56:     console.log(`Cached ${models.length} models.`);
 57:   } catch (error) {
 58:     console.error('Error caching models:', error);
 59:   }
 60: }
 61: /**
 62:  * Retrieves cached models if available and not expired
 63:  * @returns The cached models or null if unavailable or expired
 64:  */
 65: export function getCachedModels(): ModelInfo[] | null {
 66:   try {
 67:     const cachedModelsJson = localStorage.getItem(MODELS_CACHE_KEY);
 68:     const timestampStr = localStorage.getItem(MODELS_CACHE_TIMESTAMP_KEY);
 69:     if (!cachedModelsJson || !timestampStr) {
 70:       return null;
 71:     }
 72:     // Check if cache is expired
 73:     const timestamp = parseInt(timestampStr);
 74:     const now = Date.now();
 75:     if (now - timestamp > CACHE_EXPIRY_TIME) {
 76:       console.log('Models cache expired, will fetch fresh data.');
 77:       return null;
 78:     }
 79:     // Calculate age for logging
 80:     const ageHours = Math.round((now - timestamp) / (60 * 60 * 1000) * 10) / 10;
 81:     // Parse and return cached models
 82:     const cachedModels = JSON.parse(cachedModelsJson);
 83:     console.log(`Using cached models (${ageHours} hours old).`);
 84:     return Array.isArray(cachedModels) ? cachedModels : null;
 85:   } catch (error) {
 86:     console.error('Error retrieving cached models:', error);
 87:     return null;
 88:   }
 89: }
 90: // Example Usage (You would call this from your App component or context):
 91: /*
 92: import { useEffect, useState } from 'react';
 93: import { fetchModels } from './utils/modelUtils';
 94: function App() {
 95:   const [models, setModels] = useState<any[] | null>(null);
 96:   useEffect(() => {
 97:     const loadModels = async () => {
 98:       const fetchedModels = await fetchModels();
 99:       setModels(fetchedModels);
100:     };
101:     loadModels();
102:   }, []);
103:   // ... rest of your component
104: }
105: */

================
File: src/utils/patternUtils.ts
================
  1: // System pattern categories - Moved from App.tsx
  2: export const SYSTEM_PATTERN_CATEGORIES = {
  3:     versionControl: [
  4:       "**/.git/**",
  5:       "**/.svn/**",
  6:       "**/.hg/**",
  7:       "**/.cvs/**" // Added .cvs
  8:     ],
  9:     buildOutput: [
 10:       "**/node_modules/**",
 11:       "**/dist/**",
 12:       "**/build/**",
 13:       "**/.output/**", // Added .output
 14:       "**/.next/**",
 15:     ],
 16:     caches: [
 17:       "**/.cache/**",
 18:       "**/__pycache__/**",
 19:       "**/.pytest_cache/**",
 20:     ],
 21:     logs: [
 22:       "**/logs/**",
 23:       "**/*.log",
 24:     ],
 25:     ide: [
 26:       "**/.idea/**",
 27:       "**/.vscode/**",
 28:       "**/.vs/**",
 29:     ],
 30:     temp: [
 31:       "**/tmp/**",
 32:       "**/temp/**",
 33:     ],
 34:     os: [
 35:       "**/.DS_Store",
 36:       "**/Thumbs.db",
 37:     ],
 38:   };
 39:   /**
 40:    * Interface for ignore patterns state
 41:    */
 42:   export interface IgnorePatternsState {
 43:     patterns: string;
 44:     excludedSystemPatterns: string[];
 45:   }
 46:   /**
 47:    * Parse ignore patterns content to extract disabled patterns and user patterns
 48:    */
 49:   export const parseIgnorePatternsContent = (content: string): { excludedPatterns: string[]; userPatterns: string } => {
 50:     if (!content) {
 51:       return { excludedPatterns: [], userPatterns: '' };
 52:     }
 53:     const lines = content.split('\n');
 54:     const excludedPatterns: string[] = [];
 55:     const userPatterns: string[] = [];
 56:     let inUserSection = false;
 57:     lines.forEach(line => {
 58:       const trimmedLine = line.trim();
 59:       // Check for section headers
 60:       if (trimmedLine === '# USER PATTERNS:') {
 61:         inUserSection = true;
 62:         return;
 63:       }
 64:       if (trimmedLine.startsWith('# DISABLED:')) {
 65:         // Extract pattern removing the DISABLED marker
 66:         const pattern = trimmedLine.substring('# DISABLED:'.length).trim();
 67:         if (pattern) {
 68:           excludedPatterns.push(pattern);
 69:         }
 70:       } else if (inUserSection && trimmedLine !== '' && !trimmedLine.startsWith('#')) {
 71:         // In user section, add non-comment lines to user patterns
 72:         userPatterns.push(line); // Keep original line to preserve indentation/whitespace
 73:       } else if (!inUserSection && !trimmedLine.startsWith('#') && trimmedLine !== '') {
 74:         // Not in user section yet, but found a pattern - also add to user patterns
 75:         // This handles the case where user patterns aren't properly marked with a section
 76:         userPatterns.push(line);
 77:       }
 78:       // Ignore empty lines and regular comments
 79:     });
 80:     // Ensure excluded patterns are unique
 81:     const uniqueExcluded = Array.from(new Set(excludedPatterns));
 82:     return {
 83:       excludedPatterns: uniqueExcluded,
 84:       userPatterns: userPatterns.join('\n')
 85:     };
 86:   };
 87:   // --- Keep existing functions below if they are used ---
 88:   // Pattern state update function (Example, confirm if used or remove)
 89:   /*
 90:   export const handlePatternStateUpdate = (patterns: string | string[]): string => {
 91:     return Array.isArray(patterns) ? patterns.join('\n') : patterns;
 92:   };
 93:   */
 94:   /**
 95:    * Format global patterns for saving
 96:    */
 97:   /*
 98:   export const formatPatternsForSaving = (
 99:     state: IgnorePatternsState,
100:     systemPatterns: string[] = []
101:   ): string => {
102:     // Combine user patterns and non-excluded system patterns
103:     const userLines = state.patterns.split('\n').map(p => p.trim()).filter(p => p !== '');
104:     const activeSystemPatterns = systemPatterns.filter(p => !state.excludedSystemPatterns.includes(p));
105:     // Structure with comments might be helpful, but for now just combine
106:     // A simple approach: just save the user patterns string
107:     // If more complex logic is needed (like preserving comments or sections), adjust here
108:     return state.patterns; 
109:     // Alternative: Combine user and active system if needed for storage format
110:     // return [...userLines, ...activeSystemPatterns].join('\n');
111:   };
112:   */
113:   // Keep other potentially used exports like saveIgnoreStateToStorage if needed

================
File: src/utils/sortIcons.tsx
================
 1: import React from 'react';
 2: import type { LucideIcon } from 'lucide-react';
 3: import { 
 4:   ArrowUpDown,        // Default icon
 5:   ArrowDownAZ,        // For name-ascending
 6:   ArrowUpZA,          // For name-descending
 7:   ArrowUp01,          // For tokens-ascending
 8:   ArrowDown10,        // For tokens-descending
 9:   ArrowUpNarrowWide,  // For date-ascending
10:   ArrowDownWideNarrow // For date-descending
11: } from "lucide-react";
12: // Map sort options to corresponding Lucide icons
13: export const sortIconMap = {
14:   "name-ascending": "ArrowDownAZ",
15:   "name-descending": "ArrowUpZA",
16:   "tokens-ascending": "ArrowUp01",
17:   "tokens-descending": "ArrowDown10",
18:   "date-ascending": "ArrowUpNarrowWide",
19:   "date-descending": "ArrowDownWideNarrow"
20: } as const;
21: // Icon component lookup for direct reference
22: export const iconComponents: Record<string, LucideIcon> = {
23:   "ArrowDownAZ": ArrowDownAZ,
24:   "ArrowUpZA": ArrowUpZA,
25:   "ArrowUp01": ArrowUp01,
26:   "ArrowDown10": ArrowDown10,
27:   "ArrowUpNarrowWide": ArrowUpNarrowWide,
28:   "ArrowDownWideNarrow": ArrowDownWideNarrow,
29:   "ArrowUpDown": ArrowUpDown  // Default
30: };
31: // Helper function to get the appropriate icon component
32: export const getSortIcon = (sortOrder?: string, size: number = 16): JSX.Element => {
33:   try {
34:     const iconName = sortOrder && sortIconMap[sortOrder as keyof typeof sortIconMap] 
35:       ? sortIconMap[sortOrder as keyof typeof sortIconMap] 
36:       : "ArrowUpDown";
37:     const IconComponent = iconComponents[iconName];
38:     return <IconComponent size={size} />;
39:   } catch (error) {
40:     console.error("Error rendering sort icon:", error);
41:     return <ArrowUpDown size={size} />;
42:   }
43: };

================
File: src/App.module.css
================
  1: .app {
  2:   display: flex;
  3:   flex-direction: column;
  4:   height: 100vh;
  5:   background: var(--bg-primary);
  6:   color: var(--text-primary);
  7: }
  8: .header {
  9:   display: flex;
 10:   align-items: center;
 11:   justify-content: space-between;
 12:   padding: 0.5rem;
 13:   background: var(--bg-secondary);
 14:   border-bottom: 1px solid var(--border-color);
 15: }
 16: .headerLeft,
 17: .headerRight {
 18:   display: flex;
 19:   align-items: center;
 20:   gap: 0.25rem;
 21: }
 22: .headerBtn {
 23:   color: var(--text-primary);
 24: }
 25: .headerBtn:hover {
 26:   background: var(--bg-hover);
 27: }
 28: .dropdownContainer {
 29:   position: relative;
 30:   display: inline-flex;
 31:   align-items: center;
 32:   height: 32px;
 33: }
 34: .appContainer {
 35:   display: flex;
 36:   flex-direction: column;
 37:   height: 100vh;
 38:   width: 100%;
 39:   overflow: hidden;
 40: }
 41: .mainContainer {
 42:   display: flex;
 43:   flex: 1;
 44:   overflow: hidden;
 45:   position: relative;
 46: }
 47: .contentArea {
 48:   flex-grow: 1;
 49:   padding: 0;
 50:   overflow-y: auto;
 51:   display: flex;
 52:   flex-direction: column;
 53:   height: 100%;
 54:   background: var(--background);
 55:   border-left: 1px solid var(--border);
 56:   background-color: var(--background-primary);
 57:   backdrop-filter: var(--backdrop-blur-sm);
 58:   -webkit-backdrop-filter: var(--backdrop-blur-sm);
 59: }
 60: .contentHeader {
 61:   display: flex;
 62:   align-items: center;
 63:   padding: 0.5rem 1rem;
 64:   border-bottom: 1px solid var(--border-color);
 65:   background: var(--background-primary);
 66:   height: 46px;
 67:   position: sticky;
 68:   top: 0;
 69:   z-index: 10;
 70:   gap: 12px;
 71:   backdrop-filter: var(--backdrop-blur-sm);
 72:   -webkit-backdrop-filter: var(--backdrop-blur-sm);
 73: }
 74: .contentTitle {
 75:   display: none;
 76: }
 77: .contentActions {
 78:   display: flex;
 79:   gap: 0.75rem;
 80:   align-items: center;
 81:   height: 32px;
 82:   margin-left: 0;
 83: }
 84: .folderPathDisplay {
 85:   font-size: 0.7rem;
 86:   color: var(--text-secondary);
 87:   padding: 0 0.75rem;
 88:   height: 32px;
 89:   display: inline-flex;
 90:   align-items: center;
 91:   overflow: hidden;
 92:   text-overflow: ellipsis;
 93:   white-space: nowrap;
 94:   flex: 1;
 95:   min-width: 0;
 96:   font-family: var(--font-mono, monospace);
 97: }
 98: .pathLabel {
 99:   color: var(--text-primary);
100:   margin-right: 0.5rem;
101:   font-weight: 500;
102:   font-family: var(--font-sans, Courier);
103: }
104: .fileStats {
105:   font-size: 0.75rem;
106:   color: var(--text-secondary);
107:   padding: 0 0.75rem;
108:   height: 32px;
109:   display: flex;
110:   align-items: center;
111:   white-space: nowrap;
112:   flex-shrink: 0;
113: }
114: .fileStats span {
115:   color: var(--text-primary);
116:   font-weight: 500;
117:   margin: 0 0.15rem;
118: }
119: .appHeader {
120:   display: flex;
121:   justify-content: space-between;
122:   align-items: center;
123:   padding: 0.5rem 1rem;
124:   background-color: var(--background-secondary);
125:   border-bottom: 1px solid var(--border-color);
126:   backdrop-filter: var(--backdrop-blur-md);
127:   -webkit-backdrop-filter: var(--backdrop-blur-md);
128:   z-index: 10;
129: }
130: .headerActions {
131:   display: flex;
132:   align-items: center;
133:   gap: 0.5rem;
134: }
135: .headerLink {
136:   color: var(--text-primary);
137:   text-decoration: none;
138:   transition: color 0.2s;
139: }
140: .headerLink:hover {
141:   color: var(--accent-color);
142: }
143: .headerSeparator {
144:   width: 1px;
145:   height: 24px;
146:   background-color: var(--border-color);
147:   margin: 0 0.75rem;
148:   opacity: 0.6;
149: }
150: .githubButton {
151:   display: flex;
152:   align-items: center;
153:   gap: 0.5rem;
154:   padding: 0.5rem;
155:   border-radius: var(--radius);
156:   text-decoration: none;
157:   color: var(--accent-color);
158:   transition: color 0.2s;
159: }
160: .githubButton:hover {
161:   color: var(--text-primary);
162: }
163: .treeEmpty {
164:   display: flex;
165:   flex-direction: column;
166:   align-items: center;
167:   justify-content: center;
168:   padding: 2rem;
169:   text-align: center;
170:   color: var(--text-secondary);
171: }
172: .treeLoading {
173:   display: flex;
174:   flex-direction: column;
175:   align-items: center;
176:   justify-content: center;
177:   padding: 2rem;
178:   text-align: center;
179:   color: var(--text-secondary);
180: }
181: .spinner {
182:   border: 3px solid rgba(0, 0, 0, 0.1);
183:   border-top: 3px solid var(--accent-color);
184:   border-radius: 50%;
185:   width: 20px;
186:   height: 20px;
187:   animation: spin 1s linear infinite;
188:   margin-bottom: 1rem;
189: }
190: .processingIndicator {
191:   display: flex;
192:   align-items: center;
193:   justify-content: center;
194:   gap: 0.5rem;
195:   padding: 0.5rem;
196:   background-color: var(--background-secondary);
197:   color: var(--text-secondary);
198:   font-size: 0.9rem;
199: }
200: .errorMessage {
201:   padding: 0.5rem 1rem;
202:   background-color: var(--error-color);
203:   color: white;
204:   font-size: 0.9rem;
205: }
206: .userInstructionsContainer {
207:   margin-top: 1rem;
208:   animation: instructionsSlideDown 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
209:   transform-origin: top;
210:   overflow: hidden;
211: }
212: .emptyStateContent {
213:   display: flex;
214:   flex-direction: column;
215:   align-items: center;
216:   justify-content: center;
217:   padding: 2rem;
218:   text-align: center;
219: }
220: .emptyStateContent h2 {
221:   margin-bottom: 1rem;
222: }
223: .emptyStateContent ul {
224:   text-align: left;
225:   margin-top: 1rem;
226: }
227: @keyframes spin {
228:   0% { transform: rotate(0deg); }
229:   100% { transform: rotate(360deg); }
230: }
231: @keyframes dropdownFadeIn {
232:   from {
233:     opacity: 0;
234:     transform: translateY(-8px);
235:   }
236:   to {
237:     opacity: 1;
238:     transform: translateY(0);
239:   }
240: }
241: @keyframes tooltipFadeIn {
242:   from {
243:     opacity: 0;
244:     transform: translateY(-4px);
245:   }
246:   to {
247:     opacity: 1;
248:     transform: translateY(0);
249:   }
250: }
251: @keyframes instructionsSlideDown {
252:   from {
253:     opacity: 0;
254:     max-height: 0;
255:     transform: translateY(-10px);
256:   }
257:   to {
258:     opacity: 1;
259:     max-height: 1000px;
260:     transform: translateY(0);
261:   }
262: }

================
File: src/declarations.d.ts
================
 1: // Type declarations for external modules
 2: declare module "react";
 3: declare module "react-dom/client";
 4: declare module "react/jsx-runtime";
 5: declare module "electron";
 6: declare module "tiktoken";
 7: declare module "ignore";
 8: declare module "gpt-3-encoder";
 9: // Allow importing CSS files
10: declare module "*.css" {
11:   const content: { [className: string]: string };
12:   export default content;
13: }
14: // Allow importing various file types
15: declare module "*.svg" {
16:   const content: string;
17:   export default content;
18: }
19: declare module "*.png" {
20:   const content: string;
21:   export default content;
22: }
23: declare module "*.jpg" {
24:   const content: string;
25:   export default content;
26: }
27: // Add CSS module declarations
28: declare module '*.module.css' {
29:   const classes: { [key: string]: string };
30:   export default classes;
31: }
32: // React / TypeScript setup fixes
33: import 'react';
34: declare module 'react' {
35:   export type FC<P = Record<string, never>> = React.FunctionComponent<P>;
36:   export interface FunctionComponent<P = Record<string, never>> {
37:     (props: P, context?: any): React.ReactElement<any, any> | null;
38:     displayName?: string;
39:   }
40:   export type MouseEvent<T = Element> = React.MouseEvent<T>;
41:   export type ChangeEvent<T = Element> = React.ChangeEvent<T>;
42:   export type ReactElement = React.ReactElement;
43: }

================
File: src/main.tsx
================
1: import React from "react";
2: import ReactDOM from "react-dom/client";
3: import App from "./App";
4: import "./styles/index.css";
5: ReactDOM.createRoot(document.getElementById("root")!).render(
6:   <React.StrictMode>
7:     <App />
8:   </React.StrictMode>,
9: );

================
File: src/react-app-env.d.ts
================
 1: /// <reference types="react" />
 2: /// <reference types="react-dom" />
 3: /// <reference types="react-scripts" />
 4: // Add missing TypeScript definitions
 5: declare namespace React {
 6:   interface MouseEvent<T extends Element> extends globalThis.MouseEvent {
 7:     currentTarget: T;
 8:   }
 9:   interface ChangeEvent<T extends Element> extends Event {
10:     target: T;
11:   }
12: }
13: // Fix the type parameters that are unused
14: interface ImportMeta {
15:   readonly hot: {
16:     readonly data: any;
17:     accept(): void;
18:     accept(cb: (dependencies: any) => void): void;
19:     accept(path: string, cb: (dependencies: any) => void): void;
20:   };
21: }
22: declare module '*.module.css' {
23:   const classes: Record<string, string>;
24:   export default classes;
25: }
26: declare module '*.svg' {
27:   const content: string;
28:   export default content;
29: }
30: declare module '*.png' {
31:   const content: string;
32:   export default content;
33: }
34: declare module '*.jpg' {
35:   const content: string;
36:   export default content;
37: }
38: declare module '*.jpeg' {
39:   const content: string;
40:   export default content;
41: }
42: declare module '*.gif' {
43:   const content: string;
44:   export default content;
45: }
46: declare module '*.webp' {
47:   const content: string;
48:   export default content;
49: }
50: declare module '*.ico' {
51:   const content: string;
52:   export default content;
53: }
54: declare module '*.bmp' {
55:   const content: string;
56:   export default content;
57: }

================
File: .tsprunerc
================
1: {
2:   "project": "tsconfig.json",
3:   "ignore": [
4:     "src/types",
5:     "src/declarations.d.ts",
6:     "src/**/*.module.css.d.ts"
7:   ]
8: }

================
File: index.html
================
 1: <!DOCTYPE html>
 2: <html lang="en">
 3:   <head>
 4:     <meta charset="UTF-8" />
 5:     <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
 6:     <meta name="viewport" content="width=device-width, initial-scale=1.0" />
 7:     <title>ContextCraft</title>
 8:     <!-- Preconnect to Google Fonts for better performance -->
 9:     <link rel="preconnect" href="https://fonts.googleapis.com" />
10:     <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
11:     <link
12:       href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
13:       rel="stylesheet"
14:     />
15:   </head>
16:   <body>
17:     <div id="root"></div>
18:     <script type="module" src="/src/main.tsx"></script>
19:   </body>
20: </html>

================
File: jest.config.ts
================
 1: import type { Config } from '@jest/types';
 2: const config: Config.InitialOptions = {
 3:   preset: 'ts-jest',
 4:   testEnvironment: 'jsdom',
 5:   roots: ['<rootDir>/src'],
 6:   moduleNameMapper: {
 7:     '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
 8:     '^@/(.*)$': '<rootDir>/src/$1'
 9:   },
10:   setupFilesAfterEnv: ['<rootDir>/src/__tests__/setup.ts'],
11:   testMatch: [
12:     '**/__tests__/**/*.test.[jt]s?(x)',
13:     '**/?(*.)+(spec|test).[jt]s?(x)'
14:   ],
15:   transform: {
16:     '^.+\\.(ts|tsx)$': 'ts-jest'
17:   },
18:   moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node']
19: };
20: export default config;

================
File: LICENSE
================
 1: MIT License
 2: 
 3: Copyright (c) 2024 kleneway
 4: 
 5: Permission is hereby granted, free of charge, to any person obtaining a copy
 6: of this software and associated documentation files (the "Software"), to deal
 7: in the Software without restriction, including without limitation the rights
 8: to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9: copies of the Software, and to permit persons to whom the Software is
10: furnished to do so, subject to the following conditions:
11: 
12: The above copyright notice and this permission notice shall be included in all
13: copies or substantial portions of the Software.
14: 
15: THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16: IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17: FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18: AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19: LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20: OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21: SOFTWARE.

================
File: main.js
================
   1: const { app, BrowserWindow, ipcMain, dialog, globalShortcut, shell } = require("electron");
   2: const fs = require("fs");
   3: const path = require("path");
   4: const os = require("os");
   5: const url = require("url");
   6: const minimatch = require("minimatch");
   7: const { promisify } = require("util");
   8: const micromatch = require('micromatch');
   9: // Helper function to try resolving modules from multiple locations
  10: const tryLoadModule = (moduleName) => {
  11:   const possiblePaths = [
  12:     // Resources path (where extraResources copies modules)
  13:     path.join(process.resourcesPath, 'node_modules', moduleName),
  14:     // Standard node_modules path
  15:     moduleName,
  16:     // From extraResources (relative to app.getAppPath())
  17:     path.join(app.getAppPath(), 'node_modules', moduleName),
  18:     // From extraResources/asarUnpack (using resourcesPath)
  19:     path.join(process.resourcesPath, 'app.asar.unpacked', 'node_modules', moduleName)
  20:   ];
  21:   for (const modulePath of possiblePaths) {
  22:     try {
  23:       console.log(`Trying to load ${moduleName} from: ${modulePath}`);
  24:       return require(modulePath);
  25:     } catch (err) {
  26:       console.log(`Failed to load from ${modulePath}: ${err.message}`);
  27:     }
  28:   }
  29:   throw new Error(`Could not load ${moduleName} from any location`);
  30: };
  31: // Add chokidar import for file watching
  32: let chokidar;
  33: // In production, use a no-op watcher to avoid the module loading error
  34: if (app.isPackaged) {
  35:   console.log("Using no-op file watcher in production");
  36:   chokidar = {
  37:     watch: () => ({
  38:       on: () => {},
  39:       close: () => {}
  40:     })
  41:   };
  42: } else {
  43:   // Only try to load chokidar in development
  44:   try {
  45:     chokidar = require('chokidar');
  46:     console.log("Successfully loaded chokidar for file watching");
  47:   } catch (err) {
  48:     console.warn("Chokidar not available:", err.message);
  49:     // Create a no-op watcher if chokidar is not available
  50:     chokidar = {
  51:       watch: () => ({
  52:         on: () => {},
  53:         close: () => {}
  54:       })
  55:     };
  56:   }
  57: }
  58: // Safely require DOMPurify and JSDOM with fallbacks for production
  59: let createDOMPurify, JSDOM, DOMPurify;
  60: try {
  61:   createDOMPurify = tryLoadModule('dompurify');
  62:   const jsdom = tryLoadModule('jsdom');
  63:   JSDOM = jsdom.JSDOM;
  64:   // Initialize DOMPurify with JSDOM window
  65:   const window = new JSDOM('').window;
  66:   DOMPurify = createDOMPurify(window);
  67:   console.log("Successfully loaded DOMPurify and JSDOM");
  68: } catch (err) {
  69:   console.warn("DOMPurify or JSDOM not available:", err.message);
  70:   // Create no-op fallback for DOMPurify.sanitize
  71:   DOMPurify = {
  72:     sanitize: (content) => {
  73:       console.warn("DOMPurify sanitize called but not available");
  74:       // Simple fallback - handle HTML escape on your own if needed
  75:       return content;
  76:     }
  77:   };
  78: }
  79: const { execSync } = require('child_process');
  80: const { excludedFiles, binaryExtensions, systemExclusions, defaultUserPatterns } = require("./excluded-files");
  81: // Load ignore module with resilience
  82: let ignore;
  83: try {
  84:   ignore = tryLoadModule("ignore");
  85:   console.log("Successfully loaded ignore module");
  86: } catch (err) {
  87:   console.error("Failed to load ignore module:", err);
  88:   // Simple fallback implementation for when the ignore module fails to load
  89:   ignore = {
  90:     // Simple implementation that just matches exact paths
  91:     createFilter: () => {
  92:       return (path) => !excludedFiles.includes(path);
  93:     },
  94:   };
  95:   console.log("Using fallback for ignore module");
  96: }
  97: // Add require for the new TreeSitter utilities with improved error handling
  98: let mainProcessCompressCode = null;
  99: let mainProcessRemoveComments = null;
 100: // Helper function to try loading a module from multiple possible paths
 101: const tryRequireFromPaths = (modulePath) => {
 102:   const possiblePaths = [
 103:     // For resources path (extraResources)
 104:     path.join(process.resourcesPath, 'node_modules/tree-sitter'),
 105:     // Standard relative path
 106:     modulePath,
 107:     // From app path
 108:     path.join(app.getAppPath(), modulePath),
 109:     // Absolute path for packaged app
 110:     path.join(process.resourcesPath, 'app.asar', modulePath),
 111:     // For unpacked resources
 112:     path.join(process.resourcesPath, 'app.asar.unpacked', modulePath),
 113:   ];
 114:   for (const tryPath of possiblePaths) {
 115:     try {
 116:       return require(tryPath);
 117:     } catch (err) {
 118:       console.log(`Failed to load from ${tryPath}`);
 119:       // Continue to next path
 120:     }
 121:   }
 122:   throw new Error(`Failed to load module from any location: ${modulePath}`);
 123: };
 124: try {
 125:   // Try to load tree-sitter utils from multiple possible locations
 126:   const treeSitterUtils = tryLoadModule('./utils/treeSitterUtils');
 127:   mainProcessCompressCode = treeSitterUtils.mainProcessCompressCode;
 128:   mainProcessRemoveComments = treeSitterUtils.mainProcessRemoveComments;
 129:   console.log("Successfully loaded TreeSitter utilities");
 130: } catch (err) {
 131:   console.error("Failed to load TreeSitter utilities:", err.message);
 132:   // Create no-op fallbacks for the functions
 133:   mainProcessCompressCode = (source) => {
 134:     console.warn("TreeSitter compressCode called but not available");
 135:     return source; // Return original source as fallback
 136:   };
 137:   mainProcessRemoveComments = (source) => {
 138:     console.warn("TreeSitter removeComments called but not available");
 139:     return source; // Return original source as fallback
 140:   };
 141: }
 142: // For backward compatibility - use systemExclusions as the new single source of truth
 143: const DEFAULT_EXCLUSIONS = systemExclusions;
 144: // Global variables for directory loading control
 145: let isLoadingDirectory = false;
 146: let loadingTimeoutId = null;
 147: const MAX_DIRECTORY_LOAD_TIME = 30000; // 30 seconds timeout
 148: // Global variable for file watcher
 149: let fileWatcher = null;
 150: let addDebounce = null;
 151: let changeDebounce = null;
 152: let deleteDebounce = null;
 153: const WATCH_DEBOUNCE_TIME = 300; // 300ms debounce time for file changes
 154: /**
 155:  * Safer fs.watch wrapper that handles errors and works across platforms
 156:  * @param {string} dir Directory to watch
 157:  * @param {Function} callback Callback function(eventType, filename)
 158:  * @returns {object} Watcher object with close method
 159:  */
 160: function safeFsWatch(dir, callback) {
 161:   if (!fs.existsSync(dir)) {
 162:     return { close: () => {} };
 163:   }
 164:   try {
 165:     const watcher = fs.watch(dir, { recursive: false }, (eventType, filename) => {
 166:       if (!filename) return;
 167:       try {
 168:         callback(eventType, filename);
 169:       } catch (err) {
 170:         console.error(`Error in watch callback for ${dir}/${filename}:`, err);
 171:       }
 172:     });
 173:     return watcher;
 174:   } catch (err) {
 175:     console.error(`Error watching directory ${dir}:`, err);
 176:     return { close: () => {} };
 177:   }
 178: }
 179: // Cache for directory contents to avoid repeated processing
 180: const directoryCache = {
 181:   // Format: { path: { timestamp: Date, files: [] } }
 182:   cache: {},
 183:   // Cache expiration time (5 minutes)
 184:   CACHE_EXPIRY: 5 * 60 * 1000,
 185:   // Get files from cache if available and not expired
 186:   get: function(path) {
 187:     const normalizedPath = normalizePath(path);
 188:     const entry = this.cache[normalizedPath];
 189:     if (!entry) return null;
 190:     // Check if cache is expired
 191:     const now = new Date().getTime();
 192:     if (now - entry.timestamp > this.CACHE_EXPIRY) {
 193:       delete this.cache[normalizedPath];
 194:       return null;
 195:     }
 196:     console.log(`Using cached directory content for ${normalizedPath}`);
 197:     return entry.files;
 198:   },
 199:   // Store files in cache
 200:   set: function(path, files) {
 201:     const normalizedPath = normalizePath(path);
 202:     this.cache[normalizedPath] = {
 203:       timestamp: new Date().getTime(),
 204:       files: files
 205:     };
 206:     console.log(`Cached directory content for ${normalizedPath}`);
 207:   },
 208:   // Clear cache for a specific path or all paths
 209:   clear: function(path = null) {
 210:     if (path) {
 211:       const normalizedPath = normalizePath(path);
 212:       delete this.cache[normalizedPath];
 213:       console.log(`Cleared cache for ${normalizedPath}`);
 214:     } else {
 215:       this.clearAll();
 216:     }
 217:   },
 218:   // Clear all cached entries
 219:   clearAll: function() {
 220:     this.cache = {};
 221:     console.log('Cleared all directory caches');
 222:   }
 223: };
 224: /**
 225:  * Normalize file paths to use forward slashes regardless of OS
 226:  * This ensures consistent path formatting between main and renderer processes
 227:  */
 228: function normalizePath(filePath) {
 229:   if (!filePath) return filePath;
 230:   return filePath.replace(/\\/g, '/');
 231: }
 232: /**
 233:  * Get the platform-specific path separator
 234:  */
 235: function getPathSeparator() {
 236:   return os.platform() === 'win32' ? '\\' : '/';
 237: }
 238: // Initialize tokenizer with better error handling
 239: let tiktoken;
 240: try {
 241:   tiktoken = tryLoadModule("tiktoken");
 242:   console.log("Successfully loaded tiktoken module");
 243: } catch (err) {
 244:   console.error("Failed to load tiktoken module:", err);
 245:   tiktoken = null;
 246: }
 247: // Initialize the encoder once at startup with better error handling
 248: let encoder;
 249: try {
 250:   if (tiktoken) {
 251:     encoder = tiktoken.get_encoding("o200k_base"); // gpt-4o encoding
 252:     console.log("Tiktoken encoder initialized successfully");
 253:   } else {
 254:     throw new Error("Tiktoken module not available");
 255:   }
 256: } catch (err) {
 257:   console.error("Failed to initialize tiktoken encoder:", err);
 258:   // Fallback to a simpler method if tiktoken fails
 259:   console.log("Using fallback token counter");
 260:   encoder = null;
 261: }
 262: // Binary file extensions that should be excluded from token counting
 263: const BINARY_EXTENSIONS = [
 264:   // Images
 265:   ".jpg",
 266:   ".jpeg",
 267:   ".png",
 268:   ".gif",
 269:   ".bmp",
 270:   ".tiff",
 271:   ".ico",
 272:   ".webp",
 273:   ".svg",
 274:   // Audio/Video
 275:   ".mp3",
 276:   ".mp4",
 277:   ".wav",
 278:   ".ogg",
 279:   ".avi",
 280:   ".mov",
 281:   ".mkv",
 282:   ".flac",
 283:   // Archives
 284:   ".zip",
 285:   ".rar",
 286:   ".tar",
 287:   ".gz",
 288:   ".7z",
 289:   // Documents
 290:   ".pdf",
 291:   ".doc",
 292:   ".docx",
 293:   ".ppt",
 294:   ".pptx",
 295:   ".xls",
 296:   ".xlsx",
 297:   // Compiled
 298:   ".exe",
 299:   ".dll",
 300:   ".so",
 301:   ".class",
 302:   ".o",
 303:   ".pyc",
 304:   // Database
 305:   ".db",
 306:   ".sqlite",
 307:   ".sqlite3",
 308:   // Others
 309:   ".bin",
 310:   ".dat",
 311: ].concat(binaryExtensions || []); // Add any additional binary extensions from excluded-files.js
 312: // Max file size to read (5MB)
 313: const MAX_FILE_SIZE = 200 * 1024 * 1024;
 314: // Global reference to the mainWindow to prevent garbage collection
 315: let mainWindow;
 316: // Add promisify for fs operations
 317: const readFile = promisify(fs.readFile);
 318: const writeFile = promisify(fs.writeFile);
 319: const unlink = promisify(fs.unlink);
 320: // Create a clear pattern organization system with three distinct categories:
 321: // 1. SYSTEM_EXCLUSIONS: Always excluded, not user-configurable (binary files, media, etc.)
 322: // 2. DEFAULT_USER_PATTERNS: Initial user-editable patterns, restored on reset
 323: // 3. Current user patterns: Stored in global_patterns.ignore or .repo_ignore files
 324: // Category 1: System-level exclusions (not user-editable)
 325: const SYSTEM_EXCLUSIONS = [
 326:   // Version control
 327:   "**/.git/**",
 328:   "**/.svn/**",
 329:   "**/.hg/**",
 330:   // Build artifacts and dependencies
 331:   "**/node_modules/**", 
 332:   "**/dist/**",
 333:   "**/build/**",
 334:   "**/.next/**",
 335:   // Cache files
 336:   "**/.cache/**",
 337:   "**/__pycache__/**",
 338:   // Logs
 339:   "**/logs/**",
 340:   "**/*.log",
 341:   // IDE files
 342:   "**/.idea/**",
 343:   "**/.vscode/**",
 344:   // OS files
 345:   "**/.DS_Store",
 346:   "**/Thumbs.db"
 347: ];
 348: // Category 2: Default user patterns (user-editable, used when resetting to defaults)
 349: const DEFAULT_USER_PATTERNS = ""; // Start with empty patterns
 350: // Add diagnostic function for path resolution
 351: function logPathDiagnostics() {
 352:   console.log('======== PATH DIAGNOSTICS ========');
 353:   console.log('__dirname:', __dirname);
 354:   console.log('process.cwd():', process.cwd());
 355:   console.log('app.getAppPath():', app.getAppPath());
 356:   console.log('app.getPath(userData):', app.getPath('userData'));
 357:   console.log('app.getPath(exe):', app.getPath('exe'));
 358:   console.log('process.resourcesPath:', process.resourcesPath);
 359:   // Check for dist directory
 360:   const possibleDistPaths = [
 361:     path.resolve(__dirname, '../dist'),
 362:     path.join(process.resourcesPath, 'app.asar/dist'),
 363:     path.join(app.getAppPath(), 'dist')
 364:   ];
 365:   console.log('Checking dist directory existence:');
 366:   for (const distPath of possibleDistPaths) {
 367:     try {
 368:       const exists = fs.existsSync(distPath);
 369:       console.log(`- ${distPath}: ${exists ? 'EXISTS' : 'NOT FOUND'}`);
 370:       if (exists) {
 371:         // Check for index.html
 372:         const indexPath = path.join(distPath, 'index.html');
 373:         const indexExists = fs.existsSync(indexPath);
 374:         console.log(`  - index.html: ${indexExists ? 'EXISTS' : 'NOT FOUND'}`);
 375:       }
 376:     } catch (err) {
 377:       console.error(`- ${distPath}: ERROR - ${err.message}`);
 378:     }
 379:   }
 380:   console.log('==================================');
 381: }
 382: function createWindow() {
 383:   mainWindow = new BrowserWindow({
 384:     width: 1000,
 385:     height: 700,
 386:     title: "ContextCraft",
 387:     webPreferences: {
 388:       nodeIntegration: false,      contextIsolation: true,
 389:       preload: path.join(__dirname, "preload.js"),
 390:     },
 391:   });
 392:   console.log('Main window created.');
 393:   // Log diagnostic info during startup
 394:   logPathDiagnostics();
 395:   // Set Content Security Policy
 396:   mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
 397:     callback({
 398:       responseHeaders: {
 399:         ...details.responseHeaders,
 400:         'Content-Security-Policy': [
 401:           "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data:; connect-src 'self' https://openrouter.ai"
 402:         ]
 403:       }
 404:     });
 405:   });
 406:   // Load the app - fix path for production builds
 407:   let startUrl;
 408:   if (process.env.ELECTRON_START_URL) {
 409:     // Development mode
 410:     startUrl = process.env.ELECTRON_START_URL;
 411:   } else {
 412:     // Production mode
 413:     // Check if we're in an asar package
 414:     const isPackaged = app.isPackaged;
 415:     if (isPackaged) {
 416:       // We're in a packaged app
 417:       // For packaged apps, more reliable to use path.resolve with __dirname
 418:       // This ensures proper asar path resolution
 419:       startUrl = url.format({
 420:         pathname: path.resolve(__dirname, '../dist/index.html'),
 421:         protocol: 'file:',
 422:         slashes: true
 423:       });
 424:       console.log(`Packaged app path resolved to: ${path.resolve(__dirname, '../dist/index.html')}`);
 425:       // Fallback path to try if the app fails to load
 426:       const fallbackPath = path.join(process.resourcesPath, 'app.asar/dist/index.html');
 427:       console.log(`Fallback path if needed: ${fallbackPath}`);
 428:     } else {
 429:       // Not packaged, but still in production mode
 430:       startUrl = url.format({
 431:         pathname: path.resolve(__dirname, '../dist/index.html'),
 432:         protocol: 'file:',
 433:         slashes: true
 434:       });
 435:     }
 436:   }
 437:   console.log(`Attempting to load URL: ${startUrl}`);
 438:   mainWindow.loadURL(startUrl);
 439:   // Open external links in browser
 440:   mainWindow.webContents.setWindowOpenHandler(({ url }) => {
 441:     shell.openExternal(url);
 442:     return { action: "deny" };
 443:   });
 444:   // Open dev tools in development
 445:   if (process.env.ELECTRON_START_URL) {
 446:     mainWindow.webContents.openDevTools();
 447:   }
 448:   // Add basic error handling for failed loads
 449:   mainWindow.webContents.on(
 450:     "did-fail-load",
 451:     (event, errorCode, errorDescription, validatedURL, isMainFrame) => {
 452:       // Log only for the main frame failures
 453:       if (isMainFrame) {
 454:         console.error(`FAILED TO LOAD URL: ${validatedURL}`);
 455:         console.error(`Error Code: ${errorCode}`);
 456:         console.error(`Description: ${errorDescription}`);
 457:         // Add more context if available
 458:         console.error(`Is Packaged App: ${app.isPackaged}`);
 459:         console.error(`Resources Path: ${process.resourcesPath}`);
 460:         logPathDiagnostics(); // Re-run diagnostics on failure
 461:         // Retry with an explicit file URL if in production
 462:         if (!process.env.ELECTRON_START_URL) {
 463:           // Try multiple fallback paths in order
 464:           const fallbackPaths = [
 465:             // Path 1: Using process.resourcesPath (most reliable in packaged app)
 466:             path.join(process.resourcesPath, 'app.asar/dist/index.html'),
 467:             // Path 2: Using direct path to Applications folder (specific to macOS)
 468:             app.isPackaged && process.platform === 'darwin' 
 469:               ? '/Applications/ContextCraft.app/Contents/Resources/app.asar/dist/index.html' 
 470:               : null,
 471:             // Path 3: Using app.getAppPath() 
 472:             path.join(app.getAppPath(), 'dist/index.html'),
 473:             // Path 4: Original fallback as last resort
 474:             app.isPackaged 
 475:               ? path.join(process.resourcesPath, 'app.asar/dist/index.html') 
 476:               : path.resolve(__dirname, '../dist/index.html'),
 477:           ].filter(Boolean); // Remove any null entries
 478:           // Try each fallback path
 479:           let fallbackIndex = 0;
 480:           const tryNextFallback = () => {
 481:             if (fallbackIndex >= fallbackPaths.length) {
 482:               console.error('All fallback paths failed to load. Cannot recover.');
 483:               return;
 484:             }
 485:             const currentPath = fallbackPaths[fallbackIndex++];
 486:             console.log(`Trying fallback path ${fallbackIndex}/${fallbackPaths.length}: ${currentPath}`);
 487:             const fallbackUrl = url.format({
 488:               pathname: currentPath,
 489:               protocol: 'file:',
 490:               slashes: true
 491:             });
 492:             // Set up one-time handler for next failure
 493:             if (fallbackIndex < fallbackPaths.length) {
 494:               mainWindow.webContents.once('did-fail-load', () => {
 495:                 tryNextFallback();
 496:               });
 497:             }
 498:             mainWindow.loadURL(fallbackUrl);
 499:           };
 500:           tryNextFallback();
 501:         }
 502:       } else {
 503:         console.warn(`Failed to load non-main frame: ${validatedURL} (${errorCode})`);
 504:       }
 505:     },
 506:   );
 507:   // Handle window ready-to-show event
 508:   mainWindow.once('ready-to-show', () => {
 509:     mainWindow.show();
 510:   });
 511:   // Handle window closed event
 512:   mainWindow.on('closed', () => {
 513:     mainWindow = null;
 514:   });
 515: }
 516: app.whenReady().then(() => {
 517:   console.log('App ready. Verifying critical modules...');
 518:   try {
 519:     // Try to load critical modules using our resilient method
 520:     tryLoadModule('tree-sitter');
 521:     tryLoadModule('chokidar');
 522:     console.log('Critical native modules loaded successfully.');
 523:     createWindow();
 524:   } catch (moduleError) {
 525:     console.error('FATAL: Failed to load critical module:', moduleError);
 526:     // Show error dialog but continue anyway - don't exit
 527:     // This allows the app to at least try to start even if a module is missing
 528:     dialog.showErrorBox('Module Loading Warning', 
 529:       `Some required modules could not be loaded. Some features may not work correctly.\nError: ${moduleError.message}`);
 530:     // Continue with app startup despite the error
 531:     createWindow();
 532:   }
 533:   app.on("activate", () => {
 534:     if (BrowserWindow.getAllWindows().length === 0) createWindow();
 535:   });
 536: });
 537: app.on("window-all-closed", () => {
 538:   if (process.platform !== "darwin") {
 539:     app.quit();
 540:   }
 541: });
 542: // Clean up shortcuts on app quit
 543: app.on('will-quit', () => {
 544:   globalShortcut.unregisterAll();
 545: });
 546: // Helper function to check if window is valid and can receive messages
 547: function isWindowValid(window) {
 548:   try {
 549:     return window && !window.isDestroyed() && window.webContents;
 550:   } catch (error) {
 551:     console.error('Error checking window validity:', error);
 552:     return false;
 553:   }
 554: }
 555: // Function to safely send to renderer
 556: function safeRendererSend(window, channel, ...args) {
 557:   try {
 558:     if (!isWindowValid(window)) {
 559:       console.warn(`Cannot send to renderer (${channel}): window is not valid`);
 560:       return false;
 561:     }
 562:     window.webContents.send(channel, ...args);
 563:     return true;
 564:   } catch (error) {
 565:     console.error(`Error sending to renderer (${channel}):`, error);
 566:     return false;
 567:   }
 568: }
 569: // Function to get all patterns (system + user)
 570: function getAllPatterns(userPatterns) {
 571:   // Combine system exclusions with user patterns
 572:   // System exclusions always apply and come first
 573:   return [...SYSTEM_EXCLUSIONS, ...(userPatterns || [])];
 574: }
 575: // Parse patterns to extract disabled system patterns
 576: const parsePatterns = (content) => {
 577:   const lines = content.split('\n');
 578:   const excludedPatterns = [];
 579:   const userPatterns = [];
 580:   lines.forEach(line => {
 581:     const trimmed = line.trim();
 582:     if (trimmed.startsWith('# DISABLED:')) {
 583:       excludedPatterns.push(trimmed.substring('# DISABLED:'.length).trim());
 584:     } else if (trimmed !== '' && !trimmed.startsWith('#')) {
 585:       userPatterns.push(line);
 586:     }
 587:   });
 588:   return {
 589:     excludedPatterns,
 590:     userPatterns: userPatterns.join('\n')
 591:   };
 592: };
 593: // Update IPC handlers with improved error handling
 594: ipcMain.handle("open-folder", async () => {
 595:   try {
 596:     const result = await dialog.showOpenDialog({ properties: ["openDirectory"] });
 597:     if (!result.canceled && result.filePaths.length > 0) {
 598:       return result.filePaths[0];
 599:     }
 600:     return null; // Return null if canceled or no path selected
 601:   } catch (error) {
 602:     console.error("Error opening folder dialog:", error);
 603:     return null; // Return null or throw error as appropriate
 604:   }
 605: });
 606: ipcMain.handle("read-file", async (event, filePath) => {
 607:   try {
 608:     if (!filePath || typeof filePath !== 'string') {
 609:       throw new Error("Invalid file path provided.");
 610:     }
 611:     // Security check: Ensure filePath is within a reasonable scope if necessary
 612:     // e.g., check if it's within the selected project directory
 613:     // (Need access to the root directory state for this check)
 614:     // Add file size limit check
 615:     const stats = await fs.promises.stat(filePath);
 616:     if (stats.size > MAX_FILE_SIZE) {
 617:        console.warn(`Skipping large file (>${MAX_FILE_SIZE / 1024 / 1024}MB): ${filePath}`);
 618:       return null; // Or return an indicator that the file is too large
 619:     }
 620:     const content = await readFile(filePath, "utf-8");
 621:     return content;
 622:   } catch (error) {
 623:     console.error(`Error reading file ${filePath}:`, error);
 624:     // Send error back to renderer or return null
 625:     return null; // Or throw an error that the renderer can catch
 626:   }
 627: });
 628: // Add handler for the get-file-content IPC channel
 629: ipcMain.handle("get-file-content", async (event, filePath) => {
 630:   try {
 631:     if (!filePath || typeof filePath !== 'string') {
 632:       throw new Error("Invalid file path provided for get-file-content.");
 633:     }
 634:     console.log(`Getting content for file: ${filePath}`);
 635:     // Check if file exists
 636:     if (!fs.existsSync(filePath)) {
 637:       console.error(`File does not exist: ${filePath}`);
 638:       return { 
 639:         success: false, 
 640:         error: `File does not exist: ${filePath}` 
 641:       };
 642:     }
 643:     // Get file stats
 644:     const stats = await fs.promises.stat(filePath);
 645:     // Check if file is too large
 646:     if (stats.size > MAX_FILE_SIZE) {
 647:       console.warn(`Skipping large file (>${MAX_FILE_SIZE / 1024 / 1024}MB): ${filePath}`);
 648:       return { 
 649:         success: false, 
 650:         error: `File is too large (>${MAX_FILE_SIZE / 1024 / 1024}MB)`, 
 651:         size: stats.size 
 652:       };
 653:     }
 654:     // Read file content
 655:     try {
 656:       const content = await readFile(filePath, "utf-8");
 657:       const lastModified = stats.mtime.getTime();
 658:       return {
 659:         success: true,
 660:         content,
 661:         size: stats.size,
 662:         lastModified
 663:       };
 664:     } catch (e) {
 665:       // Try to identify encoding-related errors
 666:       if (e.message && e.message.includes('invalid or unsupported encoding')) {
 667:         console.error(`Encoding error reading file ${filePath}:`, e);
 668:         return { 
 669:           success: false, 
 670:           error: `File encoding not supported (not UTF-8): ${e.message}` 
 671:         };
 672:       }
 673:       // Other read errors
 674:       console.error(`Error reading file ${filePath}:`, e);
 675:       return { 
 676:         success: false, 
 677:         error: e.message || "Unknown error reading file" 
 678:       };
 679:     }
 680:   } catch (error) {
 681:     console.error(`Error in get-file-content for ${filePath}:`, error);
 682:     return { 
 683:       success: false, 
 684:       error: error.message || "Unknown error reading file" 
 685:     };
 686:   }
 687: });
 688: ipcMain.on("request-file-list", (event, folderPath) => {
 689:   try {
 690:     if (!isWindowValid(mainWindow)) {
 691:       console.warn("Window is not valid for request-file-list");
 692:       return;
 693:     }
 694:     console.log("Received request-file-list event for:", folderPath);
 695:     // Call the handleRequestFileList directly with the event object
 696:     handleRequestFileList(event, folderPath);
 697:   } catch (error) {
 698:     console.error("Error in request-file-list handler:", error);
 699:     if (isWindowValid(mainWindow)) {
 700:       mainWindow.webContents.send("file-processing-status", {
 701:         status: "error",
 702:         message: `Error loading directory: ${error.message}`,
 703:       });
 704:     }
 705:   }
 706: });
 707: // Keep the handle method for backward compatibility but log a warning
 708: ipcMain.handle("request-file-list", async (event, data) => {
 709:   console.warn("Using deprecated ipcMain.handle for request-file-list. This should use the 'on' method instead.");
 710:   // The handler should just acknowledge but actual processing happens through events
 711:   return { acknowledged: true };
 712: });
 713: ipcMain.handle('compress-code', async (event, { source, language }) => {
 714:   try {
 715:     if (!source || !language) {
 716:       throw new Error("Source code and language are required for compression.");
 717:     }
 718:     // Input validation/sanitization if necessary
 719:     const compressed = await mainProcessCompressCode(String(source), String(language));
 720:     return compressed;
 721:   } catch (error) {
 722:     console.error("Error in compress-code IPC handler:", error);
 723:     return null; // Return null on error
 724:   }
 725: });
 726: ipcMain.handle('remove-comments', async (event, { source, language, keepDocstrings }) => {
 727:   try {
 728:     if (!source || !language) {
 729:       throw new Error("Source code and language are required for comment removal.");
 730:     }
 731:     // Input validation/sanitization if necessary
 732:     const uncommented = await mainProcessRemoveComments(String(source), String(language), Boolean(keepDocstrings));
 733:     return uncommented;
 734:   } catch (error) {
 735:     console.error("Error in remove-comments IPC handler:", error);
 736:     return null; // Return null on error
 737:   }
 738: });
 739: ipcMain.on("reload-file-list", (event, folderPath) => {
 740:   try {
 741:     if (!isWindowValid(mainWindow)) {
 742:       console.warn("Window is not valid for reload-file-list");
 743:       return;
 744:     }
 745:     if (!folderPath) return;
 746:     console.log(`Forcing reload of file list for ${folderPath}`);
 747:     directoryCache.clear(folderPath);
 748:     mainWindow.webContents.send("file-processing-status", {
 749:       status: "processing",
 750:       message: "Reloading directory...",
 751:     });
 752:     // Process the request directly using the same handler for request-file-list
 753:     try {
 754:       // Create data object with force refresh flag
 755:       const data = {
 756:         path: folderPath,
 757:         forceRefresh: true
 758:       };
 759:       // Handle the request-file-list directly
 760:       handleRequestFileList(event, data);
 761:     } catch (err) {
 762:       console.error("Error reloading file list:", err);
 763:       if (isWindowValid(mainWindow)) {
 764:         mainWindow.webContents.send("file-processing-status", {
 765:           status: "error",
 766:           message: `Error reloading directory: ${err.message}`,
 767:         });
 768:       }
 769:     }
 770:   } catch (error) {
 771:     console.error("Error in reload-file-list handler:", error);
 772:   }
 773: });
 774: // Function to cancel loading directory with improved error handling
 775: function cancelDirectoryLoading(window) {
 776:   try {
 777:     if (!isWindowValid(window)) {
 778:       console.warn("Window is not valid for cancelDirectoryLoading");
 779:       return;
 780:     }
 781:     isLoadingDirectory = false;
 782:     if (loadingTimeoutId) {
 783:       clearTimeout(loadingTimeoutId);
 784:       loadingTimeoutId = null;
 785:     }
 786:     safeRendererSend(window, "file-processing-status", {
 787:       status: "error",
 788:       message: "Directory loading cancelled - try selecting a smaller directory",
 789:     });
 790:   } catch (error) {
 791:     console.error("Error in cancelDirectoryLoading:", error);
 792:     // Try to reset state even if sending to renderer failed
 793:     isLoadingDirectory = false;
 794:     loadingTimeoutId = null;
 795:   }
 796: }
 797: // Handler for directory loading timeout with improved error handling
 798: function setupDirectoryLoadingTimeout(window, folderPath) {
 799:   try {
 800:     if (!isWindowValid(window)) {
 801:       console.warn("Window is not valid for setupDirectoryLoadingTimeout");
 802:       return;
 803:     }
 804:     // Clear any existing timeout
 805:     if (loadingTimeoutId) {
 806:       clearTimeout(loadingTimeoutId);
 807:     }
 808:     // Set a new timeout
 809:     loadingTimeoutId = setTimeout(() => {
 810:       try {
 811:         console.log(`Directory loading timed out after ${MAX_DIRECTORY_LOAD_TIME / 1000} seconds: ${folderPath}`);
 812:         if (isWindowValid(window)) {
 813:           cancelDirectoryLoading(window);
 814:         } else {
 815:           // Just clean up the loading state without window reference
 816:           isLoadingDirectory = false;
 817:           loadingTimeoutId = null;
 818:           console.log("Directory loading timed out but window is no longer available");
 819:         }
 820:       } catch (error) {
 821:         console.error("Error in directory loading timeout handler:", error);
 822:         // Ensure we clean up state even if there's an error
 823:         isLoadingDirectory = false;
 824:         loadingTimeoutId = null;
 825:       }
 826:     }, MAX_DIRECTORY_LOAD_TIME);
 827:   } catch (error) {
 828:     console.error("Error setting up directory loading timeout:", error);
 829:     // Clean up state on error
 830:     isLoadingDirectory = false;
 831:     if (loadingTimeoutId) {
 832:       clearTimeout(loadingTimeoutId);
 833:       loadingTimeoutId = null;
 834:     }
 835:   }
 836: }
 837: ipcMain.on("cancel-directory-loading", (event) => {
 838:   try {
 839:     if (!isWindowValid(mainWindow)) {
 840:       console.warn("Window is not valid for cancel-directory-loading");
 841:       return;
 842:     }
 843:     if (isLoadingDirectory) {
 844:       console.log("Received cancel directory loading request");
 845:       cancelDirectoryLoading(mainWindow);
 846:     }
 847:   } catch (error) {
 848:     console.error("Error in cancel-directory-loading handler:", error);
 849:   }
 850: });
 851: // Update async handlers with improved error handling and window checks
 852: ipcMain.handle('load-ignore-patterns', async (event, { folderPath, isGlobal }) => {
 853:   try {
 854:     if (!isWindowValid(mainWindow)) {
 855:       console.warn("Window not initialized yet or destroyed");
 856:       return { 
 857:         success: true, 
 858:         patterns: isGlobal ? DEFAULT_USER_PATTERNS : '',
 859:         systemPatterns: SYSTEM_EXCLUSIONS,
 860:         excludedPatterns: []
 861:       };
 862:     }
 863:     if (isGlobal) {
 864:       try {
 865:         const appDataPath = app.getPath('userData');
 866:         const globalIgnorePath = path.join(appDataPath, 'global_patterns.ignore');
 867:         if (fs.existsSync(globalIgnorePath)) {
 868:           const content = await readFile(globalIgnorePath, 'utf8');
 869:           const { excludedPatterns, userPatterns } = parsePatterns(content);
 870:           console.log(`Loaded global ignore patterns from ${globalIgnorePath}`);
 871:           return { 
 872:             success: true, 
 873:             patterns: userPatterns,
 874:             systemPatterns: SYSTEM_EXCLUSIONS,
 875:             excludedPatterns
 876:           };
 877:         } else {
 878:           console.log('No global ignore patterns file found, creating with defaults');
 879:           try {
 880:             if (!fs.existsSync(appDataPath)) {
 881:               fs.mkdirSync(appDataPath, { recursive: true });
 882:             }
 883:             await writeFile(globalIgnorePath, DEFAULT_USER_PATTERNS, 'utf8');
 884:             console.log(`Created default global ignore patterns at ${globalIgnorePath}`);
 885:           } catch (error) {
 886:             console.error('Error creating default global patterns:', error);
 887:           }
 888:           return { 
 889:             success: true, 
 890:             patterns: DEFAULT_USER_PATTERNS,
 891:             systemPatterns: SYSTEM_EXCLUSIONS,
 892:             excludedPatterns: []
 893:           };
 894:         }
 895:       } catch (error) {
 896:         console.error('Error handling global patterns:', error);
 897:         return { 
 898:           success: true, 
 899:           patterns: DEFAULT_USER_PATTERNS,
 900:           systemPatterns: SYSTEM_EXCLUSIONS,
 901:           excludedPatterns: []
 902:         };
 903:       }
 904:     } else {
 905:       try {
 906:         if (!folderPath) {
 907:           return { 
 908:             success: true, 
 909:             patterns: '',
 910:             systemPatterns: SYSTEM_EXCLUSIONS,
 911:             excludedPatterns: []
 912:           };
 913:         }
 914:         const ignoreFilePath = path.join(folderPath, '.repo_ignore');
 915:         if (fs.existsSync(ignoreFilePath)) {
 916:           const content = await readFile(ignoreFilePath, 'utf8');
 917:           const { excludedPatterns, userPatterns } = parsePatterns(content);
 918:           console.log(`Loaded local ignore patterns from ${ignoreFilePath}`);
 919:           return { 
 920:             success: true, 
 921:             patterns: userPatterns,
 922:             systemPatterns: SYSTEM_EXCLUSIONS,
 923:             excludedPatterns
 924:           };
 925:         } else {
 926:           console.log(`No local ignore patterns file found at ${ignoreFilePath}`);
 927:           return { 
 928:             success: true, 
 929:             patterns: '',
 930:             systemPatterns: SYSTEM_EXCLUSIONS,
 931:             excludedPatterns: []
 932:           };
 933:         }
 934:       } catch (error) {
 935:         console.error('Error handling local patterns:', error);
 936:         return { 
 937:           success: true, 
 938:           patterns: '',
 939:           systemPatterns: SYSTEM_EXCLUSIONS,
 940:           excludedPatterns: []
 941:         };
 942:       }
 943:     }
 944:   } catch (error) {
 945:     console.error('Error in load-ignore-patterns handler:', error);
 946:     return { 
 947:       success: true, 
 948:       patterns: isGlobal ? DEFAULT_USER_PATTERNS : '',
 949:       systemPatterns: SYSTEM_EXCLUSIONS,
 950:       excludedPatterns: []
 951:     };
 952:   }
 953: });
 954: // Function to parse .gitignore file if it exists
 955: function loadGitignore(rootDir) {
 956:   const ig = ignore();
 957:   const gitignorePath = path.join(rootDir, ".gitignore");
 958:   if (fs.existsSync(gitignorePath)) {
 959:     const gitignoreContent = fs.readFileSync(gitignorePath, "utf8");
 960:     ig.add(gitignoreContent);
 961:   }
 962:   // Add some default ignores that are common
 963:   ig.add([".git", "node_modules", ".DS_Store"]);
 964:   // Add the excludedFiles patterns for gitignore-based exclusion
 965:   ig.add(excludedFiles);
 966:   return ig;
 967: }
 968: // Check if file is binary based on extension
 969: function isBinaryFile(filePath) {
 970:   const ext = path.extname(filePath).toLowerCase();
 971:   return BINARY_EXTENSIONS.includes(ext);
 972: }
 973: // Count tokens using tiktoken with o200k_base encoding
 974: function countTokens(text) {
 975:   if (!text) return 0;
 976:   // Very large files (over 100K) - use approximate counting only
 977:   if (text.length > 100000) {
 978:     console.log(`Using approximate token count for large file (${text.length} chars)`);
 979:     // Rough approximation: ~4 characters per token on average
 980:     return Math.ceil(text.length / 4);
 981:   }
 982:   // Normal files - use tiktoken if available
 983:   if (encoder) {
 984:     try {
 985:       const tokens = encoder.encode(text);
 986:       return tokens.length;
 987:     } catch (err) {
 988:       console.error("Error counting tokens:", err);
 989:       // Fallback to character-based estimation on error
 990:       return Math.ceil(text.length / 4);
 991:     }
 992:   } else {
 993:     // Fallback for when tiktoken is not available
 994:     return Math.ceil(text.length / 4);
 995:   }
 996: }
 997: // Function to recursively read files from a directory
 998: function readFilesRecursively(dir, rootDir, ignoreFilter) {
 999:   rootDir = rootDir || dir;
1000:   ignoreFilter = ignoreFilter || loadGitignore(rootDir);
1001:   // Normalize paths for consistent comparisons
1002:   dir = normalizePath(dir);
1003:   rootDir = normalizePath(rootDir);
1004:   console.log(`Reading directory: ${dir}`);
1005:   let results = [];
1006:   // Skip directories that are obviously going to be very large or problematic
1007:   const dirName = path.basename(dir);
1008:   const skipDirectories = [
1009:     'node_modules', '.git', 'dist', 'build', 'target',
1010:     'bin', 'obj', 'venv', 'env', '.venv', '.env',
1011:     '.next', '.idea', '.gradle', '.cache', 'coverage'
1012:   ];
1013:   if (skipDirectories.includes(dirName)) {
1014:     console.log(`Skipping known large directory: ${dir}`);
1015:     return results;
1016:   }
1017:   // Get actual app paths for comparison
1018:   const appDirectoryPath = normalizePath(app.getAppPath());
1019:   const resourcesPath = path.dirname(appDirectoryPath);
1020:   // Skip ONLY if it's the exact running app directory or its Resources parent
1021:   const isRunningAppDirectory = 
1022:       dir === appDirectoryPath || 
1023:       dir === resourcesPath || 
1024:       dir === normalizePath(path.resolve(__dirname));
1025:   if (isRunningAppDirectory) {
1026:     console.log(`Skipping running application directory: ${dir}`);
1027:     return [{
1028:       name: "_APP_DIRECTORY_",
1029:       path: dir,
1030:       relativePath: "", // Add empty relativePath for app directory
1031:       content: "Please select a project directory instead of the ContextCraft application directory.",
1032:       tokenCount: 0,
1033:       size: 0,
1034:       isBinary: false,
1035:       isSkipped: true,
1036:       error: "This is the running ContextCraft application directory. Please select a different project directory.",
1037:       isAppDirectory: true
1038:     }];
1039:   }
1040:   try {
1041:     // Try to read the directory
1042:     let dirents;
1043:     try {
1044:       dirents = fs.readdirSync(dir, { withFileTypes: true });
1045:     } catch (err) {
1046:       console.error(`Error reading directory ${dir}:`, err);
1047:       return results;
1048:     }
1049:     // Quick check if there are too many files in this directory (likely not useful)
1050:     if (dirents.length > 10000) {
1051:       console.log(`Skipping directory with too many files (${dirents.length}): ${dir}`);
1052:       return results;
1053:     }
1054:     // Process directories first, then files
1055:     const directories = [];
1056:     const files = [];
1057:     // First pass: quick filtering
1058:     for (const dirent of dirents) {
1059:       const name = dirent.name;
1060:       // Skip hidden files and directories (starting with .)
1061:       if (name.startsWith('.') && name !== '.gitignore') {
1062:         continue;
1063:       }
1064:       const fullPath = path.join(dir, name);
1065:       const normalizedPath = normalizePath(fullPath);
1066:       const relativePath = path.relative(rootDir, normalizedPath);
1067:       // Skip if the path is ignored
1068:       if (ignoreFilter.ignores(relativePath)) {
1069:         continue;
1070:       }
1071:       if (dirent.isDirectory()) {
1072:         // Skip .app directories (macOS application bundles)
1073:         if (name.endsWith('.app')) {
1074:           continue;
1075:         }
1076:         // Skip the application's own directory if we're somehow inside it
1077:         const appDirectoryPath = normalizePath(app.getAppPath());
1078:         const resourcesPath = path.dirname(appDirectoryPath);
1079:         // Compare with exact app path instead of just checking if it starts with app path
1080:         if (normalizedPath === appDirectoryPath || normalizedPath === resourcesPath) {
1081:           console.log(`Skipping running app directory: ${normalizedPath}`);
1082:           continue;
1083:         }
1084:         directories.push(dirent);
1085:       } else if (dirent.isFile()) {
1086:         // Skip file if it's a binary file or too large (quick check by extension)
1087:         const ext = path.extname(name).toLowerCase();
1088:         if (BINARY_EXTENSIONS.includes(ext)) {
1089:           // Add it to results but mark as binary
1090:           results.push({
1091:             name: name,
1092:             path: normalizedPath,
1093:             relativePath: normalizePath(path.relative(rootDir, normalizedPath)), // Add relative path property
1094:             tokenCount: 0,
1095:             size: 0,
1096:             content: "",
1097:             isBinary: true,
1098:             isSkipped: false,
1099:             fileType: ext.substring(1).toUpperCase(),
1100:           });
1101:         } else {
1102:           files.push(dirent);
1103:         }
1104:       }
1105:     }
1106:     // Process directories recursively but limit depth and count
1107:     let dirCount = 0;
1108:     for (const dirent of directories) {
1109:       if (dirCount++ > 100) {
1110:         console.log(`Limiting directory processing to 100 subdirectories in ${dir}`);
1111:         break;
1112:       }
1113:       const fullPath = path.join(dir, dirent.name);
1114:       const normalizedPath = normalizePath(fullPath);
1115:       // Recursively read subdirectory
1116:       const subResults = readFilesRecursively(normalizedPath, rootDir, ignoreFilter);
1117:       results = results.concat(subResults);
1118:     }
1119:     // Process files but limit to a reasonable number
1120:     let fileCount = 0;
1121:     for (const dirent of files) {
1122:       if (fileCount++ > 1000) {
1123:         console.log(`Limiting file processing to 1000 files in ${dir}`);
1124:         break;
1125:       }
1126:       const fullPath = path.join(dir, dirent.name);
1127:       const normalizedPath = normalizePath(fullPath);
1128:       try {
1129:         // Get file stats for size
1130:         const stats = fs.statSync(normalizedPath);
1131:         const fileSize = stats.size;
1132:         // Skip files that are too large
1133:         if (fileSize > MAX_FILE_SIZE) {
1134:           results.push({
1135:             name: dirent.name,
1136:             path: normalizedPath,
1137:             relativePath: normalizePath(path.relative(rootDir, normalizedPath)), // Add relative path property
1138:             tokenCount: 0,
1139:             size: fileSize,
1140:             content: "",
1141:             isBinary: true,
1142:             isSkipped: true,
1143:             error: "File too large to process",
1144:           });
1145:           continue;
1146:         }
1147:         // Check if the file is binary
1148:         const isBinary = isBinaryFile(normalizedPath);
1149:         // *** Add Enhanced Logging Here ***
1150:         const relativePathForLog = normalizePath(path.relative(rootDir, normalizedPath));
1151:         if (!relativePathForLog) { // Log specifically when relativePath is missing/empty
1152:             console.error(`[CRITICAL main.js] Missing relativePath! rootDir='${rootDir}', normalizedPath='${normalizedPath}', calculatedRelative='${path.relative(rootDir, normalizedPath)}'`);
1153:         } else if (debugCounter < MAX_DEBUG_FILES) { // Limit successful logs
1154:             console.log(`[Debug main.js] Adding file: Name=${dirent.name}, Path=${normalizedPath}, RelativePath=${relativePathForLog}`);
1155:             debugCounter++;
1156:         }
1157:         // *** End Enhanced Logging ***
1158:         if (isBinary) {
1159:           // Skip token counting for binary files
1160:           results.push({
1161:             name: dirent.name,
1162:             path: normalizedPath,
1163:             relativePath: normalizePath(path.relative(rootDir, normalizedPath)), // Add relative path property
1164:             tokenCount: 0,
1165:             size: fileSize,
1166:             content: "",
1167:             isBinary: true,
1168:             isSkipped: false,
1169:             fileType: path.extname(normalizedPath).substring(1).toUpperCase(),
1170:           });
1171:         } else {
1172:           // Read file content
1173:           const fileContent = fs.readFileSync(normalizedPath, "utf8");
1174:           // Calculate token count (this is the initial, uncompressed count)
1175:           const initialTokenCount = countTokens(fileContent);
1176:           // Add file info with content and token count
1177:           results.push({
1178:             name: dirent.name,
1179:             path: normalizedPath,
1180:             relativePath: normalizePath(path.relative(rootDir, normalizedPath)), // Add relative path property
1181:             content: fileContent, // Note: Consider not sending full content initially if memory is a concern
1182:             tokenCount: initialTokenCount, // Initialize current count with uncompressed count
1183:             uncompressedTokenCount: initialTokenCount, // Store the original count
1184:             isCompressed: false, // Initially not compressed
1185:             size: fileSize,
1186:             isBinary: false,
1187:             isSkipped: false,
1188:           });
1189:         }
1190:       } catch (err) {
1191:         console.error(`Error reading file ${normalizedPath}:`, err);
1192:         // *** Add Enhanced Logging Here Too for Errors ***
1193:         const relativePathForErrLog = normalizePath(path.relative(rootDir, normalizedPath));
1194:         if (!relativePathForErrLog) {
1195:             console.error(`[CRITICAL main.js ERROR CASE] Missing relativePath! rootDir='${rootDir}', normalizedPath='${normalizedPath}', calculatedRelative='${path.relative(rootDir, normalizedPath)}'`);
1196:         }
1197:         // *** End Enhanced Logging ***
1198:         results.push({
1199:           name: dirent.name,
1200:           path: normalizedPath,
1201:           relativePath: normalizePath(path.relative(rootDir, normalizedPath)), // Add relative path property
1202:           tokenCount: 0,
1203:           size: 0,
1204:           isBinary: false,
1205:           isSkipped: true,
1206:           error: "Could not read file",
1207:         });
1208:       }
1209:     }
1210:   } catch (err) {
1211:     console.error(`Error processing directory ${dir}:`, err);
1212:   }
1213:   return results;
1214: }
1215: // Extract file list processing into a reusable function
1216: function handleRequestFileList(event, data) {
1217:   try {
1218:     // Allow either simple string or object with options
1219:     const folderPath = typeof data === 'string' ? data : data.path;
1220:     if (!folderPath) {
1221:       console.log("No folder path provided");
1222:       event.sender.send("file-processing-status", {
1223:         status: "error",
1224:         message: "No folder selected. Please select a project directory.",
1225:       });
1226:       return;
1227:     }
1228:     const forceRefresh = typeof data === 'object' && data.forceRefresh === true;
1229:     console.log("Processing file list for folder:", folderPath);
1230:     console.log("OS platform:", os.platform());
1231:     console.log("Path separator:", getPathSeparator());
1232:     // Get actual app paths for comparison
1233:     const normalizedFolderPath = normalizePath(folderPath);
1234:     const appDirectoryPath = normalizePath(app.getAppPath());
1235:     const resourcesPath = path.dirname(appDirectoryPath);
1236:     // Check ONLY if it's the exact running app directory or its Resources parent
1237:     const isRunningAppDirectory = 
1238:         normalizedFolderPath === appDirectoryPath || 
1239:         normalizedFolderPath === resourcesPath || 
1240:         normalizedFolderPath === normalizePath(path.resolve(__dirname));
1241:     if (isRunningAppDirectory) {
1242:       console.log(`Preventing recursive scan of running app instance at: ${appDirectoryPath}`);
1243:       console.log(`Selected path: ${normalizedFolderPath}`);
1244:       event.sender.send("file-list-data", [{
1245:         name: "_APP_DIRECTORY_",
1246:         path: normalizedFolderPath,
1247:         relativePath: "", // Add empty relativePath for app directory
1248:         content: "Please select a project directory instead of the ContextCraft application directory.",
1249:         tokenCount: 0,
1250:         size: 0,
1251:         isBinary: false,
1252:         isSkipped: true,
1253:         error: "This is the running ContextCraft application directory. Please select a different project directory.",
1254:         isAppDirectory: true
1255:       }]);
1256:       event.sender.send("file-processing-status", {
1257:         status: "error",
1258:         message: "Please select a project directory instead of the ContextCraft application.",
1259:       });
1260:       return;
1261:     }
1262:     // Check cache first (unless forced refresh)
1263:     if (!forceRefresh) {
1264:       const cachedFiles = directoryCache.get(folderPath);
1265:       if (cachedFiles) {
1266:         console.log(`Using ${cachedFiles.length} cached files for ${folderPath}`);
1267:         // Check cached files for reload functionality too
1268:         if (data.forceRefresh) {
1269:           // If forceRefresh is specified, ensure excluded property is set correctly
1270:           cachedFiles = cachedFiles.map(file => {
1271:             const normalizedPath = normalizePath(file.path);
1272:             const isExcluded = shouldExcludeByDefault(normalizedPath, folderPath);
1273:             return {
1274:               ...file,
1275:               excludedByDefault: isExcluded,
1276:               excluded: isExcluded
1277:             };
1278:           });
1279:         }
1280:         event.sender.send("file-list-data", cachedFiles);
1281:         // Set up file watcher even when using cached files
1282:         setupFileWatcher(folderPath, mainWindow);
1283:         return;
1284:       }
1285:     } else {
1286:       console.log("Force refreshing directory:", folderPath);
1287:       directoryCache.clear(folderPath);
1288:     }
1289:     // Set loading flag
1290:     isLoadingDirectory = true;
1291:     // Set timeout to abort if it takes too long
1292:     if (loadingTimeoutId) {
1293:       clearTimeout(loadingTimeoutId);
1294:     }
1295:     loadingTimeoutId = setTimeout(() => {
1296:       if (isLoadingDirectory) {
1297:         console.log("Loading directory timed out");
1298:         cancelDirectoryLoading(mainWindow);
1299:       }
1300:     }, 120000); // 2 minutes timeout
1301:     // Rest of your original file processing logic
1302:     // ...
1303:     // Start processing files logic goes here (unchanged from the original function)
1304:     const processFiles = () => {
1305:       console.log("Starting file scan in:", folderPath);
1306:       console.log("OS normalized path:", normalizePath(folderPath));
1307:       // Force clear the directory cache for this path to ensure fresh scan
1308:       directoryCache.clear(folderPath);
1309:       // First, get all files in the directory
1310:       const files = readFilesRecursively(folderPath, folderPath);
1311:       console.log(`Found ${files.length} files in ${folderPath}`);
1312:       // Debug log of first few files
1313:       if (files.length > 0) {
1314:         console.log("First few files found:");
1315:         files.slice(0, Math.min(5, files.length)).forEach(f => {
1316:           console.log(`- ${f.name} (${f.path})`);
1317:         });
1318:       } else {
1319:         console.log("WARNING: No files found in directory!");
1320:       }
1321:       // Optimize chunk size based on file count
1322:       const CHUNK_SIZE = files.length < 100 ? 50 : 20; // Larger chunks for small directories
1323:       let currentIndex = 0;
1324:       const processedFiles = [];
1325:       const processNextChunk = () => {
1326:         // Calculate the end index for this chunk
1327:         const endIndex = Math.min(currentIndex + CHUNK_SIZE, files.length);
1328:         // Get the chunk of files to process
1329:         const currentChunk = files.slice(currentIndex, endIndex);
1330:         // Process each file in the chunk
1331:         currentChunk.forEach(file => {
1332:           // Normalize the path to use forward slashes consistently
1333:           const normalizedPath = normalizePath(file.path);
1334:           // Check if file should be excluded by patterns
1335:           const isExcluded = shouldExcludeByDefault(normalizedPath, folderPath);
1336:           // Create a clean file object
1337:           processedFiles.push({
1338:             name: file.name ? String(file.name) : "",
1339:             path: normalizedPath, // Use normalized path
1340:             tokenCount: typeof file.tokenCount === "number" ? file.tokenCount : 0,
1341:             uncompressedTokenCount: typeof file.uncompressedTokenCount === "number" ? file.uncompressedTokenCount : 0,
1342:             isCompressed: typeof file.isCompressed === "boolean" ? file.isCompressed : false,
1343:             size: typeof file.size === "number" ? file.size : 0,
1344:             content: file.isBinary
1345:               ? ""
1346:               : typeof file.content === "string"
1347:               ? file.content
1348:               : "",
1349:             isBinary: Boolean(file.isBinary),
1350:             isSkipped: Boolean(file.isSkipped),
1351:             error: file.error ? String(file.error) : null,
1352:             fileType: file.fileType ? String(file.fileType) : null,
1353:             excludedByDefault: isExcluded,
1354:             excluded: isExcluded, // Set the excluded property as well
1355:           });
1356:         });
1357:         // Update the current index
1358:         currentIndex = endIndex;
1359:         // If there are more files to process, schedule the next chunk
1360:         if (currentIndex < files.length) {
1361:           // Use setTimeout to allow the UI to update between chunks
1362:           setTimeout(processNextChunk, 0);
1363:         } else {
1364:           // All files processed, send the complete list
1365:           console.log(`Finished processing all ${processedFiles.length} files`);
1366:           // Cache the processed files
1367:           directoryCache.set(folderPath, processedFiles);
1368:           try {
1369:             console.log(`Sending ${processedFiles.length} files to renderer`);
1370:             // Log a sample of paths to check normalization
1371:             if (processedFiles.length > 0) {
1372:               console.log("Sample file paths (first 3):");
1373:               processedFiles.slice(0, 3).forEach(file => {
1374:                 console.log(`- ${file.path}`);
1375:               });
1376:             }
1377:             // Send the files to the renderer process
1378:             event.sender.send("file-list-data", processedFiles);
1379:             // Clear loading state
1380:             isLoadingDirectory = false;
1381:             if (loadingTimeoutId) {
1382:               clearTimeout(loadingTimeoutId);
1383:               loadingTimeoutId = null;
1384:             }
1385:             // Set up file watcher after successfully loading the directory
1386:             setupFileWatcher(folderPath, mainWindow);
1387:           } catch (sendErr) {
1388:             console.error("Error sending file data:", sendErr);
1389:             // If sending fails, try again with minimal data
1390:             const minimalFiles = processedFiles.map((file) => ({
1391:               name: file.name,
1392:               path: file.path,
1393:               tokenCount: file.tokenCount,
1394:               uncompressedTokenCount: file.uncompressedTokenCount,
1395:               isCompressed: file.isCompressed,
1396:               size: file.size,
1397:               isBinary: file.isBinary,
1398:               isSkipped: file.isSkipped,
1399:               excludedByDefault: file.excludedByDefault,
1400:             }));
1401:             event.sender.send("file-list-data", minimalFiles);
1402:             // Clear loading state
1403:             isLoadingDirectory = false;
1404:             if (loadingTimeoutId) {
1405:               clearTimeout(loadingTimeoutId);
1406:               loadingTimeoutId = null;
1407:             }
1408:           }
1409:         }
1410:       };
1411:       // Start processing the first chunk
1412:       processNextChunk();
1413:     };
1414:     // Start processing files
1415:     processFiles();
1416:   } catch (error) {
1417:     console.error("Error processing files:", error);
1418:     event.sender.send("file-processing-status", {
1419:       status: "error",
1420:       message: `Error processing files: ${error.message}`,
1421:     });
1422:     // Clear loading state
1423:     isLoadingDirectory = false;
1424:     if (loadingTimeoutId) {
1425:       clearTimeout(loadingTimeoutId);
1426:       loadingTimeoutId = null;
1427:     }
1428:   }
1429: }
1430: // Check if a file should be excluded by default, using gitignore-style pattern matching
1431: // Create a pattern cache to avoid recreating ignore instances
1432: const patternCache = {
1433:   global: null,
1434:   local: {},  // Cache by rootDir
1435:   combined: {}, // Cache by rootDir
1436:   excludedLocal: {}, // Initialize excludedLocal object
1437:   excludedGlobal: [] // Initialize excludedGlobal array
1438: };
1439: // Counter to limit debug output
1440: let debugCounter = 0;
1441: const MAX_DEBUG_FILES = 5;
1442: function shouldExcludeByDefault(filePath, rootDir) {
1443:   // Normalize both paths to ensure consistent handling
1444:   const normalizedPath = normalizePath(filePath);
1445:   const normalizedRoot = normalizePath(rootDir);
1446:   // Use cached ignore instance if available
1447:   if (!patternCache.combined[rootDir]) {
1448:     // Initialize cache for this root directory
1449:     const ig = ignore();
1450:     // Track all patterns for debugging
1451:     let allPatterns = [];
1452:     // Add built-in patterns - convert array to a proper string format for the ignore package
1453:     const builtInPatterns = [...excludedFiles, ...DEFAULT_EXCLUSIONS];
1454:     ig.add(builtInPatterns);
1455:     allPatterns = builtInPatterns;
1456:     // Try to load global patterns if not already cached
1457:     if (!patternCache.global) {
1458:       try {
1459:         const appDataPath = app.getPath('userData');
1460:         const globalIgnorePath = path.join(appDataPath, 'global_patterns.ignore');
1461:         if (fs.existsSync(globalIgnorePath)) {
1462:           const content = fs.readFileSync(globalIgnorePath, 'utf8');
1463:           if (content.trim()) {
1464:             const { excludedPatterns, userPatterns } = parsePatterns(content);
1465:             // Cache global patterns and excluded patterns
1466:             patternCache.global = userPatterns;
1467:             patternCache.excludedGlobal = excludedPatterns;
1468:           }
1469:         }
1470:       } catch (err) {
1471:         console.error('Error loading global ignore patterns:', err);
1472:         patternCache.global = '';
1473:         patternCache.excludedGlobal = [];
1474:       }
1475:     }
1476:     // Add global patterns if available
1477:     if (patternCache.global) {
1478:       ig.add(patternCache.global);
1479:     }
1480:     // Try to load local patterns if not already cached
1481:     if (!patternCache.local[rootDir]) {
1482:       try {
1483:         const ignoreFilePath = path.join(rootDir, '.repo_ignore');
1484:         if (fs.existsSync(ignoreFilePath)) {
1485:           const content = fs.readFileSync(ignoreFilePath, 'utf8');
1486:           if (content.trim()) {
1487:             const { excludedPatterns, userPatterns } = parsePatterns(content);
1488:             // Cache local patterns and excluded patterns
1489:             patternCache.local[rootDir] = userPatterns;
1490:             patternCache.excludedLocal[rootDir] = excludedPatterns;
1491:           } else {
1492:             patternCache.local[rootDir] = '';
1493:             patternCache.excludedLocal[rootDir] = [];
1494:           }
1495:         } else {
1496:           patternCache.local[rootDir] = '';
1497:           patternCache.excludedLocal[rootDir] = [];
1498:         }
1499:       } catch (err) {
1500:         console.error('Error loading local ignore patterns:', err);
1501:         patternCache.local[rootDir] = '';
1502:         patternCache.excludedLocal[rootDir] = [];
1503:       }
1504:     }
1505:     // Add local patterns if available
1506:     if (patternCache.local[rootDir]) {
1507:       ig.add(patternCache.local[rootDir]);
1508:     }
1509:     // Cache the ignore instance
1510:     patternCache.combined[rootDir] = ig;
1511:   }
1512:   // Get the ignore instance from cache
1513:   const ig = patternCache.combined[rootDir];
1514:   // Check if the file should be ignored
1515:   const relativePath = path.relative(normalizedRoot, normalizedPath);
1516:   const shouldIgnore = ig.ignores(relativePath);
1517:   // Check if the pattern that would ignore this file is disabled
1518:   if (shouldIgnore) {
1519:     const excludedGlobal = patternCache.excludedGlobal || [];
1520:     const excludedLocal = patternCache.excludedLocal[rootDir] || [];
1521:     const allExcluded = [...excludedGlobal, ...excludedLocal];
1522:     // If any pattern that would match this file is disabled, don't ignore it
1523:     for (const pattern of allExcluded) {
1524:       try {
1525:         if (minimatch(relativePath, pattern)) {
1526:           return false;
1527:         }
1528:       } catch (e) {
1529:         console.error(`Error with minimatch for pattern "${pattern}":`, e);
1530:         // Continue processing other patterns if one fails
1531:       }
1532:     }
1533:   }
1534:   return shouldIgnore;
1535: }
1536: // Function to clear pattern cache when patterns change
1537: function clearPatternCache(rootDir) {
1538:   if (rootDir) {
1539:     delete patternCache.local[rootDir];
1540:     delete patternCache.combined[rootDir];
1541:     delete patternCache.excludedLocal[rootDir];
1542:   } else {
1543:     patternCache.global = null;
1544:     patternCache.local = {};
1545:     patternCache.combined = {};
1546:     patternCache.excludedLocal = {};
1547:     patternCache.excludedGlobal = [];
1548:   }
1549:   debugCounter = 0;
1550: }
1551: // IPC handler for counting tokens in a given text string
1552: ipcMain.handle('count-tokens', async (event, text) => {
1553:   try {
1554:     if (typeof text !== 'string') {
1555:       // Return 0 or throw error if input is not a string
1556:       return 0; 
1557:     }
1558:     return countTokens(text); // Reuse the existing countTokens function
1559:   } catch (error) {
1560:     console.error("Error handling 'count-tokens' IPC:", error);
1561:     // Return 0 or throw? Let's return 0 for robustness in the renderer.
1562:     return 0; 
1563:   }
1564: });
1565: // Add a debug handler for file selection
1566: ipcMain.on("debug-file-selection", (event, data) => {
1567:   console.log("DEBUG - File Selection:", data);
1568: });
1569: // Handle resetting patterns to defaults
1570: ipcMain.handle('reset-ignore-patterns', async (event, { folderPath, isGlobal }) => {
1571:   try {
1572:     if (isGlobal) {
1573:       // Reset global patterns to defaults
1574:       const appDataPath = app.getPath('userData');
1575:       const globalIgnorePath = path.join(appDataPath, 'global_patterns.ignore');
1576:       // Write default patterns to the file
1577:       await writeFile(globalIgnorePath, DEFAULT_USER_PATTERNS);
1578:       console.log(`Reset global ignore patterns to defaults at ${globalIgnorePath}`);
1579:       // Clear all pattern caches to ensure new patterns are applied
1580:       clearPatternCache();
1581:       // Clear all directory caches to ensure new patterns are applied
1582:       directoryCache.clearAll();
1583:       return { 
1584:         success: true, 
1585:         patterns: DEFAULT_USER_PATTERNS,
1586:         systemPatterns: SYSTEM_EXCLUSIONS
1587:       };
1588:     } else {
1589:       // Reset local patterns (delete the file)
1590:       if (!folderPath) {
1591:         return { success: false, error: 'No folder path provided' };
1592:       }
1593:       const ignoreFilePath = path.join(folderPath, '.repo_ignore');
1594:       if (fs.existsSync(ignoreFilePath)) {
1595:         fs.unlinkSync(ignoreFilePath);
1596:         console.log(`Deleted local ignore file at ${ignoreFilePath}`);
1597:       }
1598:       // Clear pattern cache for this folder
1599:       clearPatternCache(folderPath);
1600:       // Clear cache for this folder
1601:       directoryCache.clear(folderPath);
1602:       return { 
1603:         success: true, 
1604:         patterns: '',
1605:         systemPatterns: SYSTEM_EXCLUSIONS
1606:       };
1607:     }
1608:   } catch (error) {
1609:     console.error('Error resetting ignore patterns:', error);
1610:     return { success: false, error: error.message };
1611:   }
1612: });
1613: // Handle clearing ignore patterns (only for local patterns)
1614: ipcMain.handle('clear-local-ignore-patterns', async (event, { folderPath }) => {
1615:   console.log('Clearing local ignore patterns for:', folderPath);
1616:   try {
1617:     if (!folderPath) {
1618:       return { success: false, error: 'No folder path provided' };
1619:     }
1620:     const result = await clearLocalIgnorePatterns(folderPath);
1621:     // Clear the cache for this folder to ensure patterns are reloaded
1622:     if (patternCache.combined[folderPath]) {
1623:       delete patternCache.combined[folderPath];
1624:     }
1625:     return { success: true };
1626:   } catch (error) {
1627:     console.error('Error in clear-local-ignore-patterns handler:', error);
1628:     return { success: false, error: String(error) };
1629:   }
1630: });
1631: // Disable security warnings in development mode
1632: // These warnings don't appear in production builds anyway
1633: process.env.ELECTRON_DISABLE_SECURITY_WARNINGS = 'true';
1634: // Enable clipboard reading/writing (for security reasons, this is restricted by default)
1635: app.commandLine.appendSwitch('enable-features', 'SharedArrayBuffer');
1636: // This module pattern is preserved
1637: module.exports = { 
1638:   app, 
1639:   BrowserWindow,
1640:   // Export pattern-related functions
1641:   shouldExcludeByDefault,
1642:   getAllPatterns,
1643:   loadGitignore,
1644:   normalizePath
1645: };
1646: /**
1647:  * Clears local ignore patterns for a specific folder
1648:  * @param {string} folderPath - Path of the folder for which to clear ignore patterns
1649:  * @returns {Promise<boolean>} - True if successful, false otherwise
1650:  */
1651: async function clearLocalIgnorePatterns(folderPath) {
1652:   try {
1653:     const ignoreFilePath = path.join(folderPath, '.repo_ignore');
1654:     // Delete the file if it exists
1655:     if (fs.existsSync(ignoreFilePath)) {
1656:       await unlink(ignoreFilePath);
1657:       console.log(`Cleared local ignore patterns by deleting ${ignoreFilePath}`);
1658:     } else {
1659:       console.log(`No local ignore file found at ${ignoreFilePath}, nothing to clear`);
1660:     }
1661:     // Clear pattern cache for this folder using the correct cache variable
1662:     if (patternCache) {
1663:       // Clear local patterns
1664:       if (patternCache.local && patternCache.local[folderPath]) {
1665:         delete patternCache.local[folderPath];
1666:       }
1667:       // Clear combined patterns
1668:       if (patternCache.combined && patternCache.combined[folderPath]) {
1669:         delete patternCache.combined[folderPath];
1670:       }
1671:       // Clear excluded local patterns
1672:       if (patternCache.excludedLocal && patternCache.excludedLocal[folderPath]) {
1673:         delete patternCache.excludedLocal[folderPath];
1674:       }
1675:       console.log(`Cleared pattern cache for ${folderPath}`);
1676:     }
1677:     // Clear directory cache for this folder
1678:     if (directoryCache && typeof directoryCache.clear === 'function') {
1679:       directoryCache.clear(folderPath);
1680:     }
1681:     return true;
1682:   } catch (error) {
1683:     console.error('Error clearing local ignore patterns:', error);
1684:     throw error;
1685:   }
1686: }
1687: // Handle saving ignore patterns
1688: ipcMain.handle('save-ignore-patterns', async (event, { patterns, isGlobal, folderPath }) => {
1689:   try {
1690:     if (!isWindowValid(mainWindow)) {
1691:       console.warn("Window not initialized yet or destroyed");
1692:       return { success: false, error: 'Window not initialized' };
1693:     }
1694:     if (isGlobal) {
1695:       try {
1696:         const appDataPath = app.getPath('userData');
1697:         const globalIgnorePath = path.join(appDataPath, 'global_patterns.ignore');
1698:         // Ensure directory exists
1699:         if (!fs.existsSync(appDataPath)) {
1700:           await fs.promises.mkdir(appDataPath, { recursive: true });
1701:         }
1702:         // Write patterns to file
1703:         await fs.promises.writeFile(globalIgnorePath, patterns, 'utf8');
1704:         console.log(`Saved global ignore patterns to ${globalIgnorePath}`);
1705:         // Clear pattern cache to ensure new patterns are applied
1706:         clearPatternCache();
1707:         // Clear all directory caches to ensure new patterns are applied
1708:         directoryCache.clearAll();
1709:         return { success: true };
1710:       } catch (error) {
1711:         console.error('Error saving global patterns:', error);
1712:         return { success: false, error: error.message };
1713:       }
1714:     } else {
1715:       if (!folderPath) {
1716:         return { success: false, error: 'No folder path provided for local patterns' };
1717:       }
1718:       try {
1719:         const ignoreFilePath = path.join(folderPath, '.repo_ignore');
1720:         // Write patterns to file
1721:         await fs.promises.writeFile(ignoreFilePath, patterns, 'utf8');
1722:         console.log(`Saved local ignore patterns to ${ignoreFilePath}`);
1723:         // Clear pattern cache for this folder
1724:         clearPatternCache(folderPath);
1725:         // Clear cache for this folder
1726:         directoryCache.clear(folderPath);
1727:         return { success: true };
1728:       } catch (error) {
1729:         console.error('Error saving local patterns:', error);
1730:         return { success: false, error: error.message };
1731:       }
1732:     }
1733:   } catch (error) {
1734:     console.error('Error in save-ignore-patterns handler:', error);
1735:     return { success: false, error: error.message };
1736:   }
1737: });
1738: // Handle testing ignore patterns against a folder
1739: ipcMain.handle('test-ignore-patterns', async (event, { folderPath, patterns }) => {
1740:   console.log(`Testing patterns for folder: ${folderPath}`);
1741:   if (!folderPath || !patterns) {
1742:     return { success: false, error: 'Missing folderPath or patterns' };
1743:   }
1744:   try {
1745:     // 1. Create an ignore instance with the provided patterns
1746:     // Note: These patterns should already be combined (system+global+local)
1747:     // from the frontend logic, matching the current edits.
1748:     const ig = ignore().add(patterns);
1749:     // 2. Get the list of all files in the directory (recursively)
1750:     // We can reuse or adapt the file listing logic, ensuring it respects basic system ignores
1751:     // but *not* applying the user patterns yet, as we want to test against the raw list.
1752:     const allFiles = [];
1753:     const files = await fs.promises.readdir(folderPath, { withFileTypes: true });
1754:     // Basic recursive function to get all file paths relative to the root
1755:     // This needs to be robust and handle potential errors/symlinks etc.
1756:     // For simplicity here, we use a basic traversal. Consider reusing `walkDirectory` logic if available.
1757:     async function traverseDir(currentPath) {
1758:       try {
1759:         const entries = await fs.promises.readdir(currentPath, { withFileTypes: true });
1760:         for (const entry of entries) {
1761:           const fullPath = path.join(currentPath, entry.name);
1762:           const relativePath = path.relative(folderPath, fullPath);
1763:           // Basic exclusion (e.g., node_modules, .git) - apply system defaults if needed
1764:           // Or rely on the provided patterns to handle this.
1765:           // For now, let's assume the provided `patterns` include system defaults.
1766:           if (entry.isDirectory()) {
1767:             // Check if directory itself is ignored before traversing
1768:             if (!ig.ignores(relativePath + '/')) { // Add trailing slash for directories
1769:               await traverseDir(fullPath);
1770:             }
1771:           } else if (entry.isFile()) {
1772:             allFiles.push(normalizePath(relativePath)); // Add normalized relative path
1773:           }
1774:         }
1775:       } catch (error) {
1776:         // Log errors but continue if possible
1777:         console.warn(`Error reading directory ${currentPath}:`, error.message);
1778:       }
1779:     }
1780:     await traverseDir(folderPath);
1781:     // 3. Filter the file list using the ignore instance
1782:     const ignoredFiles = allFiles.filter(relativePath => ig.ignores(relativePath));
1783:     console.log(`Found ${allFiles.length} total files, ${ignoredFiles.length} would be ignored.`);
1784:     return {
1785:       success: true,
1786:       ignoredCount: ignoredFiles.length,
1787:       ignoredFiles: ignoredFiles, // Return the list of ignored relative paths
1788:       totalFilesChecked: allFiles.length
1789:     };
1790:   } catch (error) {
1791:     console.error('Error testing ignore patterns:', error);
1792:     return { success: false, error: error.message };
1793:   }
1794: });
1795: // Setup file watcher for real-time file change detection
1796: function setupFileWatcher(folderPath, window) {
1797:   // Close any existing watcher
1798:   if (fileWatcher) {
1799:     console.log("Closing existing file watcher");
1800:     fileWatcher.close();
1801:     fileWatcher = null;
1802:   }
1803:   // Close all existing watchers if we're maintaining an array of them
1804:   if (global.allWatchers && Array.isArray(global.allWatchers)) {
1805:     console.log(`Closing ${global.allWatchers.length} existing watchers`);
1806:     global.allWatchers.forEach(w => {
1807:       try {
1808:         w.close();
1809:       } catch (err) {
1810:         // Ignore errors when closing
1811:       }
1812:     });
1813:     global.allWatchers = [];
1814:   } else {
1815:     global.allWatchers = [];
1816:   }
1817:   if (!folderPath || !window || !isWindowValid(window)) {
1818:     console.log("Cannot setup file watcher: missing dependencies");
1819:     return;
1820:   }
1821:   console.log(`Setting up file watcher for ${folderPath}`);
1822:   try {
1823:     // Get ignore patterns for this folder to avoid watching excluded files
1824:     const allPatterns = getAllPatterns(folderPath);
1825:     const ig = ignore().add(allPatterns);
1826:     // Create ignored function for filtering
1827:     const isIgnored = (watchPath) => {
1828:       // Check for empty or invalid paths
1829:       if (!watchPath || typeof watchPath !== 'string' || watchPath.trim() === '') {
1830:         console.warn(`Attempted to check an empty or invalid path for ignoring. Treating as not ignored.`);
1831:         return false; // Don't ignore empty paths
1832:       }
1833:       // Always ignore node_modules and other large directories
1834:       if (watchPath.includes('node_modules') || 
1835:           watchPath.includes('.git') || 
1836:           watchPath.includes('dist') || 
1837:           watchPath.includes('build')) {
1838:         return true;
1839:       }
1840:       // The ignore package requires relative paths
1841:       try {
1842:         const normalizedWatchPath = normalizePath(watchPath);
1843:         const normalizedFolderPath = normalizePath(folderPath);
1844:         // Convert absolute path to relative path
1845:         const relativePath = path.relative(normalizedFolderPath, normalizedWatchPath);
1846:         // Check that relativePath is not empty before passing to ignores()
1847:         if (!relativePath || relativePath.trim() === '') {
1848:           console.warn(`Empty relative path generated from: ${watchPath}. Treating as not ignored.`);
1849:           return false;
1850:         }
1851:         // Now pass the relative path to ignores()
1852:         return ig.ignores(relativePath);
1853:       } catch (err) {
1854:         console.warn(`Error checking if path is ignored: ${watchPath}`, err);
1855:         return false; // Don't ignore if there's an error
1856:       }
1857:     };
1858:     // Use chokidar if available, otherwise fall back to native fs.watch
1859:     if (chokidar && typeof chokidar.watch === 'function' && 
1860:         chokidar.watch.toString().includes('function')) {
1861:       // Start watching the folder with appropriate options using chokidar
1862:       try {
1863:         console.log("Using chokidar for file watching with optimized settings");
1864:         fileWatcher = chokidar.watch(folderPath, {
1865:           ignored: [
1866:             isIgnored,
1867:             /(^|[\/\\])\../, // Ignore dotfiles
1868:             '**/node_modules/**',
1869:             '**/.git/**'
1870:           ],
1871:           persistent: true,
1872:           ignoreInitial: true, // Don't fire events for existing files
1873:           awaitWriteFinish: {
1874:             stabilityThreshold: 500, // Wait 500ms after last change
1875:             pollInterval: 100 // Poll every 100ms
1876:           },
1877:           depth: 5, // Limit watch depth to 5 levels to prevent excessive watchers
1878:           useFsEvents: true, // Use native filesystem events if available
1879:           alwaysStat: false, // Don't get stats for all files (performance)
1880:           usePolling: false // Don't use polling (uses more CPU)
1881:         });
1882:         // Set up event handlers with debouncing to avoid too many updates
1883:         let addDebounce = null;
1884:         let changeDebounce = null;
1885:         let deleteDebounce = null;
1886:         fileWatcher
1887:           .on('add', path => {
1888:             if (addDebounce) clearTimeout(addDebounce);
1889:             addDebounce = setTimeout(() => {
1890:               console.log(`File added (raw path): ${path}`);
1891:               // Ensure consistent path format
1892:               const normalizedPath = normalizePath(path);
1893:               safeRendererSend(window, 'file-changed', { type: 'add', path: normalizedPath });
1894:             }, WATCH_DEBOUNCE_TIME);
1895:           })
1896:           .on('change', path => {
1897:             if (changeDebounce) clearTimeout(changeDebounce);
1898:             changeDebounce = setTimeout(() => {
1899:               console.log(`File changed (raw path): ${path}`);
1900:               // Ensure consistent path format
1901:               const normalizedPath = normalizePath(path);
1902:               safeRendererSend(window, 'file-changed', { type: 'change', path: normalizedPath });
1903:             }, WATCH_DEBOUNCE_TIME);
1904:           })
1905:           .on('unlink', path => {
1906:             if (deleteDebounce) clearTimeout(deleteDebounce);
1907:             deleteDebounce = setTimeout(() => {
1908:               console.log(`File deleted (raw path): ${path}`);
1909:               // Ensure consistent path format
1910:               const normalizedPath = normalizePath(path);
1911:               safeRendererSend(window, 'file-changed', { type: 'delete', path: normalizedPath });
1912:             }, WATCH_DEBOUNCE_TIME);
1913:           })
1914:           .on('error', error => {
1915:             // Handle errors specifically
1916:             if (error.code === 'EMFILE') {
1917:               console.error('Too many files to watch! Some changes may not be detected.');
1918:               console.error('You can increase the limit with: ulimit -n <number> (macOS/Linux)');
1919:               safeRendererSend(window, 'file-processing-status', {
1920:                 status: 'warning',
1921:                 message: 'Too many files to watch. Some changes may not be detected.'
1922:               });
1923:             } else {
1924:               console.error(`File watcher error: ${error}`);
1925:             }
1926:           });
1927:         console.log("Chokidar file watcher set up successfully");
1928:       } catch (err) {
1929:         console.error(`Error setting up chokidar watcher: ${err}`);
1930:         // Fall back to fs.watch on chokidar failure
1931:         useFsWatchFallback();
1932:       }
1933:     } else {
1934:       // Fall back to native fs.watch
1935:       useFsWatchFallback();
1936:     }
1937:     // Function for using fs.watch as a fallback
1938:     function useFsWatchFallback() {
1939:       console.log("Using optimized native fs.watch fallback for file watching");
1940:       // This will store all the watchers we create
1941:       const watchers = [];
1942:       let addDebounce = null;
1943:       let deleteDebounce = null;
1944:       let changeDebounce = null;
1945:       // Create a watcher manager to handle errors and limits
1946:       const watcherManager = {
1947:         // Track the number of watchers and depth
1948:         count: 0,
1949:         // Maximum number of watchers to create
1950:         MAX_WATCHERS: 1000,
1951:         // Maximum directory depth to watch
1952:         MAX_DEPTH: 4,
1953:         // Add a watcher if we haven't hit the limit
1954:         addWatcher: function(watcher) {
1955:           if (this.count >= this.MAX_WATCHERS) {
1956:             console.warn(`Reached maximum watcher limit (${this.MAX_WATCHERS}). Some changes may not be detected.`);
1957:             return false;
1958:           }
1959:           watchers.push(watcher);
1960:           global.allWatchers.push(watcher); // Also add to global tracker
1961:           this.count++;
1962:           return true;
1963:         },
1964:         // Check if we can add more watchers
1965:         canAddWatchers: function() {
1966:           return this.count < this.MAX_WATCHERS;
1967:         }
1968:       };
1969:       // Function to watch a directory and its subdirectories
1970:       const watchDirectory = (dir, depth = 0) => {
1971:         // Validate directory path before proceeding
1972:         if (!dir || typeof dir !== 'string' || dir.trim() === '') {
1973:           console.warn('Attempted to watch an empty or invalid directory path. Skipping.');
1974:           return;
1975:         }
1976:         // Check depth limit to avoid excessive recursion
1977:         if (depth > watcherManager.MAX_DEPTH) {
1978:           console.log(`Reached maximum watch depth (${watcherManager.MAX_DEPTH}) for ${dir}. Skipping deeper directories.`);
1979:           return;
1980:         }
1981:         // Check if we should ignore this directory
1982:         if (isIgnored(dir)) {
1983:           return;
1984:         }
1985:         // Check if we've hit the watcher limit
1986:         if (!watcherManager.canAddWatchers()) {
1987:           return;
1988:         }
1989:         try {
1990:           // Watch the current directory
1991:           const watcher = safeFsWatch(dir, (eventType, filename) => {
1992:             // Validate filename before using it
1993:             if (!filename || typeof filename !== 'string' || filename.trim() === '') {
1994:               console.warn(`Received empty or invalid filename in watcher event for ${dir}. Skipping.`);
1995:               return;
1996:             }
1997:             const fullPath = path.join(dir, filename);
1998:             // Skip ignored files/directories
1999:             if (isIgnored(fullPath)) return;
2000:             try {
2001:               // Check if the path still exists
2002:               const exists = fs.existsSync(fullPath);
2003:               const stats = exists ? fs.statSync(fullPath) : null;
2004:               if (eventType === 'rename') {
2005:                 if (exists && stats) {
2006:                   // It's an add event
2007:                   if (addDebounce) clearTimeout(addDebounce);
2008:                   addDebounce = setTimeout(() => {
2009:                     console.log(`File added (raw path): ${fullPath}`);
2010:                     // Ensure consistent path format
2011:                     const normalizedPath = normalizePath(fullPath);
2012:                     safeRendererSend(window, 'file-changed', { type: 'add', path: normalizedPath });
2013:                     // If it's a directory, watch it too (but respect depth limit)
2014:                     if (stats.isDirectory() && depth < watcherManager.MAX_DEPTH) {
2015:                       watchDirectory(fullPath, depth + 1);
2016:                     }
2017:                   }, WATCH_DEBOUNCE_TIME);
2018:                 } else {
2019:                   // It's a delete event
2020:                   if (deleteDebounce) clearTimeout(deleteDebounce);
2021:                   deleteDebounce = setTimeout(() => {
2022:                     console.log(`File deleted (raw path): ${fullPath}`);
2023:                     // Ensure consistent path format
2024:                     const normalizedPath = normalizePath(fullPath);
2025:                     safeRendererSend(window, 'file-changed', { type: 'delete', path: normalizedPath });
2026:                   }, WATCH_DEBOUNCE_TIME);
2027:                 }
2028:               } else if (eventType === 'change' && exists && stats && !stats.isDirectory()) {
2029:                 // It's a file change event
2030:                 if (changeDebounce) clearTimeout(changeDebounce);
2031:                 changeDebounce = setTimeout(() => {
2032:                   console.log(`File changed (raw path): ${fullPath}`);
2033:                   // Ensure consistent path format
2034:                   const normalizedPath = normalizePath(fullPath);
2035:                   safeRendererSend(window, 'file-changed', { type: 'change', path: normalizedPath });
2036:                 }, WATCH_DEBOUNCE_TIME);
2037:               }
2038:             } catch (err) {
2039:               console.error(`Error handling file event for ${fullPath}:`, err);
2040:             }
2041:           });
2042:           // Add to our tracked watchers
2043:           if (watcher && watcherManager.addWatcher(watcher)) {
2044:             if (depth === 0) {
2045:               console.log(`Set up root watcher for ${dir}`);
2046:             }
2047:           }
2048:           // Recursively watch subdirectories (with depth limit)
2049:           try {
2050:             if (watcherManager.canAddWatchers()) {
2051:               const entries = fs.readdirSync(dir, { withFileTypes: true });
2052:               // Process only directories
2053:               const directories = entries.filter(entry => entry.isDirectory());
2054:               // Limit the number of directories to watch at each level
2055:               const MAX_DIRS_PER_LEVEL = 50;
2056:               if (directories.length > MAX_DIRS_PER_LEVEL) {
2057:                 console.log(`Limiting subdirectory watching to ${MAX_DIRS_PER_LEVEL} at ${dir}`);
2058:                 directories.length = MAX_DIRS_PER_LEVEL;
2059:               }
2060:               for (const entry of directories) {
2061:                 if (!watcherManager.canAddWatchers()) {
2062:                   console.log(`Reached watcher limit. Stopping directory traversal at ${dir}`);
2063:                   break;
2064:                 }
2065:                 const subDir = path.join(dir, entry.name);
2066:                 if (!isIgnored(subDir)) {
2067:                   watchDirectory(subDir, depth + 1);
2068:                 }
2069:               }
2070:             }
2071:           } catch (err) {
2072:             console.error(`Error reading directory ${dir}:`, err);
2073:           }
2074:         } catch (err) {
2075:           // Handle EMFILE error specifically
2076:           if (err.code === 'EMFILE') {
2077:             console.error('Too many open files. No more watchers will be created.');
2078:             safeRendererSend(window, 'file-processing-status', {
2079:               status: 'warning',
2080:               message: 'Too many files to watch. Some changes may not be detected.'
2081:             });
2082:           } else {
2083:             console.error(`Error setting up watcher for ${dir}:`, err);
2084:           }
2085:         }
2086:       };
2087:       // Start watching from the root folder
2088:       watchDirectory(folderPath);
2089:       // Create a fileWatcher-like object with a close method
2090:       fileWatcher = {
2091:         close: () => {
2092:           watchers.forEach(watcher => {
2093:             try {
2094:               watcher.close();
2095:             } catch (err) {
2096:               console.error("Error closing watcher:", err);
2097:             }
2098:           });
2099:           console.log(`Closed ${watchers.length} watchers`);
2100:         }
2101:       };
2102:       console.log(`Native fs.watch fallback set up with ${watchers.length} watchers`);
2103:     }
2104:     console.log("File watcher set up successfully");
2105:   } catch (error) {
2106:     console.error("Error setting up file watcher:", error);
2107:     // Notify the renderer of the error
2108:     safeRendererSend(window, 'file-processing-status', {
2109:       status: 'error',
2110:       message: `Error setting up file watcher: ${error.message}`
2111:     });
2112:   }
2113: }
2114: // Handle get-file-metadata request
2115: ipcMain.handle("get-file-metadata", async (event, filePath) => {
2116:   try {
2117:     console.log(`Getting metadata for file: ${filePath}`);
2118:     if (!filePath) {
2119:       return { success: false, error: "No file path provided" };
2120:     }
2121:     // Check if file exists
2122:     if (!fs.existsSync(filePath)) {
2123:       return { success: false, error: "File does not exist" };
2124:     }
2125:     // Get file stats
2126:     const stats = fs.statSync(filePath);
2127:     // Skip if it's a directory
2128:     if (stats.isDirectory()) {
2129:       return { success: false, error: "Path is a directory, not a file" };
2130:     }
2131:     // Check if it's a binary file
2132:     const isBinary = isBinaryFile(filePath);
2133:     // Get base file info
2134:     const fileName = path.basename(filePath);
2135:     const normalizedPath = normalizePath(filePath);
2136:     // Find parent directory to check ignore patterns
2137:     const parentDir = path.dirname(filePath);
2138:     const isExcluded = shouldExcludeByDefault(normalizedPath, parentDir);
2139:     // Create file metadata object
2140:     const fileData = {
2141:       name: fileName,
2142:       path: normalizedPath,
2143:       size: stats.size,
2144:       lastModified: stats.mtime.getTime(),
2145:       isBinary: isBinary,
2146:       excludedByDefault: isExcluded,
2147:       excluded: isExcluded,
2148:       isSkipped: isBinary || isExcluded || stats.size > MAX_FILE_SIZE,
2149:       tokenCount: 0, // Will be calculated on demand
2150:       uncompressedTokenCount: 0
2151:     };
2152:     // If it's a small text file, count tokens
2153:     if (!isBinary && stats.size <= MAX_FILE_SIZE) {
2154:       try {
2155:         const content = fs.readFileSync(filePath, "utf-8");
2156:         fileData.tokenCount = countTokens(content);
2157:         fileData.uncompressedTokenCount = fileData.tokenCount;
2158:       } catch (error) {
2159:         console.error(`Error reading file content for ${filePath}:`, error);
2160:         fileData.error = `Error reading file: ${error.message}`;
2161:       }
2162:     }
2163:     return {
2164:       success: true,
2165:       fileData
2166:     };
2167:   } catch (error) {
2168:     console.error(`Error getting file metadata for ${filePath}:`, error);
2169:     return {
2170:       success: false,
2171:       error: `Error: ${error.message}`
2172:     };
2173:   }
2174: });

================
File: tsconfig.node.json
================
 1: {
 2:   "compilerOptions": {
 3:     "composite": true,
 4:     "skipLibCheck": true,
 5:     "module": "ESNext",
 6:     "moduleResolution": "bundler",
 7:     "allowSyntheticDefaultImports": true
 8:   },
 9:   "include": ["vite.config.ts"]
10: }

================
File: vite.config.ts
================
 1: import { defineConfig } from "vite";
 2: import react from "@vitejs/plugin-react";
 3: import path from "path";
 4: // List of tree-sitter packages (adjust if you use more/less)
 5: const treeSitterPackages = [
 6:   "tree-sitter",
 7:   "tree-sitter-javascript",
 8:   "tree-sitter-typescript",
 9:   "tree-sitter-python",
10:   "tree-sitter-css",
11:   "tree-sitter-html",
12:   // Add any other tree-sitter-* language packages you install
13: ];
14: // https://vitejs.dev/config/
15: export default defineConfig({
16:   plugins: [react()],
17:   base: "./", // Relative base path for assets
18:   build: {
19:     outDir: "dist",
20:     emptyOutDir: true,
21:     sourcemap: true,
22:     // Ensure native modules are treated as external during build
23:     rollupOptions: {
24:       external: [
25:         "electron", // Already implicitly external but good to be explicit
26:         ...treeSitterPackages,
27:         // Add any other native node modules here
28:       ],
29:     },
30:   },
31:   // Add this section to exclude tree-sitter from dependency pre-bundling
32:   optimizeDeps: {
33:     exclude: [
34:       ...treeSitterPackages,
35:     ],
36:   },
37:   resolve: {
38:     alias: {
39:       "@": path.resolve(__dirname, "./src"),
40:     },
41:   },
42: });

================
File: .cursor/rules/github-api.mdc
================
 1: ---
 2: description: You can get information from github, using API
 3: globs: 
 4: alwaysApply: false
 5: ---
 6: Interacting with the GitHub API via `curl` is a powerful way to get specific information or perform actions programmatically.
 7: 
 8: Here's a table with some useful `curl` commands for working with GitHub Pull Requests via the API, similar to the one we discussed. Remember to replace `{owner}`, `{repo}`, `{pull_number}`, and `{commit_sha}` with your specific details, and ensure your `GITHUB_TOKEN` environment variable is set.
 9: 
10: | Command                                                                                                | Description                                                                                               | When to Use                                                                                                                               |
11: | :----------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------- |
12: | `curl -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/repos/{owner}/{repo}/pulls`     | Lists all Pull Requests in a repository.                                                                  | When you want to see all open or closed PRs in a repo, perhaps to get a list of PR numbers or their titles.                              |
13: | `curl -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}` | Gets the details of a specific Pull Request.                                                              | To get comprehensive information about a single PR, including its state, title, body, creator, and head/base commit SHAs.                 |
14: | `curl -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/commits` | Lists the commits in a specific Pull Request.                                                             | To see the individual commits that make up a PR, useful for reviewing the history or getting commit SHAs.                               |
15: | `curl -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/repos/{owner}/{repo}/pulls/{pull_number}/files` | Lists the files changed in a specific Pull Request.                                                       | To see which files were added, modified, or deleted in a PR and get details like the number of additions and deletions per file.          |
16: | `curl -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/repos/{owner}/{repo}/commits/{commit_sha}/check-runs` | Lists the Check Runs associated with a specific commit.                                                   | To get details about automated checks (like GitHub Actions workflows) that ran against a commit, including their status and conclusion.     |
17: | `curl -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/repos/{owner}/{repo}/commits/{commit_sha}/statuses` | Lists the Commit Statuses associated with a specific commit.                                              | To get details about statuses reported by integrations (older Statuses API) against a commit, including their state and description.      |
18: | `curl -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/repos/{owner}/{repo}/issues/{pull_number}/comments` | Lists the comments on a specific Pull Request (PRs are also considered issues in the API).                | To retrieve all comments made on a PR, useful for tracking discussions or building a summary of feedback.                                 |
19: | `curl -H "Authorization: token ${GITHUB_TOKEN}" -X POST -d '{"body": "Your comment text here"}' https://api.github.com/repos/{owner}/{repo}/issues/{pull_number}/comments` | Creates a comment on a specific Pull Request.                                                             | To programmatically add a comment to a PR, perhaps from a script reporting test results or other automated feedback. **Requires write access.** |
20: 
21: **Important Notes:**
22: 
23: *   **Authentication:** All these commands require authentication using a Personal Access Token (PAT) with appropriate scopes (at least `repo` for most read operations).
24: *   **Rate Limits:** The GitHub API has rate limits. If you make too many requests in a short period, you might get throttled.
25: *   **Pagination:** For resources with many items (like lists of PRs, commits, or files), the API results are paginated. You might need to make multiple requests to get all results if there are more than 30 (the default per page) or 100 (the maximum per page). Look for the `Link` header in the response to find the next page URL.
26: *   **JSON Output:** The output of these commands is in JSON format. You can use tools like `jq` to parse and filter this output.
27: 
28: This table should give you a good starting point for exploring your PR information using the GitHub API via `curl`.

================
File: config/native-modules.json
================
 1: {
 2:   "windows": {
 3:     "visualStudioVersion": "",
 4:     "nodeGypPath": ""
 5:   },
 6:   "mac": {
 7:     "nodeGypPath": ""
 8:   },
 9:   "linux": {
10:     "nodeGypPath": ""
11:   },
12:   "general": {
13:     "cxxStandard": "c++20"
14:   }
15: }

================
File: config/README.md
================
 1: # Native Module Configuration
 2: 
 3: This configuration file allows you to customize how native modules are rebuilt in your project without modifying any JavaScript code.
 4: 
 5: ## Platform Requirements
 6: 
 7: ### Windows:
 8: - **Visual Studio 2022** (with C++ desktop development workload)
 9: - **Windows SDK** (included with Visual Studio)
10: - **node-gyp** (installed globally via npm)
11: 
12: ### macOS:
13: - **Xcode Command Line Tools** (`xcode-select --install`)
14: - **node-gyp** (installed globally via npm)
15: 
16: ### Linux:
17: - **GCC/G++** (version supporting C++20)
18: - **Python** (for node-gyp)
19: - **node-gyp** (installed globally via npm)
20: 
21: ## Options
22: 
23: ### Windows-specific Options
24: - `visualStudioVersion` - Specify which Visual Studio version to use (e.g., "2019", "2022")
25: - `nodeGypPath` - Custom path to node-gyp binary (leave empty to use default)
26:   - On Windows, this should point to the `.cmd` file (e.g., `C:\\Path\\To\\node-gyp.cmd`)
27: 
28: ### Mac-specific Options
29: - `nodeGypPath` - Custom path to node-gyp binary (e.g., "/opt/homebrew/bin/node-gyp")
30: 
31: ### Linux-specific Options
32: - `nodeGypPath` - Custom path to node-gyp binary
33: 
34: > Note: Visual Studio requirements are Windows-only. Other platforms use their native toolchains.
35: 
36: ### General Options
37: - `cxxStandard` - C++ standard to use (e.g., "c++20", "c++17")
38: 
39: ## Example Configuration
40: 
41: ```json
42: {
43:   "windows": {
44:     "visualStudioVersion": "2022",
45:     "nodeGypPath": "C:\\Path\\To\\node-gyp.cmd"
46:   },
47:   "mac": {
48:     "nodeGypPath": "/opt/homebrew/bin/node-gyp"
49:   },
50:   "linux": {
51:     "nodeGypPath": "/usr/local/bin/node-gyp"
52:   },
53:   "general": {
54:     "cxxStandard": "c++20"
55:   }
56: }
57: ```
58: 
59: ## Priority Order
60: 
61: The system checks for configuration values in the following order (highest to lowest priority):
62: 
63: 1. Environment variables (e.g., `NPM_CONFIG_MSVS_VERSION`, `NODE_GYP_PATH`)
64: 2. This configuration file (`config/native-modules.json`)
65: 3. Values in `.npmrc` file
66: 4. Default values
67: 
68: This means you can temporarily override settings using environment variables without changing the configuration files.
69: 
70: ## Notes
71: 
72: ### Recommended Configuration Approach
73: 
74: - **Keep .npmrc for:**
75:     - Standard npm configurations used by npm/node-gyp
76:     - Global settings not specific to any platform
77:     - Backward compatibility with existing tools
78: 
79: - **Use config/native-modules.json for:**
80:     - Platform-specific settings (like Visual Studio version)
81:     - Node-gyp path customization
82:     - Settings that vary by operating system
83: 
84: ### For Your Users
85: 
86: It is recommended to direct users to modify the native-modules.json file when they need to change Visual Studio version or node-gyp path. The accompanying README provides clear guidance on available options and examples of proper configuration.
87: 
88: This approach gives you the best of both worlds - standard npm configuration plus an improved user experience for the platform-specific settings that are critical for cross-platform compatibility.

================
File: config/UserInstructions.md
================
  1: # Node-Gyp Setup Instructions
  2: 
  3: ## Windows Setup
  4: 
  5: ### 1. Install Build Tools (Choose One Option)
  6: 
  7: **Option A: Visual Studio (Recommended)**
  8: - Download from [Visual Studio website](https://visualstudio.microsoft.com/)
  9: - Select "Desktop development with C++" workload
 10: - Includes full IDE and all necessary components
 11: 
 12: **Option B: Build Tools Only (Lighter Install)**
 13: - Download [Visual C++ Build Tools](https://visualstudio.microsoft.com/visual-cpp-build-tools/)
 14: - Select these workloads:
 15:   - "C++ build tools"
 16:   - "Windows 10/11 SDK"
 17:   - "MSVC v143 - VS 2022 C++ x64/x86 build tools"
 18: 
 19: Both options provide the required compilers and tools. Visual Studio provides a full development environment, while Build Tools are sufficient for compilation.
 20: 
 21: ### 2. Install Node-Gyp Globally
 22: ```cmd
 23: npm install -g node-gyp
 24: ```
 25: 
 26: ### 3. Find Node-Gyp Path
 27: Choose one method:
 28: 
 29: **Command Prompt:**
 30: ```cmd
 31: where node-gyp
 32: 
 33: # The path will show something like:
 34: C:\Users\YourUsername\AppData\Roaming\npm\node-gyp.cmd
 35: ```
 36: 
 37: **PowerShell:**
 38: ```powershell
 39: (Get-Command node-gyp).Path
 40: 
 41: # The path will show something like:
 42: C:\Users\YourUsername\AppData\Roaming\npm\node-gyp.cmd
 43: ```
 44: 
 45: ### 4. Update Configuration
 46: Copy the path to `config/native-modules.json`:
 47: ```json
 48: {
 49:   "windows": {
 50:     "visualStudioVersion": "2022",
 51:     # Ensure to replace with \\
 52:     "nodeGypPath": "C:\\Path\\To\\node-gyp.cmd"
 53:   }
 54: }
 55: ```
 56: 
 57: ---
 58: 
 59: ## macOS Setup
 60: 
 61: ### 1. Install Xcode Command Line Tools
 62: ```bash
 63: xcode-select --install
 64: ```
 65: 
 66: ### 2. Install Node-Gyp Globally
 67: ```bash
 68: npm install -g node-gyp
 69: ```
 70: 
 71: ### 3. Find Node-Gyp Path
 72: ```bash
 73: which node-gyp
 74: 
 75: # The path will show something like:
 76: /usr/local/bin/node-gyp
 77: ```
 78: 
 79: ### 4. Update Configuration
 80: ```json
 81: {
 82:   "mac": {
 83:     "nodeGypPath": "/usr/local/bin/node-gyp"
 84:   }
 85: }
 86: ```
 87: 
 88: ---
 89: 
 90: ## Linux Setup
 91: 
 92: ### 1. Install Build Tools
 93: ```bash
 94: sudo apt-get update
 95: sudo apt-get install build-essential python3
 96: ```
 97: 
 98: ### 2. Install Node-Gyp Globally
 99: ```bash
100: npm install -g node-gyp
101: ```
102: 
103: ### 3. Find Node-Gyp Path
104: ```bash
105: which node-gyp
106: 
107: # The path will show something like:
108: /usr/bin/node-gyp
109: ```
110: 
111: ### 4. Update Configuration
112: ```json
113: {
114:   "linux": {
115:     "nodeGypPath": "/usr/bin/node-gyp"
116:   }
117: }
118: ```
119: 
120: ## Verification
121: After configuration, run:
122: ```bash
123: npm run rebuild-native-modules

================
File: electron/__tests__/main.path.test.js
================
 1: const path = require('path');
 2: // Assuming normalizePath is exported from main.js or a utils file
 3: // If main.js isn't easily requireable due to Electron dependencies,
 4: // consider extracting normalizePath to a separate utility file.
 5: // For now, let's assume it's exported correctly.
 6: const { normalizePath } = require('../main.js'); // Adjust path if needed
 7: describe('Path Utilities in main.js', () => {
 8:   describe('normalizePath', () => {
 9:     it('should replace backslashes with forward slashes', () => {
10:       expect(normalizePath('C:\\Users\\Test\\Project\\file.txt')).toBe('C:/Users/Test/Project/file.txt');
11:     });
12:     it('should handle mixed slashes', () => {
13:       expect(normalizePath('C:/Users\\Test/Project\\file.txt')).toBe('C:/Users/Test/Project/file.txt');
14:     });
15:     it('should handle already normalized paths', () => {
16:       expect(normalizePath('C:/Users/Test/Project/file.txt')).toBe('C:/Users/Test/Project/file.txt');
17:     });
18:     it('should handle paths without drive letters (relative)', () => {
19:       expect(normalizePath('src\\components\\button.js')).toBe('src/components/button.js');
20:     });
21:     it('should handle UNC paths (Windows network paths)', () => {
22:       expect(normalizePath('\\\\Server\\Share\\Folder\\file.txt')).toBe('//Server/Share/Folder/file.txt');
23:     });
24:     it('should return empty string for empty input', () => {
25:       expect(normalizePath('')).toBe('');
26:     });
27:     it('should return null for null input', () => {
28:       expect(normalizePath(null)).toBe(null);
29:     });
30:     it('should return undefined for undefined input', () => {
31:       expect(normalizePath(undefined)).toBe(undefined);
32:     });
33:   });
34:   describe('Relative Path Calculation (Simulating Windows)', () => {
35:     const rootDirWin = 'C:\\Users\\Test\\Project';
36:     it('should calculate correct relative path for a file in a subdirectory', () => {
37:       const filePathWin = 'C:\\Users\\Test\\Project\\src\\utils\\helper.js';
38:       // Use path.win32.relative to force Windows path logic
39:       const relativeWin = path.win32.relative(rootDirWin, filePathWin); // Expected: 'src\\utils\\helper.js'
40:       expect(normalizePath(relativeWin)).toBe('src/utils/helper.js');
41:     });
42:     it('should calculate correct relative path for a file in the root directory', () => {
43:       const filePathWin = 'C:\\Users\\Test\\Project\\README.md';
44:       const relativeWin = path.win32.relative(rootDirWin, filePathWin); // Expected: 'README.md'
45:       expect(normalizePath(relativeWin)).toBe('README.md');
46:     });
47:     it('should handle paths with spaces', () => {
48:       const rootDirWithSpace = 'C:\\Users\\Test User\\My Project';
49:       const filePathWithSpace = 'C:\\Users\\Test User\\My Project\\src\\app file.js';
50:       const relativeWin = path.win32.relative(rootDirWithSpace, filePathWithSpace); // Expected: 'src\\app file.js'
51:       expect(normalizePath(relativeWin)).toBe('src/app file.js');
52:     });
53:     it('should return an empty string if paths are identical', () => {
54:       const filePathWin = 'C:\\Users\\Test\\Project';
55:       const relativeWin = path.win32.relative(rootDirWin, filePathWin); // Expected: ''
56:       expect(normalizePath(relativeWin)).toBe('');
57:     });
58:     // Note: path.relative behavior when rootDir and filePath are on different drives
59:     // on Windows usually returns the absolute filePath. normalizePath should still work.
60:     it('should handle paths on different drives (returns absolute path)', () => {
61:       const rootDirD = 'D:\\Another\\Folder';
62:       const filePathC = 'C:\\Users\\Test\\Project\\file.txt';
63:       const relativeWin = path.win32.relative(rootDirD, filePathC); // Expected: 'C:\\Users\\Test\\Project\\file.txt'
64:       expect(normalizePath(relativeWin)).toBe('C:/Users/Test/Project/file.txt');
65:     });
66:   });
67: });

================
File: electron/utils/treeSitterUtils.ts
================
  1: /* eslint-disable @typescript-eslint/no-var-requires */
  2: import Parser from 'tree-sitter';
  3: // Tree-sitter language parsers must be loaded using require in Electron
  4: // because they contain native modules that can't be imported dynamically
  5: let JavaScript: Parser.Language | null = null;
  6: let TypeScript: Parser.Language | null = null;
  7: let Python: Parser.Language | null = null;
  8: let Css: Parser.Language | null = null;
  9: let Html: Parser.Language | null = null;
 10: try {
 11:   JavaScript = require('tree-sitter-javascript');
 12: } catch (e) {
 13:   console.warn("Failed to load tree-sitter-javascript parser", e);
 14: }
 15: try {
 16:   // Note: tree-sitter-typescript exports multiple languages
 17:   const tsParser = require('tree-sitter-typescript');
 18:   TypeScript = tsParser.typescript; // Or tsx if needed primarily
 19: } catch (e) {
 20:   console.warn("Failed to load tree-sitter-typescript parser", e);
 21: }
 22: try {
 23:   Python = require('tree-sitter-python');
 24: } catch (e) {
 25:   console.warn("Failed to load tree-sitter-python parser", e);
 26: }
 27: try {
 28:   Css = require('tree-sitter-css');
 29: } catch (e) {
 30:   console.warn("Failed to load tree-sitter-css parser", e);
 31: }
 32: try {
 33:   Html = require('tree-sitter-html');
 34: } catch (e) {
 35:   console.warn("Failed to load tree-sitter-html parser", e);
 36: }
 37: const COMPRESSION_PLACEHOLDER = '/* ... body removed by ContextCraft ... */';
 38: /**
 39:  * Gets the appropriate Tree-sitter language parser based on a simple language identifier.
 40:  * @param language Simple language string (e.g., 'javascript', 'python').
 41:  * @returns The Tree-sitter language parser object or null if unsupported/unavailable.
 42:  */
 43: function getLanguageParser(language: string): Parser.Language | null {
 44:   switch (language?.toLowerCase()) {
 45:     case 'javascript':
 46:     case 'js':
 47:     case 'jsx':
 48:       return JavaScript;
 49:     case 'typescript':
 50:     case 'ts':
 51:     case 'tsx':
 52:        // Make sure to load the correct part of the typescript parser if needed
 53:       return TypeScript; 
 54:     case 'python':
 55:     case 'py':
 56:       return Python;
 57:     case 'css':
 58:       return Css;
 59:     case 'html':
 60:       return Html;
 61:     default:
 62:       console.warn(`Compression/Comment removal not supported for language: ${language}`);
 63:       return null;
 64:   }
 65: }
 66: // --- Queries (Keep these as before) ---
 67: const FUNCTION_BODY_QUERIES: { [language: string]: string } = {
 68:   javascript: `
 69:     [
 70:       (function_declaration body: (_) @body)
 71:       (function body: (_) @body)
 72:       (arrow_function body: (_) @body)
 73:       (method_definition body: (_) @body)
 74:       (class_declaration body: (_) @body)
 75:     ] @function
 76:   `,
 77:   typescript: `
 78:     [
 79:       (function_declaration body: (_) @body)
 80:       (function_signature body: (_) @body)
 81:       (function body: (_) @body)
 82:       (arrow_function body: (_) @body)
 83:       (method_definition body: (_) @body)
 84:       (method_signature body: (_) @body)
 85:       (constructor_type body: (_) @body)
 86:       (class_declaration body: (_) @body)
 87:       (interface_declaration body: (_) @body)
 88:     ] @function
 89:   `,
 90:   python: `
 91:     [
 92:       (function_definition body: (_) @body)
 93:       (class_definition body: (_) @body)
 94:     ] @function
 95:   `,
 96:   css: '',
 97:   html: '',
 98: };
 99: const COMMENT_QUERIES: { [language: string]: string } = {
100:   javascript: `(comment) @comment`,
101:   typescript: `(comment) @comment`,
102:   python: `(comment) @comment`,
103:   css: `(comment) @comment`,
104:   html: `(comment) @comment`,
105: };
106: // --- Core Logic Functions (Exported for main.ts) ---
107: /**
108:  * Main process function to remove comments.
109:  */
110: export function mainProcessRemoveComments(source: string, language: string): string | null {
111:   const langParser = getLanguageParser(language);
112:   const queryStr = COMMENT_QUERIES[language?.toLowerCase()] || '';
113:   if (!langParser || !queryStr) {
114:     return source; // Return original if not supported
115:   }
116:   const parser = new Parser();
117:   try {
118:     parser.setLanguage(langParser);
119:     const tree = parser.parse(source);
120:     const query = new Parser.Query(langParser, queryStr);
121:     const matches = query.captures(tree.rootNode);
122:     if (matches.length === 0) {
123:       return source;
124:     }
125:     matches.sort((a, b) => b.node.endIndex - a.node.endIndex);
126:     let sourceWithoutComments = source;
127:     for (const capture of matches) {
128:       const startIndex = capture.node.startIndex;
129:       const endIndex = capture.node.endIndex;
130:       // Basic whitespace removal logic (can be refined)
131:       let startSlice = startIndex;
132:       let endSlice = endIndex;
133:       while (startSlice > 0 && /[ \t]/.test(sourceWithoutComments[startSlice - 1]) && sourceWithoutComments[startSlice - 1] !== '\n') {
134:           startSlice--;
135:       }
136:       if (startSlice === 0 || sourceWithoutComments[startSlice - 1] === '\n') { 
137:           if (endSlice < sourceWithoutComments.length && sourceWithoutComments[endSlice] === '\n') {
138:              endSlice++;
139:           } else if (startSlice > 0 && sourceWithoutComments[startSlice - 1] === '\n'){
140:               startSlice--; 
141:           }
142:       }
143:       sourceWithoutComments = sourceWithoutComments.slice(0, startSlice) +
144:                               sourceWithoutComments.slice(endSlice);
145:     }
146:     return sourceWithoutComments.trim();
147:   } catch (error) {
148:     console.error(`Error removing comments for language '${language}' in main process:`, error);
149:     return null;
150:   }
151: }
152: /**
153:  * Main process function to compress code (remove function bodies).
154:  */
155: export function mainProcessCompressCode(source: string, language: string): string | null {
156:   const langParser = getLanguageParser(language);
157:   const queryStr = FUNCTION_BODY_QUERIES[language?.toLowerCase()] || '';
158:   if (!langParser || !queryStr) {
159:     console.warn(`Cannot compress in main: No parser or query for language '${language}'.`);
160:     return null; // Return null if not supported to distinguish from unchanged source
161:   }
162:   const parser = new Parser();
163:   try {
164:     parser.setLanguage(langParser);
165:     const tree = parser.parse(source);
166:     const query = new Parser.Query(langParser, queryStr);
167:     const matches = query.matches(tree.rootNode);
168:     const bodyCaptures = matches
169:       .flatMap(match => match.captures)
170:       .filter(capture => capture.name === 'body');
171:     if (bodyCaptures.length === 0) {
172:       return source; // Return original if nothing to compress
173:     }
174:     bodyCaptures.sort((a, b) => b.node.startIndex - a.node.startIndex);
175:     let compressedSource = source;
176:     for (const capture of bodyCaptures) {
177:       const bodyNode = capture.node;
178:       compressedSource = compressedSource.slice(0, bodyNode.startIndex) +
179:                          COMPRESSION_PLACEHOLDER +
180:                          compressedSource.slice(bodyNode.endIndex);
181:     }
182:     return compressedSource;
183:   } catch (error) {
184:     console.error(`Error compressing code for language '${language}' in main process:`, error);
185:     return null;
186:   }
187: }

================
File: electron/excluded-files.js
================
  1: /**
  2:  * Central repository for all file exclusion patterns
  3:  * This file is the single source of truth for determining which files
  4:  * should be excluded from processing in the application.
  5:  */
  6: // Constants for pattern groups to avoid duplication
  7: const BINARY_IMAGE_PATTERNS = [
  8:   "**/*.jpg", "**/*.jpeg", "**/*.png", "**/*.gif", "**/*.ico",
  9:   "**/*.webp", "**/*.svg", "**/*.pdf" 
 10: ];
 11: const BINARY_ARCHIVE_PATTERNS = [
 12:   "**/*.zip", "**/*.tar.gz", "**/*.tgz", "**/*.rar", "**/*.7z"
 13: ];
 14: const BINARY_AUDIO_VIDEO_PATTERNS = [
 15:   "**/*.mp4", "**/*.mov", "**/*.avi", "**/*.mkv", 
 16:   "**/*.mp3", "**/*.wav", "**/*.flac"
 17: ];
 18: const BINARY_FONT_PATTERNS = [
 19:   "**/*.woff", "**/*.woff2", "**/*.ttf", "**/*.eot"
 20: ];
 21: const COMMON_DIR_PATTERNS = [
 22:   "**/node_modules/**", "**/dist/**", "**/build/**", "**/.git/**",
 23:   "**/__pycache__/**", "**/venv/**", "**/.venv/**"
 24: ];
 25: module.exports = {
 26:   /**
 27:    * System exclusions - should never be modified/overridden
 28:    * These are the absolute minimum exclusions for the application to function properly
 29:    */
 30:   systemExclusions: [
 31:     // Common directories
 32:     ...COMMON_DIR_PATTERNS,
 33:     // Compiled Python files (not source)
 34:     "**/*.pyc",
 35:     // Binary files
 36:     ...BINARY_IMAGE_PATTERNS,
 37:     ...BINARY_ARCHIVE_PATTERNS,
 38:     ...BINARY_AUDIO_VIDEO_PATTERNS,
 39:     ...BINARY_FONT_PATTERNS
 40:   ],
 41:   /**
 42:    * Default user patterns - these are restored when user resets to defaults
 43:    * These can be modified by users through the UI
 44:    */
 45:   defaultUserPatterns: `# Default ignore patterns (editable)
 46: # These patterns can be modified in the Ignore Patterns UI
 47: # Common directories
 48: node_modules/
 49: .git/
 50: .github/
 51: dist/
 52: build/
 53: __pycache__/
 54: venv/
 55: .venv/
 56: # Common files
 57: **/*.log
 58: .DS_Store
 59: *.tmp
 60: *.class
 61: # Not excluding Python source files
 62: *.pyc
 63: *.pyo
 64: .env
 65: `,
 66:   /**
 67:    * Files to always exclude by default when a folder is first loaded
 68:    * Users can override these by selecting them manually
 69:    */
 70:   excludedFiles: [
 71:     // NPM/Yarn/Node related
 72:     "package-lock.json",
 73:     "yarn.lock",
 74:     "npm-debug.log*",
 75:     "yarn-debug.log*",
 76:     "yarn-error.log*",
 77:     "pnpm-lock.yaml",
 78:     ".npmrc",
 79:     ".yarnrc",
 80:     ".nvmrc",
 81:     "node_modules/**",
 82:     // JavaScript/TypeScript related
 83:     ".eslintrc*",
 84:     ".prettierrc*",
 85:     "tsconfig*.json",
 86:     "*.d.ts",
 87:     "*.min.js",
 88:     "*.map",
 89:     // Python related
 90:     "__pycache__/**",
 91:     "*.pyc",
 92:     "*.pyo",
 93:     "*.pyd",
 94:     ".pytest_cache/**",
 95:     ".coverage",
 96:     ".python-version",
 97:     "venv/**",
 98:     ".venv/**",
 99:     "*.egg-info/**",
100:     // Go related
101:     "go.sum",
102:     "go.mod",
103:     "vendor/**",
104:     // Java related
105:     "*.class",
106:     "*.jar",
107:     "target/**",
108:     ".gradle/**",
109:     // Ruby related
110:     "Gemfile.lock",
111:     ".bundle/**",
112:     // PHP related
113:     "composer.lock",
114:     "vendor/**",
115:     // Rust related
116:     "Cargo.lock",
117:     "target/**",
118:     // .NET related
119:     "bin/**",
120:     "obj/**",
121:     "*.suo",
122:     "*.user",
123:     // Binary and image files
124:     "*.jpg",
125:     "*.jpeg",
126:     "*.png",
127:     "*.gif",
128:     "*.ico",
129:     "*.webp",
130:     "*.svg",
131:     "*.pdf",
132:     "*.zip",
133:     "*.tar.gz",
134:     "*.tgz",
135:     "*.rar",
136:     // IDE and editor files
137:     ".idea/**",
138:     ".vscode/**",
139:     "*.swp",
140:     "*.swo",
141:     ".DS_Store",
142:     // Build output
143:     "dist/**",
144:     "build/**",
145:     "out/**",
146:     ".next/**",
147:     // Database files
148:     "*.sqlite",
149:     "*.db",
150:     // Environment and secrets
151:     ".env*",
152:     ".aws/**",
153:     "*.pem",
154:     "*.key",
155:     // Docker related
156:     "docker-compose.override.yml",
157:     // Misc
158:     ".gitlab/**",
159:   ],
160:   /**
161:    * File extensions to always mark as binary/unselectable
162:    * The app already has binary detection, but this ensures specific types
163:    * are always treated as binary regardless of content detection
164:    */
165:   binaryExtensions: [
166:     // Images (including .svg which might not be detected as binary)
167:     ".svg",
168:     ".jpg",
169:     ".jpeg",
170:     ".png",
171:     ".gif",
172:     ".bmp",
173:     ".tiff",
174:     ".ico",
175:     ".webp",
176:     // Other binary formats
177:     ".pdf",
178:     ".doc",
179:     ".docx",
180:     ".xls",
181:     ".xlsx",
182:     ".ppt",
183:     ".pptx",
184:   ]
185: };

================
File: electron/preload.js
================
  1: // Preload script
  2: const { contextBridge, ipcRenderer, shell } = require("electron");
  3: // Define valid channels in one place for better maintainability
  4: const VALID_CHANNELS = {
  5:   send: [
  6:     "open-folder", 
  7:     "request-file-list", 
  8:     "load-ignore-patterns", 
  9:     "save-ignore-patterns",
 10:     "reset-ignore-patterns",
 11:     "debug-file-selection", 
 12:     "cancel-directory-loading",
 13:     "reload-file-list"
 14:   ],
 15:   receive: [
 16:     "folder-selected", 
 17:     "file-list-data", 
 18:     "file-processing-status", 
 19:     "ignore-patterns-loaded", 
 20:     "ignore-patterns-saved",
 21:     "startup-mode",
 22:     "file-changed"
 23:   ],
 24:   invoke: [
 25:     "open-folder",
 26:     "read-file",
 27:     "request-file-list",
 28:     "save-ignore-patterns",
 29:     "load-ignore-patterns",
 30:     "reset-ignore-patterns",
 31:     "clear-local-ignore-patterns",
 32:     "get-file-content",
 33:     "test-ignore-patterns",
 34:     "compress-code",
 35:     "remove-comments",
 36:     "count-tokens",
 37:     "get-file-metadata"
 38:   ]
 39: };
 40: // Helper function to ensure data is serializable
 41: function ensureSerializable(data) {
 42:   if (data === null || data === undefined) {
 43:     return data;
 44:   }
 45:   // Handle primitive types directly
 46:   if (typeof data !== "object") {
 47:     return data;
 48:   }
 49:   // For arrays, map each item
 50:   if (Array.isArray(data)) {
 51:     return data.map(ensureSerializable);
 52:   }
 53:   // For objects, create a new object with serializable properties
 54:   const result = {};
 55:   for (const key in data) {
 56:     if (Object.prototype.hasOwnProperty.call(data, key)) {
 57:       // Skip functions or symbols which are not serializable
 58:       if (typeof data[key] === "function" || typeof data[key] === "symbol") {
 59:         continue;
 60:       }
 61:       // Recursively process nested objects
 62:       result[key] = ensureSerializable(data[key]);
 63:     }
 64:   }
 65:   return result;
 66: }
 67: // Expose protected methods that allow the renderer process to use
 68: // the ipcRenderer without exposing the entire object
 69: contextBridge.exposeInMainWorld("electron", {
 70:   // Direct API methods
 71:   send: (channel, data) => {
 72:     if (VALID_CHANNELS.send.includes(channel)) {
 73:       const serializedData = ensureSerializable(data);
 74:       ipcRenderer.send(channel, serializedData);
 75:     }
 76:   },
 77:   receive: (channel, func) => {
 78:     if (VALID_CHANNELS.receive.includes(channel)) {
 79:       ipcRenderer.removeAllListeners(channel);
 80:       ipcRenderer.on(channel, (event, ...args) => func(...args));
 81:     }
 82:   },
 83:   // Add specific invoke methods for clarity and type safety (optional but good practice)
 84:   openFolder: () => ipcRenderer.invoke('open-folder'),
 85:   readFile: (filePath) => ipcRenderer.invoke('read-file', filePath),
 86:   requestFileList: (data) => {
 87:     // Use send instead of invoke for request-file-list
 88:     const serializedData = ensureSerializable(data);
 89:     ipcRenderer.send('request-file-list', serializedData);
 90:     return Promise.resolve(true); // Return a resolved promise for backward compatibility
 91:   },
 92:   saveIgnorePatterns: (data) => ipcRenderer.invoke('save-ignore-patterns', ensureSerializable(data)),
 93:   loadIgnorePatterns: (data) => ipcRenderer.invoke('load-ignore-patterns', ensureSerializable(data)),
 94:   resetIgnorePatterns: (data) => ipcRenderer.invoke('reset-ignore-patterns', ensureSerializable(data)),
 95:   clearLocalIgnorePatterns: (folderPath) => ipcRenderer.invoke('clear-local-ignore-patterns', folderPath),
 96:   getFileContent: (filePath) => ipcRenderer.invoke('get-file-content', filePath),
 97:   testIgnorePatterns: (data) => ipcRenderer.invoke('test-ignore-patterns', ensureSerializable(data)),
 98:   // Add the new methods for compression and comment removal
 99:   compressCode: (source, language) => {
100:     if (VALID_CHANNELS.invoke.includes('compress-code')) {
101:       // Pass data as an object matching the handler's expectation
102:       return ipcRenderer.invoke('compress-code', { source, language }); 
103:     }
104:     return Promise.reject(new Error('Invalid channel: compress-code'));
105:   },
106:   removeComments: (source, language, keepDocstrings) => {
107:     if (VALID_CHANNELS.invoke.includes('remove-comments')) {
108:       // Pass data as an object matching the handler's expectation
109:       return ipcRenderer.invoke('remove-comments', { source, language, keepDocstrings });
110:     }
111:     return Promise.reject(new Error('Invalid channel: remove-comments'));
112:   },
113:   // Add countTokens method
114:   countTokens: (text) => {
115:     if (VALID_CHANNELS.invoke.includes('count-tokens')) {
116:       return ipcRenderer.invoke('count-tokens', text);
117:     }
118:     return Promise.reject(new Error('Invalid channel: count-tokens'));
119:   },
120:   // Add getFileMetadata method for file change detection
121:   getFileMetadata: (filePath) => {
122:     if (VALID_CHANNELS.invoke.includes('get-file-metadata')) {
123:       return ipcRenderer.invoke('get-file-metadata', filePath);
124:     }
125:     return Promise.reject(new Error('Invalid channel: get-file-metadata'));
126:   },
127:   // Add file processing status listener
128:   onFileProcessingStatus: (callback) => {
129:     if (!callback || typeof callback !== 'function') {
130:       console.error('Invalid callback provided to onFileProcessingStatus');
131:       return;
132:     }
133:     // Use the standard pattern used by other listeners
134:     if (VALID_CHANNELS.receive.includes('file-processing-status')) {
135:       ipcRenderer.removeAllListeners('file-processing-status');
136:       ipcRenderer.on('file-processing-status', (event, statusData) => {
137:         try {
138:           callback(statusData);
139:         } catch (err) {
140:           console.error('Error in file processing status callback:', err);
141:         }
142:       });
143:     }
144:   },
145:   // Add openExternal function to open links in the default browser
146:   openExternal: (url) => {
147:     if (typeof url === 'string' && (url.startsWith('https://') || url.startsWith('http://'))) {
148:       return shell.openExternal(url);
149:     }
150:     return Promise.reject(new Error('Invalid URL provided to openExternal'));
151:   },
152:   // Keep the generic ipcRenderer object for potential backward compatibility or other uses
153:   // BUT favor using the specific methods above for better code clarity.
154:   ipcRenderer: {
155:     send: (channel, data) => {
156:       if (VALID_CHANNELS.send.includes(channel)) {
157:         const serializedData = ensureSerializable(data);
158:         ipcRenderer.send(channel, serializedData);
159:       }
160:     },
161:     invoke: (channel, data) => {
162:       if (VALID_CHANNELS.invoke.includes(channel)) {
163:         // Ensure data is serializable before invoking
164:         const serializedData = ensureSerializable(data);
165:         return ipcRenderer.invoke(channel, serializedData);
166:       }
167:       return Promise.reject(new Error(`Invalid channel: ${channel}`));
168:     },
169:     on: (channel, func) => {
170:       if (VALID_CHANNELS.receive.includes(channel)) {
171:         const subscription = (event, ...args) => {
172:           const serializedArgs = args.map(ensureSerializable);
173:           func(...serializedArgs);
174:         };
175:         ipcRenderer.on(channel, subscription);
176:         return subscription;
177:       }
178:     },
179:     removeListener: (channel, func) => {
180:       if (VALID_CHANNELS.receive.includes(channel)) {
181:         ipcRenderer.removeListener(channel, func);
182:       }
183:     },
184:   },
185: });

================
File: src/__tests__/buildWorkflow.test.ts
================
 1: import fs from 'fs';
 2: import path from 'path';
 3: import yaml from 'js-yaml';
 4: describe('GitHub Actions build.yml workflow', () => {
 5:   let workflow: any;
 6:   beforeAll(() => {
 7:     const workflowPath = path.resolve(__dirname, '../../.github/workflows/build.yml');
 8:     const content = fs.readFileSync(workflowPath, 'utf8');
 9:     workflow = yaml.load(content);
10:   });
11:   test('should define validate, build_mac and build_windows jobs', () => {
12:     expect(workflow.jobs.validate).toBeDefined();
13:     expect(workflow.jobs.build_mac).toBeDefined();
14:     expect(workflow.jobs.build_windows).toBeDefined();
15:   });
16:   test('validate job runs on ubuntu-latest', () => {
17:     expect(workflow.jobs.validate['runs-on']).toBe('ubuntu-latest');
18:   });
19:   test('build_mac runs on macos-latest', () => {
20:     expect(workflow.jobs.build_mac['runs-on']).toBe('macos-latest');
21:   });
22:   test('build_windows runs on windows-latest', () => {
23:     expect(workflow.jobs.build_windows['runs-on']).toBe('windows-latest');
24:   });
25:   test('build_mac env includes CXXFLAGS set to --std=c++20', () => {
26:     const env = workflow.jobs.build_mac.env;
27:     expect(env.CXXFLAGS).toBe('--std=c++20');
28:   });
29:   test('build_windows env includes CXXFLAGS for Windows', () => {
30:     const env = workflow.jobs.build_windows.env;
31:     expect(env.CXXFLAGS).toBe('/std:c++20');
32:   });
33:   test('release step should publish immediately (not draft)', () => {
34:     const steps = workflow.jobs.build_mac.steps;
35:     const releaseStep = steps.find((step: any) => step.uses === 'softprops/action-gh-release@v1');
36:     expect(releaseStep).toBeDefined();
37:     expect(releaseStep.with.draft).toBe(false);
38:   });
39: });

================
File: src/components/ui/Dropdown/Dropdown.module.css
================
  1: .dropdown {
  2:   position: relative;
  3:   display: inline-flex;
  4:   vertical-align: middle;
  5: }
  6: .button {
  7:   display: inline-flex;
  8:   align-items: center;
  9:   justify-content: center;
 10:   gap: 0.5rem;
 11:   padding: 0.5rem;
 12:   font-size: 0.875rem;
 13:   color: var(--icon-color);
 14:   border-radius: var(--radius);
 15:   cursor: pointer;
 16:   transition: all 0.15s ease;
 17:   background: transparent;
 18:   border: 1px solid var(--border-color);
 19:   height: 32px;
 20:   width: 32px;
 21: }
 22: .button:hover:not(:disabled) {
 23:   background: var(--hover-color);
 24: }
 25: .button:focus-visible {
 26:   outline: 2px solid var(--ring-color);
 27:   outline-offset: -1px;
 28: }
 29: .button.active {
 30:   background: var(--hover-color);
 31: }
 32: .buttonLabel {
 33:   flex: 1;
 34:   text-align: left;
 35:   overflow: hidden;
 36:   text-overflow: ellipsis;
 37:   white-space: nowrap;
 38: }
 39: .chevron {
 40:   color: var(--text-secondary);
 41:   transition: transform 0.2s ease;
 42:   width: 16px;
 43:   height: 16px;
 44: }
 45: .chevronOpen {
 46:   transform: rotate(180deg);
 47: }
 48: .menu {
 49:   position: absolute;
 50:   top: 100%;
 51:   left: 0;
 52:   z-index: var(--z-index-dropdown);
 53:   min-width: 180px;
 54:   margin-top: 0.25rem;
 55:   padding: 0.375rem;
 56:   background: var(--background-primary);
 57:   border: 1px solid var(--border-color);
 58:   border-radius: var(--radius);
 59:   box-shadow: var(--shadow-md);
 60:   overflow-y: auto;
 61:   max-height: 300px;
 62:   animation: dropdownFadeIn 0.15s ease;
 63: }
 64: .option {
 65:   display: flex;
 66:   align-items: center;
 67:   gap: 0.5rem;
 68:   padding: 0.5rem 0.75rem;
 69:   font-size: 0.875rem;
 70:   color: var(--text-primary);
 71:   cursor: pointer;
 72:   border-radius: var(--radius);
 73:   transition: background-color 0.1s ease;
 74:   user-select: none;
 75: }
 76: .option:hover:not(.disabled) {
 77:   background: var(--hover-color);
 78: }
 79: .option:focus {
 80:   outline: none;
 81:   background: var(--hover-color);
 82: }
 83: .option.selected {
 84:   background: var(--background-selected);
 85:   color: var(--text-primary);
 86: }
 87: .option.disabled {
 88:   opacity: 0.5;
 89:   cursor: not-allowed;
 90: }
 91: .optionIcon {
 92:   flex-shrink: 0;
 93:   color: var(--icon-color);
 94:   width: 16px;
 95:   height: 16px;
 96: }
 97: .optionLabel {
 98:   flex: 1;
 99:   white-space: nowrap;
100:   overflow: hidden;
101:   text-overflow: ellipsis;
102:   font-size: 11px;
103: }
104: .checkmark {
105:   color: var(--accent-color);
106: }
107: /* Size variants */
108: .sm .button {
109:   height: 28px;
110:   width: 28px;
111:   padding: 0.25rem;
112: }
113: .lg .button {
114:   height: 36px;
115:   width: 36px;
116:   padding: 0.75rem;
117: }
118: @keyframes dropdownFadeIn {
119:   from {
120:     opacity: 0;
121:     transform: translateY(4px);
122:   }
123:   to {
124:     opacity: 1;
125:     transform: translateY(0);
126:   }
127: }
128: /* Dark mode enhancements */
129: :global(.dark-mode) .menu {
130:   background: var(--dropdown-menu-background);
131:   border-color: var(--border-color);
132: }
133: :global(.dark-mode) .option:hover:not(.disabled) {
134:   background: var(--dropdown-item-hover);
135: }
136: /* Improved focus styles for keyboard navigation */
137: .option:focus-visible {
138:   outline: none;
139:   box-shadow: 0 0 0 2px var(--background-primary), 0 0 0 4px var(--ring-color);
140: }
141: /* Add subtle divider between groups of options if needed */
142: .option + .option {
143:   border-top: 1px solid transparent;
144: }
145: .option:hover + .option {
146:   border-top-color: transparent;
147: }

================
File: src/components/ui/DropdownMenu/DropdownMenu.module.css
================
  1: .dropdownMenu {
  2:   position: relative;
  3:   display: inline-block;
  4:   width: auto;
  5:   max-width: 100%;
  6: }
  7: .dropdownTrigger {
  8:   display: flex;
  9:   align-items: center;
 10:   justify-content: space-between;
 11:   width: 100%;
 12:   padding: 0.35rem 0.75rem;
 13:   background-color: var(--background-primary);
 14:   border: 1px solid var(--border-color);
 15:   border-radius: var(--radius);
 16:   color: var(--text-primary);
 17:   font-size: 11px;
 18:   cursor: pointer;
 19:   transition: all 0.15s ease;
 20:   text-align: left;
 21:   min-height: 28px;
 22: }
 23: .dropdownTrigger:hover:not(:disabled) {
 24:   background-color: var(--hover-color);
 25: }
 26: .dropdownTrigger:focus {
 27:   outline: none;
 28:   box-shadow: 0 0 0 2px var(--focus-ring-color);
 29: }
 30: .dropdownTrigger:disabled {
 31:   opacity: 0.5;
 32:   cursor: not-allowed;
 33: }
 34: .dropdownTriggerOpen {
 35:   background-color: var(--hover-color);
 36: }
 37: .dropdownContent {
 38:   position: fixed;
 39:   min-width: 12rem;
 40:   width: max-content;
 41:   max-width: 300px;
 42:   padding: 0.5rem;
 43:   background-color: var(--background-primary);
 44:   border: 1px solid var(--border-color);
 45:   border-radius: var(--radius);
 46:   box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
 47:   z-index: 1000;
 48:   max-height: 80vh;
 49:   overflow-y: auto;
 50:   animation: dropdownIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
 51:   will-change: transform, opacity;
 52: }
 53: .dropdownContent.closing {
 54:   animation: dropdownOut 0.15s ease-in forwards;
 55: }
 56: .dropdownItem {
 57:   display: flex;
 58:   align-items: center;
 59:   gap: 0.5rem;
 60:   padding: 0.35rem 0.75rem;
 61:   color: var(--text-primary);
 62:   font-size: 10px;
 63:   cursor: pointer;
 64:   border-radius: 0.375rem;
 65:   transition: all 0.1s ease;
 66:   user-select: none;
 67: }
 68: .dropdownItem:hover:not(.disabled) {
 69:   background-color: var(--hover-color);
 70: }
 71: .itemIcon {
 72:   display: flex;
 73:   align-items: center;
 74:   justify-content: center;
 75:   width: 1rem;
 76:   height: 1rem;
 77:   opacity: 0.6;
 78:   flex-shrink: 0;
 79: }
 80: .itemText {
 81:   flex: 1;
 82:   white-space: nowrap;
 83:   overflow: hidden;
 84:   text-overflow: ellipsis;
 85: }
 86: .buttonLabel {
 87:   flex: 1;
 88:   text-align: left;
 89:   overflow: hidden;
 90:   text-overflow: ellipsis;
 91:   white-space: nowrap;
 92:   margin-right: 0.5rem;
 93:   max-width: 220px;
 94: }
 95: .accordionIcon {
 96:   transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
 97:   position: relative;
 98:   color: var(--text-secondary);
 99:   width: 16px;
100:   height: 16px;
101:   opacity: 0.6;
102: }
103: .accordionIcon path:last-child {
104:   transform-origin: center;
105:   transition: opacity 0.2s ease;
106: }
107: .accordionIcon.rotated {
108:   transform: rotate(180deg);
109: }
110: .accordionIcon.rotated path:last-child {
111:   opacity: 0;
112: }
113: .sm {
114:   height: 24px;
115:   font-size: 10px;
116:   padding: 0.2rem 0.5rem;
117: }
118: .md {
119:   height: 28px;
120:   font-size: 11px;
121:   padding: 0.25rem 0.75rem;
122: }
123: .lg {
124:   height: 32px;
125:   font-size: 12px;
126:   padding: 0.35rem 1rem;
127: }
128: @keyframes dropdownIn {
129:   from {
130:     opacity: 0;
131:     transform: translateY(-4px) scale(0.97);
132:   }
133:   to {
134:     opacity: 1;
135:     transform: translateY(0) scale(1);
136:   }
137: }
138: @keyframes dropdownOut {
139:   from {
140:     opacity: 1;
141:     transform: translateY(0) scale(1);
142:   }
143:   to {
144:     opacity: 0;
145:     transform: translateY(-4px) scale(0.97);
146:   }
147: }
148: .dropdownContent[data-side="top"] {
149:   transform-origin: bottom;
150:   animation: dropdownInTop 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
151: }
152: .dropdownContent[data-side="top"].closing {
153:   animation: dropdownOutTop 0.15s ease-in forwards;
154: }
155: .dropdownContent[data-side="bottom"] {
156:   transform-origin: top;
157: }
158: @keyframes dropdownInTop {
159:   from {
160:     opacity: 0;
161:     transform: translateY(4px) scale(0.97);
162:   }
163:   to {
164:     opacity: 1;
165:     transform: translateY(0) scale(1);
166:   }
167: }
168: @keyframes dropdownOutTop {
169:   from {
170:     opacity: 1;
171:     transform: translateY(0) scale(1);
172:   }
173:   to {
174:     opacity: 0;
175:     transform: translateY(4px) scale(0.97);
176:   }
177: }
178: @media (max-width: 768px) {
179:   .dropdownContent {
180:     max-width: calc(100vw - 2rem);
181:   }
182: }
183: :global(.dark) .dropdownContent {
184:   box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
185: }
186: :global(.dark) .dropdownItem:hover:not(.disabled) {
187:   background-color: var(--hover-color);
188: }

================
File: src/components/ui/Toast/toastUtils.ts
================
 1: import { toast } from 'sonner';
 2: import styles from './Toast.module.css';
 3: /**
 4:  * Helper functions to show different types of toasts
 5:  */
 6: export const showToast = {
 7:   /**
 8:    * Show a default toast notification
 9:    */
10:   default: (
11:     title: string, 
12:     description?: string, 
13:     action?: { label: string; onClick: () => void }
14:   ) => {
15:     return toast(title, {
16:       description,
17:       action: action ? {
18:         label: action.label,
19:         onClick: action.onClick
20:       } : undefined,
21:       icon: null,
22:       className: !description ? styles.singleLineToast : ''
23:     });
24:   },
25:   /**
26:    * Show a success toast notification
27:    */
28:   success: (title: string, description?: string) => {
29:     return toast.success(title, { 
30:       description,
31:       icon: null,
32:       className: !description ? styles.singleLineToast : ''
33:     });
34:   },
35:   /**
36:    * Show an error toast notification
37:    */
38:   error: (title: string, description?: string) => {
39:     return toast.error(title, { 
40:       description,
41:       icon: null,
42:       className: !description ? styles.singleLineToast : ''
43:     });
44:   },
45:   /**
46:    * Show a warning toast notification
47:    */
48:   warning: (title: string, description?: string) => {
49:     return toast.warning(title, { 
50:       description,
51:       icon: null,
52:       className: !description ? styles.singleLineToast : ''
53:     });
54:   },
55:   /**
56:    * Show an info toast notification
57:    */
58:   info: (title: string, description?: string) => {
59:     return toast.info(title, { 
60:       description,
61:       icon: null,
62:       className: !description ? styles.singleLineToast : ''
63:     });
64:   },
65:   /**
66:    * Show a promise toast that updates with promise resolution
67:    */
68:   promise: <T,>(
69:     promise: Promise<T>,
70:     messages: {
71:       loading: string;
72:       success: string | ((data: T) => string);
73:       error: string | ((error: Error) => string);
74:       icon?: null;
75:     }
76:   ) => {
77:     return toast.promise(promise, {
78:       ...messages,
79:       icon: null
80:     });
81:   }
82: };

================
File: src/components/ui/TabsComponents.tsx
================
1: // Export all tab components from a single file
2: import React from 'react';
3: import { Tabs } from './Tabs';
4: // Adding a component to satisfy the react-refresh/only-export-components rule
5: const TabsWrapper = (props) => <Tabs {...props} />;
6: // eslint-disable-next-line react-refresh/only-export-components
7: export * from './Tabs/index';
8: export { TabsWrapper };

================
File: src/components/GuideModal.module.css
================
 1: .guideContent {
 2:   padding: 8px 4px;
 3:   font-size: 14px;
 4:   line-height: 1.5;
 5:   color: var(--text-primary);
 6: }
 7: .sectionTitle {
 8:   font-size: 16px;
 9:   font-weight: 600;
10:   margin: 16px 0 8px;
11:   color: var(--text-primary);
12: }
13: .guideList {
14:   margin: 0 0 16px;
15:   padding-left: 24px;
16: }
17: .guideList li {
18:   margin-bottom: 8px;
19: }
20: .guideList strong {
21:   font-weight: 600;
22:   color: var(--accent-color);
23: }
24: .wikiSection {
25:   margin-top: 24px;
26:   padding: 16px;
27:   background-color: var(--background-secondary);
28:   border-radius: 8px;
29:   text-align: center;
30: }
31: .wikiSection p {
32:   margin-bottom: 16px;
33:   color: var(--text-secondary);
34: }
35: .wikiButton {
36:   display: inline-flex;
37:   align-items: center;
38:   justify-content: center;
39:   gap: 8px;
40:   padding: 8px 16px;
41:   min-width: 240px;
42: }

================
File: src/components/IgnorePatterns.module.css
================
  1: .modal {
  2:   position: fixed;
  3:   top: 0;
  4:   left: 0;
  5:   width: 100%;
  6:   height: 100%;
  7:   background-color: rgba(0, 0, 0, 0.5);
  8:   display: flex;
  9:   justify-content: center;
 10:   align-items: center;
 11:   z-index: var(--z-index-modal);
 12:   backdrop-filter: blur(4px);
 13:   animation: fadeIn 0.25s ease-out;
 14: }
 15: .content {
 16:   background-color: var(--background-primary);
 17:   border-radius: 0.75rem;
 18:   width: 90%;
 19:   max-width: 700px;
 20:   max-height: 85vh;
 21:   padding: 1rem;
 22:   box-shadow: var(--shadow-lg);
 23:   overflow-y: auto;
 24:   animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1);
 25:   border: 1px solid var(--border-color);
 26:   scrollbar-width: thin;
 27:   scrollbar-color: var(--border-color) transparent;
 28: }
 29: .content::-webkit-scrollbar {
 30:   width: 6px;
 31: }
 32: .content::-webkit-scrollbar-track {
 33:   background: transparent;
 34: }
 35: .content::-webkit-scrollbar-thumb {
 36:   background-color: var(--border-color);
 37:   border-radius: 4px;
 38:   border: 2px solid var(--background-primary);
 39: }
 40: .header {
 41:   display: flex;
 42:   justify-content: space-between;
 43:   align-items: center;
 44:   margin-bottom: 12px;
 45: }
 46: .header h2 {
 47:   margin: 0;
 48:   font-size: 1.2rem;
 49:   color: var(--text-primary);
 50:   font-weight: 600;
 51: }
 52: .description {
 53:   margin-bottom: 12px;
 54:   font-size: 0.75rem;
 55:   color: var(--text-secondary);
 56:   line-height: 1.4;
 57: }
 58: .scopeSelector {
 59:   display: flex;
 60:   margin-bottom: 10px;
 61:   border-bottom: 1px solid var(--border-color);
 62:   padding: 0 4px;
 63:   gap: 1px;
 64: }
 65: .scopeBtn {
 66:   flex: 1;
 67:   border-radius: var(--radius) var(--radius) 0 0 !important;
 68:   font-size: 0.8rem !important;
 69:   padding: 6px 10px !important;
 70:   transition: all 0.15s ease-out;
 71: }
 72: .scopeBtn:first-child {
 73:   border-top-right-radius: 0 !important;
 74: }
 75: .scopeBtn:last-child {
 76:   border-top-left-radius: 0 !important;
 77: }
 78: .scopeBtn:hover {
 79:   background-color: var(--hover-color);
 80:   opacity: 0.9;
 81: }
 82: .scopeBtn.active {
 83:   font-weight: 500 !important;
 84:   position: relative;
 85: }
 86: .scopeBtn.active::after {
 87:   content: "";
 88:   position: absolute;
 89:   bottom: -1px;
 90:   left: 0;
 91:   width: 100%;
 92:   height: 2px;
 93:   background-color: var(--accent-color);
 94: }
 95: .scopeDescription {
 96:   margin-bottom: 12px;
 97:   font-size: 0.75rem;
 98:   color: var(--text-secondary);
 99:   padding: 0 6px;
100: }
101: .folderSelector {
102:   margin-bottom: 12px;
103: }
104: .folderSelector label {
105:   display: block;
106:   margin-bottom: 4px;
107:   font-size: 0.8rem;
108:   font-weight: 500;
109:   color: var(--text-primary);
110: }
111: .customSelect {
112:   position: relative;
113:   width: 100%;
114:   cursor: pointer;
115: }
116: .selectedValue {
117:   display: flex;
118:   justify-content: space-between;
119:   align-items: center;
120:   padding: 6px 8px;
121:   background-color: var(--background-secondary);
122:   border: 1px solid var(--border-color);
123:   border-radius: var(--radius);
124:   font-size: 0.7rem;
125:   transition: border-color 0.2s;
126: }
127: .selectedValue:hover {
128:   border-color: var(--accent-color);
129: }
130: .chevron {
131:   transition: transform 0.2s;
132: }
133: .chevron.open {
134:   transform: rotate(180deg);
135: }
136: .optionsContainer {
137:   position: absolute;
138:   top: 100%;
139:   left: 0;
140:   right: 0;
141:   background-color: var(--background-primary);
142:   border: 1px solid var(--border-color);
143:   border-radius: var(--radius);
144:   box-shadow: var(--shadow-md);
145:   z-index: var(--z-index-dropdown);
146:   max-height: 180px;
147:   overflow-y: auto;
148: }
149: .option {
150:   padding: 6px 8px;
151:   font-size: 0.6rem;
152:   cursor: pointer;
153: }
154: .option:hover {
155:   background-color: var(--hover-color);
156: }
157: .pathDisplay {
158:   margin-top: 3px;
159:   font-size: 0.6rem;
160:   color: var(--text-secondary);
161:   font-family: monospace;
162: }
163: .patternsSection {
164:   margin-bottom: 16px;
165: }
166: .patternsInput:focus {
167:   outline: none;
168:   border-color: var(--accent-color);
169:   box-shadow: 0 0 0 1px var(--accent-color);
170: }
171: /* Styles for the react-simple-code-editor */
172: .editorContainer {
173:   position: relative;
174:   border: 1px solid var(--border-color);
175:   border-radius: var(--radius);
176:   overflow: hidden;
177:   margin-bottom: 12px;
178:   background-color: var(--background-secondary);
179: }
180: .patternsEditor {
181:   background-color: var(--background-secondary) !important;
182:   font-family: monospace !important;
183:   font-size: 0.75rem !important;
184:   line-height: 1.4 !important;
185:   padding: 8px !important;
186:   min-height: 140px !important;
187:   max-height: 200px !important;
188:   overflow-y: auto !important;
189:   position: relative !important;
190: }
191: .patternsEditor:focus-within,
192: .editorContainer:focus-within {
193:   border-color: var(--accent-color);
194:   box-shadow: 0 0 0 1px var(--accent-color);
195: }
196: .patternsEditorTextarea {
197:   font-family: monospace !important;
198:   padding: 8px !important;
199:   margin: 0 !important;
200:   position: absolute !important;
201:   top: 0 !important;
202:   left: 0 !important;
203:   height: 100% !important;
204:   width: 100% !important;
205:   resize: none !important;
206:   overflow: auto !important;
207:   white-space: pre !important;
208:   tab-size: 2 !important;
209:   line-height: 1.4 !important;
210:   letter-spacing: normal !important;
211:   text-rendering: auto !important;
212:   color: inherit !important;
213:   background-color: transparent !important;
214:   caret-color: var(--text-primary) !important;
215:   outline: none !important;
216: }
217: .patternsEditor::-webkit-scrollbar { width: var(--scrollbar-width); }
218: .patternsEditor::-webkit-scrollbar-track { background: var(--scrollbar-track-color); }
219: .patternsEditor::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb-color); border-radius: var(--radius-full); }
220: .patternsEditor::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover-color); }
221: .patternsEditor { scrollbar-width: thin; scrollbar-color: var(--scrollbar-thumb-color) var(--scrollbar-track-color); }
222: .patternsEditor .token.comment,
223: .patternsEditor .token.prolog,
224: .patternsEditor .token.doctype,
225: .patternsEditor .token.cdata {
226:   color: var(--text-secondary);
227:   font-style: italic;
228: }
229: .patternsEditor .token.punctuation {
230:   color: var(--text-secondary);
231: }
232: .patternsEditor pre,
233: .patternsEditor code {
234:   font-family: monospace !important;
235:   font-size: 0.75rem !important;
236:   line-height: 1.4 !important;
237:   padding: 0 !important;
238:   margin: 0 !important;
239:   white-space: pre !important;
240:   tab-size: 2 !important;
241: }
242: .patternComment {
243:   color: var(--text-secondary) !important;
244:   font-style: italic;
245: }
246: .patternsHelp {
247:   margin-top: 8px;
248:   font-size: 0.7rem;
249:   color: var(--text-secondary);
250: }
251: .patternsHelp p {
252:   margin: 4px 0;
253: }
254: .modalStatus {
255:   margin-bottom: 12px;
256:   font-size: 0.8rem;
257: }
258: .unsaved {
259:   color: var(--warning-color);
260:   font-style: italic;
261: }
262: .modalActions {
263:   display: flex;
264:   justify-content: space-between;
265:   margin-top: 12px;
266:   gap: 6px;
267: }
268: .modalActions button {
269:   font-size: 0.75rem !important;
270:   padding: 5px 8px !important;
271: }
272: .destructiveIcon {
273:   color: var(--error-color);
274:   margin-right: 4px;
275:   vertical-align: middle;
276:   width: 14px;
277:   height: 14px;
278: }
279: /* We'll override these with our Button component */
280: .systemPatterns {
281:   margin-top: 8px;
282:   margin-bottom: 12px;
283:   padding: 8px;
284:   background-color: var(--background-secondary);
285:   border: 1px solid var(--border-color);
286:   border-radius: var(--radius);
287: }
288: .systemPatterns h3 {
289:   margin: 0 0 8px 0;
290:   font-size: 0.85rem;
291:   font-weight: 600;
292: }
293: .systemPatternsList {
294:   margin: 0;
295:   padding: 0;
296:   list-style: none;
297:   max-height: 200px;
298:   overflow-y: auto;
299: }
300: .systemPatternItem {
301:   display: flex;
302:   align-items: center;
303:   padding: 4px 6px;
304:   margin-bottom: 2px;
305:   border-radius: 3px;
306:   font-size: 0.7rem;
307:   font-family: monospace;
308:   transition: background-color 0.15s;
309: }
310: .systemPatternItem:hover {
311:   background-color: var(--hover-color);
312: }
313: .toggleButton {
314:   margin-right: 6px;
315:   border: none;
316:   background: none;
317:   cursor: pointer;
318:   display: flex;
319:   align-items: center;
320:   justify-content: center;
321:   padding: 2px;
322:   border-radius: 3px;
323:   width: 20px;
324:   height: 20px;
325:   color: var(--text-primary);
326:   transition: background-color 0.2s, color 0.2s;
327: }
328: .toggleButton:hover {
329:   background-color: var(--hover-color);
330:   color: var(--accent-color);
331: }
332: .disabledPattern {
333:   text-decoration: line-through;
334:   opacity: 0.5;
335: }
336: .previewSection {
337:   margin-top: 12px;
338:   margin-bottom: 12px;
339: }
340: .previewContainer {
341:   max-height: 180px;
342:   overflow-y: auto;
343:   padding: 8px;
344:   border: 1px solid var(--border-color);
345:   border-radius: var(--radius);
346:   background-color: var(--background-secondary);
347:   font-family: monospace;
348:   font-size: 0.7rem;
349: }
350: /* Make the scrollbar look consistent */
351: .previewContainer::-webkit-scrollbar {
352:   width: 6px;
353: }
354: .previewContainer::-webkit-scrollbar-track {
355:   background: transparent;
356: }
357: .previewContainer::-webkit-scrollbar-thumb {
358:   background-color: var(--border-color-lighter);
359:   border-radius: 3px;
360: }
361: .previewContainer {
362:   scrollbar-width: thin;
363:   scrollbar-color: var(--border-color-lighter) transparent;
364: }
365: .previewHeader {
366:   display: flex;
367:   justify-content: space-between;
368:   align-items: center;
369:   margin-bottom: 6px;
370:   font-size: 0.75rem;
371:   font-weight: 600;
372: }
373: .patternCount {
374:   font-size: 0.65rem;
375:   color: var(--text-secondary);
376:   padding: 2px 4px;
377:   border-radius: 3px;
378:   background-color: var(--background-secondary);
379: }
380: .previewLine {
381:   display: flex;
382:   align-items: center;
383:   padding: 2px 0;
384:   margin: 1px 0;
385:   font-size: 0.7rem;
386:   line-height: 1.3;
387: }
388: .previewPatternText {
389:   flex: 1;
390:   white-space: nowrap;
391:   overflow: hidden;
392:   text-overflow: ellipsis;
393: }
394: .previewBadge {
395:   font-size: 0.6rem;
396:   padding: 1px 3px;
397:   border-radius: 2px;
398:   margin-left: 4px;
399:   color: var(--text-primary);
400:   opacity: 0.7;
401: }
402: .previewBadgeLocal {
403:   color: var(--success-color);
404:   opacity: 0.9;
405: }
406: .previewComment {
407:   color: var(--text-secondary);
408:   font-style: italic;
409:   font-size: 0.65rem;
410: }
411: .previewSeparator {
412:   height: 4px;
413:   margin: 2px 0;
414: }
415: .previewUnknown {
416:   color: var(--error-color);
417:   opacity: 0.8;
418: }
419: .notification {
420:   position: fixed;
421:   bottom: 20px;
422:   right: 20px;
423:   padding: 12px 16px;
424:   border-radius: var(--radius);
425:   background-color: var(--background-primary);
426:   color: var(--text-primary);
427:   box-shadow: var(--shadow-md);
428:   transform: translateY(100%);
429:   opacity: 0;
430:   transition: transform 0.3s ease, opacity 0.3s ease;
431:   z-index: var(--z-index-modal);
432: }
433: .notification.visible {
434:   transform: translateY(0);
435:   opacity: 1;
436: }
437: .notification.success {
438:   border-left: 4px solid var(--success-color);
439: }
440: .notification.error {
441:   border-left: 4px solid var(--error-color);
442: }
443: @keyframes slideIn {
444:   from {
445:     transform: scaleX(0);
446:   }
447:   to {
448:     transform: scaleX(1);
449:   }
450: }
451: @keyframes fadeIn {
452:   from {
453:     opacity: 0;
454:   }
455:   to {
456:     opacity: 1;
457:   }
458: }
459: @keyframes slideUp {
460:   from {
461:     opacity: 0;
462:     transform: translateY(20px);
463:   }
464:   to {
465:     opacity: 1;
466:     transform: translateY(0);
467:   }
468: }
469: @keyframes togglePulse {
470:   0% { transform: scale(1); }
471:   50% { transform: scale(1.05); }
472:   100% { transform: scale(1); }
473: }
474: .patternCategory {
475:   border: 1px solid var(--border-color);
476:   border-radius: var(--radius);
477:   overflow: hidden;
478:   margin-bottom: 8px;
479:   transition: box-shadow 0.2s;
480: }
481: .patternCategory:hover {
482:   box-shadow: var(--shadow-sm);
483: }
484: .categoryHeader {
485:   display: flex;
486:   align-items: center;
487:   padding: 6px 8px;
488:   background-color: var(--background-secondary);
489:   cursor: pointer;
490:   user-select: none;
491:   transition: background-color 0.2s;
492:   justify-content: space-between;
493: }
494: .categoryTitle {
495:   font-weight: 600;
496:   color: var(--text-primary);
497:   font-size: 0.75rem;
498:   margin-right: 6px;
499: }
500: .categoryMeta {
501:   display: flex;
502:   align-items: center;
503:   justify-content: flex-end;
504:   flex-shrink: 0;
505: }
506: .categoryCount {
507:   font-size: 0.65rem;
508:   color: var(--text-secondary);
509:   padding: 1px 3px;
510:   border-radius: 2px;
511:   background-color: var(--background-tertiary, rgba(0, 0, 0, 0.05));
512: }
513: .accordionIcon {
514:   transition: transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
515:   position: relative;
516: }
517: .accordionIcon.rotated {
518:   transform: rotate(180deg);
519: }
520: .accordionIcon.rotated path:last-child {
521:   opacity: 0;
522:   transition: opacity 0.15s ease;
523: }
524: .accordionIcon path:last-child {
525:   transform-origin: center;
526:   transition: opacity 0.2s ease;
527: }
528: .chevron {
529:   transition: transform 0.3s ease;
530: }
531: .chevronRotated {
532:   transform: rotate(180deg);
533: }
534: .categoryItems {
535:   max-height: 0;
536:   overflow: hidden;
537:   transform: translateY(-10px);
538:   opacity: 0;
539:   transition: 
540:     max-height 0.25s cubic-bezier(0.4, 0.0, 0.2, 1), 
541:     padding 0.2s cubic-bezier(0.4, 0.0, 0.2, 1),
542:     opacity 0.15s ease,
543:     transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
544: }
545: .categoryExpanded .categoryItems {
546:   max-height: 2000px;
547:   transform: translateY(0);
548:   opacity: 1;
549:   transition: 
550:     max-height 0.35s cubic-bezier(0.4, 0.0, 0.2, 1), 
551:     padding 0.2s cubic-bezier(0.4, 0.0, 0.2, 1),
552:     opacity 0.2s ease,
553:     transform 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
554:   padding: 8px 12px;
555: }
556: .smallerSwitch {
557:   transform: scale(0.65);
558:   transform-origin: right center;
559:   margin-left: auto;
560: }
561: .buttonGroup {
562:   display: flex;
563:   flex-wrap: wrap;
564:   gap: 4px;
565:   margin-top: 6px;
566: }
567: .buttonGroup button {
568:   font-size: 0.7rem;
569:   flex: 1 0 calc(50% - 4px); /* Make buttons take up half the width minus the gap */
570:   min-width: 80px;
571: }
572: .previewContent {
573:   margin-top: 8px;
574:   padding: 12px;
575:   background: var(--background);
576:   border-radius: 4px;
577:   font-family: monospace;
578:   white-space: pre-wrap;
579:   max-height: 200px;
580:   overflow-y: auto;
581: }
582: .hint {
583:   color: var(--text-secondary);
584:   font-size: 0.9em;
585:   margin: 8px 0;
586: }
587: /* Additional animation for the toggle */
588: .patternToggled {
589:   animation: togglePulse 0.3s ease;
590: }
591: .sectionTitle {
592:   margin-bottom: 16px;
593:   font-size: 0.9rem;
594:   font-weight: 500;
595:   color: var(--text-primary);
596: }
597: .closeButton {
598:   padding: 6px !important;
599:   border-radius: 6px;
600:   display: flex;
601:   align-items: center;
602:   justify-content: center;
603:   color: var(--text-secondary);
604:   transition: all 0.15s ease;
605: }
606: .closeButton:hover {
607:   background-color: var(--hover-color);
608:   color: var(--text-primary);
609: }
610: /* Visual feedback for saving operations */
611: .saveSuccess {
612:   animation: saveSuccessFlash 0.5s ease;
613: }
614: .saveError {
615:   animation: saveErrorFlash 0.5s ease;
616: }
617: .saveMessage {
618:   position: absolute;
619:   bottom: 1rem;
620:   left: 50%;
621:   transform: translateX(-50%);
622:   background-color: var(--accent-color);
623:   color: white;
624:   padding: 0.5rem 1rem;
625:   border-radius: var(--radius);
626:   font-size: 0.9rem;
627:   animation: fadeInUp 0.3s ease;
628:   z-index: 10;
629:   box-shadow: var(--shadow-md);
630: }
631: .errorMessage {
632:   background-color: var(--error-color);
633: }
634: @keyframes saveSuccessFlash {
635:   0% { background-color: var(--background-primary); }
636:   30% { background-color: rgba(46, 160, 67, 0.15); }
637:   100% { background-color: var(--background-primary); }
638: }
639: @keyframes saveErrorFlash {
640:   0% { background-color: var(--background-primary); }
641:   30% { background-color: rgba(248, 81, 73, 0.15); }
642:   100% { background-color: var(--background-primary); }
643: }
644: @keyframes fadeInUp {
645:   from { 
646:     opacity: 0;
647:     transform: translate(-50%, 1rem);
648:   }
649:   to { 
650:     opacity: 1;
651:     transform: translate(-50%, 0);
652:   }
653: }
654: .patternEntrySection {
655:   margin-bottom: 1.5rem;
656:   position: relative;
657: }
658: .sectionHeader {
659:   display: flex;
660:   justify-content: space-between;
661:   align-items: center;
662:   margin-bottom: 0.75rem; /* Space between header and editor */
663: }
664: .timestamp {
665:   font-size: 0.8rem;
666:   color: var(--text-secondary);
667:   font-style: italic;
668: }
669: .loadingIndicator {
670:   font-size: 0.8rem;
671:   color: var(--text-secondary);
672:   font-style: italic;
673:   /* Add a subtle animation if desired */
674:   animation: pulse 1.5s infinite ease-in-out;
675: }
676: /* Optional pulsing animation for loading indicator */
677: @keyframes pulse {
678:   0%, 100% { opacity: 1; }
679:   50% { opacity: 0.5; }
680: }
681: /* Style for the test button specifically */
682: .testButton {
683:   display: flex;
684:   align-items: center;
685:   gap: 6px; /* Space between icon and text */
686: }
687: .loadingIcon {
688:   animation: spin 1s linear infinite;
689: }
690: @keyframes spin {
691:   from { transform: rotate(0deg); }
692:   to { transform: rotate(360deg); }
693: }
694: /* Test Results Section */
695: .testResultsSection {
696:   margin-top: 1.5rem;
697:   border-top: 1px solid var(--border-color);
698:   padding-top: 1rem;
699: }
700: .testResultsHeader {
701:   font-size: 0.8rem;
702:   font-weight: 500;
703:   margin-bottom: 0.75rem;
704:   color: var(--text-primary);
705: }
706: .testResultsList {
707:   max-height: 150px; /* Limit height */
708:   overflow-y: auto;
709:   border: 1px solid var(--border-color);
710:   border-radius: var(--radius);
711:   padding: 0.5rem;
712:   background-color: var(--background-secondary);
713:   font-family: monospace;
714:   font-size: 0.8rem;
715: }
716: /* Test results scrollbar */
717: .testResultsList::-webkit-scrollbar {
718:   width: 6px;
719: }
720: .testResultsList::-webkit-scrollbar-track {
721:   background: transparent;
722: }
723: .testResultsList::-webkit-scrollbar-thumb {
724:   background-color: var(--border-color-lighter);
725:   border-radius: 3px;
726: }
727: .testResultsList {
728:   scrollbar-width: thin;
729:   scrollbar-color: var(--border-color-lighter) transparent;
730: }
731: .testResultItem {
732:   padding: 2px 4px;
733:   margin-bottom: 2px;
734:   white-space: nowrap;
735:   overflow: hidden;
736:   text-overflow: ellipsis;
737:   border-radius: 3px;
738:   font-size: 0.7rem;
739: }
740: .testError {
741:   color: var(--error-color);
742:   background-color: rgba(var(--error-color-rgb), 0.1);
743:   padding: 0.5rem;
744:   border-radius: var(--radius);
745: }
746: .noResults {
747:   color: var(--text-secondary);
748:   font-style: italic;
749:   padding: 0.5rem;
750: }

================
File: src/constants/promptTemplates.ts
================
  1: export interface PromptTemplate {
  2:   id: string;
  3:   name: string;
  4:   content: string;
  5:   category: TemplateCategory;
  6:   description?: string;
  7:   icon?: string;
  8: }
  9: export type TemplateCategory = 
 10:   | 'Code Review' 
 11:   | 'Documentation Generation' 
 12:   | 'Analysis and Improvement' 
 13:   | 'Testing' 
 14:   | 'Code Quality';
 15: export const PROMPT_TEMPLATES: PromptTemplate[] = [
 16:   {
 17:     id: 'rubric-creation',
 18:     name: 'Codebase-Informed Rubric',
 19:     category: 'Analysis and Improvement',
 20:     icon: '📊',
 21:     description: 'Create a detailed 8-category evaluation rubric informed by your codebase',
 22:     content: `Modified Rubric Creation Prompt
 23: You are an expert in creating detailed and effective rubrics. Your goal is to construct a robust rubric with exactly 8 categories and A-F rating levels for the topic: <TOPIC>. You also have access to the following code base for context and reference: <CODEBASE>. Use insights from the code base to inform and enrich the rubric, but ensure the final rubric remains broadly applicable to <TOPIC>, not overly tailored to the specifics of <CODEBASE>. The final output MUST be a markdown table representing the complete rubric.
 24: To create the best possible rubric, follow these steps:
 25: 1. Understand the Topic:
 26: First, take a moment to fully understand the topic: <TOPIC>. Consider its key components, aspects, and criteria for evaluation.
 27: 2. Examine the Code Base (If Relevant):
 28: Review <CODEBASE> to gain concrete examples or patterns that might inform your categories or grade descriptors. Look for notable features, common pitfalls, or unique aspects. However, maintain a balance: use the code to inspire more specific or relevant criteria without making the rubric so specialized that it cannot be applied to other projects under the same topic.
 29: 3. Brainstorm Core Categories:
 30: Think about the most important dimensions or categories for evaluating <TOPIC>. Aim for a comprehensive set of categories that cover all essential aspects. You may derive extra insight from the code base if it highlights key concerns (e.g., testing, security, architecture), but do not neglect broader best practices that might not appear in <CODEBASE>.
 31: 4. Select and Refine 8 Categories:
 32: From your brainstormed list, carefully select the 8 most critical and distinct categories. Refine the names of these categories to be clear, concise, and user-friendly. Each category should represent a key area of evaluation for <TOPIC>.
 33: • Note: If the code base reveals significant issues or exemplary techniques in certain areas (e.g., performance, documentation), you may include corresponding categories. Just ensure these categories are still relevant to <TOPIC> in a general sense.
 34: 5. Define Grade Descriptors for Each Category (A-F):
 35: For each of the 8 categories, you must define detailed descriptions for each grade level: A, B, C, D, E, and F.
 36: • Grade A (Excellent): Describe the characteristics of truly exceptional performance in this category.
 37: • Grade B (Good): Describe solid, above-average performance.
 38: • Grade C (Fair): Describe satisfactory or average performance.
 39: • Grade D (Needs Improvement): Describe performance that is below average and needs specific improvement.
 40: • Grade E (Poor): Describe significantly deficient performance.
 41: • Grade F (Failing): Describe completely inadequate or unacceptable performance.
 42: Ensure there is a clear progression of quality from A to F in your descriptions for each category. Whenever appropriate, you may reference themes discovered in <CODEBASE> (for instance, a security vulnerability or an especially efficient approach). However, avoid adding code-base-specific language that would not apply to other projects in the same domain.
 43: 6. Format as a Markdown Table:
 44: Present the complete rubric as a markdown table with the following structure:
 45: | Category | Grade A | Grade B | Grade C | Grade D | Grade E | Grade F |
 46: |----------|---------|---------|---------|---------|---------|---------|
 47: | Category 1 Name | Description for Grade A | Description for Grade B | Description for Grade C | Description for Grade D | Description for Grade E | Description for Grade F |
 48: | Category 2 Name | Description for Grade A | Description for Grade B | Description for Grade C | Description for Grade D | Description for Grade E | Description for Grade F |
 49: | Category 3 Name | Description for Grade A | Description for Grade B | Description for Grade C | Description for Grade D | Description for Grade E | Description for Grade F |
 50: | Category 4 Name | Description for Grade A | Description for Grade B | Description for Grade C | Description for Grade D | Description for Grade E | Description for Grade F |
 51: | Category 5 Name | Description for Grade A | Description for Grade B | Description for Grade C | Description for Grade D | Description for Grade E | Description for Grade F |
 52: | Category 6 Name | Description for Grade A | Description for Grade B | Description for Grade C | Description for Grade D | Description for Grade E | Description for Grade F |
 53: | Category 7 Name | Description for Grade A | Description for Grade B | Description for Grade C | Description for Grade D | Description for Grade E | Description for Grade F |
 54: | Category 8 Name | Description for Grade A | Description for Grade B | Description for Grade C | Description for Grade D | Description for Grade E | Description for Grade F |
 55: Replace "Category X Name" with the name of each of your 8 categories, and fill in the "Description for Grade X" cells with the corresponding descriptions you created in the previous step.
 56: Example (Row Only): If the topic was "Evaluating a Business Plan," one row of your markdown table might look like this:
 57: | Market Analysis | Comprehensive market analysis with strong evidence and clear understanding of market dynamics. | Solid market analysis with good understanding of the target market and competitive landscape. | Adequate market analysis demonstrating basic understanding. | Market analysis is present but weak or superficial. | Market analysis is significantly flawed or incomplete. | Market analysis is missing or fundamentally flawed. |
 58: Final Instruction
 59: Now, generate the complete markdown table rubric for the topic: <TOPIC>
 60: ... enter your topic here ...
 61: </TOPIC>, referencing <CODEBASE> only as needed for additional clarity or examples. Your rubric should remain broadly applicable to <TOPIC> while also reflecting any insights from <CODEBASE> that are valuable for guiding evaluations or improvements.`
 62:   },
 63:   {
 64:     id: 'architecture-review',
 65:     name: 'Architecture Review',
 66:     category: 'Code Review',
 67:     icon: '🏗️',
 68:     description: 'Analyze codebase architecture, patterns, and suggest improvements',
 69:     content: `Architecture Review:
 70: - Analyze this codebase's architecture:
 71: 1. Evaluate the overall structure and patterns
 72: 2. Identify potential architectural issues
 73: 3. Suggest improvements for scalability
 74: 4. Note areas that follow best practices
 75: Focus on maintainability and modularity.`
 76:   },
 77:   {
 78:     id: 'security-review',
 79:     name: 'Security Review',
 80:     category: 'Code Review',
 81:     icon: '🔒',
 82:     description: 'Identify security vulnerabilities and suggest fixes',
 83:     content: `Security Review:
 84: Perform a security review of this codebase:
 85: 1. Identify potential security vulnerabilities
 86: 2. Check for common security anti-patterns
 87: 3. Review error handling and input validation
 88: 4. Assess dependency security
 89: Provide specific examples and remediation steps.`
 90:   },
 91:   {
 92:     id: 'performance-review',
 93:     name: 'Performance Review',
 94:     category: 'Code Review',
 95:     icon: '⚡',
 96:     description: 'Analyze performance bottlenecks and optimization opportunities',
 97:     content: `Performance Review
 98: Review the codebase for performance:
 99: 1. Identify performance bottlenecks
100: 2. Check resource utilization
101: 3. Review algorithmic efficiency
102: 4. Assess caching strategies
103: Include specific optimization recommendations.`
104:   },
105:   {
106:     id: 'api-documentation',
107:     name: 'API Documentation',
108:     category: 'Documentation Generation',
109:     icon: '📚',
110:     description: 'Generate comprehensive API documentation',
111:     content: `API Documentation
112: Generate comprehensive API documentation:
113: 1. List and describe all public endpoints
114: 2. Document request/response formats
115: 3. Include usage examples
116: 4. Note any limitations or constraints`
117:   },
118:   {
119:     id: 'developer-guide',
120:     name: 'Developer Guide',
121:     category: 'Documentation Generation',
122:     icon: '📖',
123:     description: 'Create a comprehensive guide for developers',
124:     content: `Developer Guide
125: Create a developer guide covering:
126: 1. Setup instructions
127: 2. Project structure overview
128: 3. Development workflow
129: 4. Testing approach
130: 5. Common troubleshooting steps`
131:   },
132:   {
133:     id: 'architecture-documentation',
134:     name: 'Architecture Documentation',
135:     category: 'Documentation Generation',
136:     icon: '🏛️',
137:     description: 'Document system architecture and design decisions',
138:     content: `Architecture Documentation
139: Document the system architecture:
140: 1. High-level overview
141: 2. Component interactions
142: 3. Data flow diagrams
143: 4. Design decisions and rationale
144: 5. System constraints and limitations`
145:   },
146:   {
147:     id: 'dependency-analysis',
148:     name: 'Dependency Analysis',
149:     category: 'Analysis and Improvement',
150:     icon: '📦',
151:     description: 'Analyze project dependencies and suggest improvements',
152:     content: `Dependency Analysis
153: Analyze the project dependencies:
154: 1. Identify outdated packages
155: 2. Check for security vulnerabilities
156: 3. Suggest alternative packages
157: 4. Review dependency usage patterns
158: Include specific upgrade recommendations.`
159:   },
160:   {
161:     id: 'test-coverage',
162:     name: 'Test Coverage Review',
163:     category: 'Testing',
164:     icon: '🧪',
165:     description: 'Review test coverage and suggest improvements',
166:     content: `Test Coverage Review
167: Review the test coverage:
168: 1. Identify untested components
169: 2. Suggest additional test cases
170: 3. Review test quality
171: 4. Recommend testing strategies`
172:   },
173:   {
174:     id: 'code-quality',
175:     name: 'Code Quality Assessment',
176:     category: 'Code Quality',
177:     icon: '✨',
178:     description: 'Assess code quality and suggest improvements',
179:     content: `Code Quality Assessment
180: Assess code quality and suggest improvements:
181: 1. Review naming conventions
182: 2. Check code organization
183: 3. Evaluate error handling
184: 4. Review commenting practices
185: Provide specific examples of good and problematic patterns.`
186:   }
187: ];
188: export const TEMPLATE_STORAGE_KEY = 'pastemax-last-template';
189: export const TEMPLATE_INSERT_MODE_KEY = 'pastemax-template-insert-mode';
190: export type TemplateInsertMode = 'replace' | 'append';

================
File: src/types/FileTypes.ts
================
 1: export interface FileData {
 2:   name: string;
 3:   path: string;
 4:   relativePath?: string;
 5:   content?: string;
 6:   tokenCount: number;
 7:   uncompressedTokenCount: number;
 8:   isCompressed: boolean;
 9:   size: number;
10:   isBinary: boolean;
11:   isSkipped: boolean;
12:   error?: string;
13:   fileType?: string;
14:   type?: "file" | "directory";
15:   excludedByDefault?: boolean;
16:   lastModified?: number;
17:   isAppDirectory?: boolean;
18:   excluded?: boolean;
19: }
20: export interface TreeNode {
21:   id: string;
22:   name: string;
23:   path: string;
24:   type: "file" | "directory";
25:   children?: TreeNode[];
26:   isExpanded?: boolean;
27:   isSelected?: boolean;
28:   depth: number;
29:   parentId?: string;
30:   fileData?: FileData;
31: }
32: export interface SidebarProps {
33:   selectedFolder: string | null;
34:   openFolder: () => void;
35:   allFiles: Omit<FileData, 'content'>[];
36:   selectedFiles: string[];
37:   toggleFileSelection: (filePath: string) => void;
38:   toggleFolderSelection: (folderPath: string, isSelected: boolean) => void;
39:   searchTerm: string;
40:   onSearchChange: (term: string) => void;
41:   selectAllFiles: () => void;
42:   deselectAllFiles: () => void;
43:   expandedNodes: Map<string, boolean>;
44:   toggleExpanded: (nodeId: string) => void;
45: }
46: export interface FileListProps {
47:   files: Omit<FileData, 'content'>[];
48:   selectedFiles: string[];
49:   toggleFileSelection: (filePath: string) => void;
50: }
51: export interface FileCardProps {
52:   file: Omit<FileData, 'content'>;
53:   isSelected: boolean;
54:   toggleSelection: (filePath: string) => void;
55: }
56: export interface TreeItemProps {
57:   node: TreeNode;
58:   selectedFiles: string[];
59:   toggleFileSelection: (filePath: string) => void;
60:   toggleFolderSelection: (folderPath: string, isSelected: boolean) => void;
61:   toggleExpanded: (nodeId: string) => void;
62: }
63: export interface SortOption {
64:   value: string;
65:   label: string;
66: }
67: export interface SearchBarProps {
68:   searchTerm: string;
69:   onSearchChange: (term: string) => void;
70: }
71: export type FileTreeMode = "none" | "selected" | "selected-with-roots" | "complete";
72: // SortOrder type with consistent naming
73: export type SortOrder = 
74:   | "name-ascending" 
75:   | "name-descending" 
76:   | "tokens-ascending" 
77:   | "tokens-descending" 
78:   | "date-ascending" 
79:   | "date-descending";
80: // Add IgnorePattern interface for ignore patterns feature
81: export interface IgnorePattern {
82:   pattern: string;
83:   isGlobal: boolean;
84: }

================
File: src/utils/formatters.ts
================
  1: import { FileTreeMode } from '../types/FileTypes';
  2: export interface FileContent {
  3:   path: string;
  4:   content: string;
  5:   tokenCount?: number;
  6: }
  7: // Helper function to escape XML special characters
  8: function escapeXML(str: string): string {
  9:   return str
 10:     .replace(/&/g, '&amp;')
 11:     .replace(/</g, '&lt;')
 12:     .replace(/>/g, '&gt;')
 13:     .replace(/"/g, '&quot;')
 14:     .replace(/'/g, '&apos;');
 15: }
 16: // Helper function to wrap content in CDATA if it contains special characters
 17: function wrapInCDATA(content: string): string {
 18:   if (content.includes(']]>')) {
 19:     // Handle nested CDATA by splitting the string
 20:     return content
 21:       .split(']]>')
 22:       .map(part => `<![CDATA[${part}]]>`)
 23:       .join(']]&gt;');
 24:   }
 25:   return `<![CDATA[${content}]]>`;
 26: }
 27: export function formatAsXML(
 28:   files: FileContent[],
 29:   selectedFolder: string | null,
 30:   fileTreeMode: FileTreeMode,
 31:   fileTree: string,
 32:   userInstructions: string
 33: ): string {
 34:   const timestamp = new Date().toISOString();
 35:   let output = '<?xml version="1.0" encoding="UTF-8"?>\n';
 36:   output += '<contextcraft-export>\n';
 37:   // Add metadata
 38:   output += '  <metadata>\n';
 39:   output += `    <timestamp>${timestamp}</timestamp>\n`;
 40:   output += `    <file_count>${files.length}</file_count>\n`;
 41:   if (selectedFolder) {
 42:     output += `    <base_folder>${escapeXML(selectedFolder)}</base_folder>\n`;
 43:   }
 44:   output += '  </metadata>\n\n';
 45:   // Add user instructions if present
 46:   if (userInstructions) {
 47:     output += '  <instructions>\n';
 48:     output += `    ${wrapInCDATA(userInstructions)}\n`;
 49:     output += '  </instructions>\n\n';
 50:   }
 51:   // Add file tree if present
 52:   if (fileTree) {
 53:     output += '  <directory_structure>\n';
 54:     output += `    ${wrapInCDATA(fileTree)}\n`;
 55:     output += '  </directory_structure>\n\n';
 56:   }
 57:   // Add files
 58:   output += '  <files>\n';
 59:   files.forEach(file => {
 60:     output += `    <file path="${escapeXML(file.path)}"`;
 61:     if (file.tokenCount !== undefined) {
 62:       output += ` token_count="${file.tokenCount}"`;
 63:     }
 64:     output += '>\n';
 65:     output += `      ${wrapInCDATA(file.content)}\n`;
 66:     output += '    </file>\n';
 67:   });
 68:   output += '  </files>\n';
 69:   output += '</contextcraft-export>';
 70:   return output;
 71: }
 72: export function formatAsMarkdown(
 73:   files: FileContent[],
 74:   selectedFolder: string | null,
 75:   fileTreeMode: FileTreeMode,
 76:   fileTree: string,
 77:   userInstructions: string
 78: ): string {
 79:   const timestamp = new Date().toISOString();
 80:   let output = '# ContextCraft Export\n\n';
 81:   // Add metadata
 82:   output += '## Metadata\n';
 83:   output += `- **Timestamp:** ${timestamp}\n`;
 84:   output += `- **File Count:** ${files.length}\n`;
 85:   if (selectedFolder) {
 86:     output += `- **Base Folder:** \`${selectedFolder}\`\n`;
 87:   }
 88:   output += '\n';
 89:   // Add user instructions if present
 90:   if (userInstructions) {
 91:     output += '## Instructions\n\n';
 92:     output += userInstructions + '\n\n';
 93:   }
 94:   // Add file tree if present
 95:   if (fileTree) {
 96:     output += '## Directory Structure\n\n';
 97:     output += '```\n' + fileTree + '\n```\n\n';
 98:   }
 99:   // Add files
100:   output += '## Files\n\n';
101:   files.forEach(file => {
102:     const extension = file.path.split('.').pop() || '';
103:     output += `### ${file.path}\n`;
104:     if (file.tokenCount !== undefined) {
105:       output += `Token count: ${file.tokenCount}\n\n`;
106:     }
107:     output += '```' + extension + '\n' + file.content + '\n```\n\n';
108:   });
109:   return output;
110: }
111: export function formatAsPlain(
112:   files: FileContent[],
113:   selectedFolder: string | null,
114:   fileTreeMode: FileTreeMode,
115:   fileTree: string,
116:   userInstructions: string
117: ): string {
118:   const timestamp = new Date().toISOString();
119:   const separator = '='.repeat(80) + '\n';
120:   let output = '';
121:   // Add header
122:   output += separator;
123:   output += 'CONTEXTCRAFT EXPORT\n';
124:   output += separator + '\n';
125:   // Add metadata
126:   output += 'METADATA\n';
127:   output += separator;
128:   output += `Timestamp: ${timestamp}\n`;
129:   output += `File Count: ${files.length}\n`;
130:   if (selectedFolder) {
131:     output += `Base Folder: ${selectedFolder}\n`;
132:   }
133:   output += '\n';
134:   // Add user instructions if present
135:   if (userInstructions) {
136:     output += separator;
137:     output += 'INSTRUCTIONS\n';
138:     output += separator;
139:     output += userInstructions + '\n\n';
140:   }
141:   // Add file tree if present
142:   if (fileTree) {
143:     output += separator;
144:     output += 'DIRECTORY STRUCTURE\n';
145:     output += separator;
146:     output += fileTree + '\n\n';
147:   }
148:   // Add files
149:   output += separator;
150:   output += 'FILES\n';
151:   output += separator;
152:   files.forEach((file, index) => {
153:     if (index > 0) output += '\n';
154:     output += `File: ${file.path}\n`;
155:     if (file.tokenCount !== undefined) {
156:       output += `Token Count: ${file.tokenCount}\n`;
157:     }
158:     output += separator;
159:     output += file.content + '\n';
160:   });
161:   return output;
162: }

================
File: src/utils/pathUtils.ts
================
  1: /**
  2:  * Browser-compatible path utilities to replace Node.js path module
  3:  */
  4: import { FileTreeMode } from "../types/FileTypes";
  5: import _path from 'path'; // Prefix with underscore to indicate intentionally unused
  6: /**
  7:  * Normalizes a file path to use forward slashes regardless of operating system
  8:  * This helps with path comparison across different platforms
  9:  * 
 10:  * @param filePath The file path to normalize
 11:  * @returns The normalized path with forward slashes
 12:  */
 13: export function normalizePath(filePath: string): string {
 14:   if (!filePath) return filePath;
 15:   // Replace backslashes with forward slashes
 16:   return filePath.replace(/\\/g, '/');
 17: }
 18: /**
 19:  * Detects the operating system
 20:  * 
 21:  * @returns The detected operating system ('windows', 'mac', 'linux', or 'unknown')
 22:  */
 23: /*
 24: export const detectOS = (): 'windows' | 'mac' | 'linux' | 'other' => {
 25:   const platform = typeof process !== 'undefined' ? process.platform : (navigator.platform || '').toLowerCase();
 26:   if (platform.startsWith('win')) return 'windows';
 27:   if (platform.startsWith('darwin') || platform.startsWith('mac')) return 'mac';
 28:   if (platform.startsWith('linux')) return 'linux';
 29:   return 'other';
 30: };
 31: */
 32: /**
 33:  * Compares two paths for equality, handling different OS path separators
 34:  * 
 35:  * @param path1 First path to compare
 36:  * @param path2 Second path to compare
 37:  * @returns True if the paths are equivalent, false otherwise
 38:  */
 39: export function arePathsEqual(path1: string, path2: string): boolean {
 40:   return normalizePath(path1) === normalizePath(path2);
 41: }
 42: /**
 43:  * Extract the basename from a path string
 44:  * @param path The path to extract the basename from
 45:  * @returns The basename (last part of the path)
 46:  */
 47: /*
 48: const basename = (filePath: string): string => {
 49:   // Basic implementation, consider edge cases
 50:   const parts = normalizePath(filePath).split('/');
 51:   return parts[parts.length - 1] || '';
 52: };
 53: */
 54: /**
 55:  * Extract the directory name from a path string
 56:  * @param path The path to extract the directory from
 57:  * @returns The directory (everything except the last part)
 58:  */
 59: /*
 60: export const dirname = (filePath: string): string => {
 61:   const normalized = normalizePath(filePath);
 62:   const lastSlash = normalized.lastIndexOf('/');
 63:   if (lastSlash === -1) return '.'; // Root or no directory
 64:   return normalized.substring(0, lastSlash) || '/'; // Handle root case
 65: };
 66: */
 67: /**
 68:  * Join path segments together
 69:  * @param segments The path segments to join
 70:  * @returns The joined path
 71:  */
 72: /*
 73: const join = (...paths: string[]): string => {
 74:   // Basic implementation
 75:   const joined = paths.map(p => normalizePath(p)).join('/');
 76:   // Handle multiple slashes, etc. (more robust logic needed for full path.join mimicry)
 77:   return joined.replace(/\/+/g, '/'); 
 78: };
 79: */
 80: /**
 81:  * Get the file extension
 82:  * @param path The path to get the extension from
 83:  * @returns The file extension including the dot
 84:  */
 85: /*
 86: export const extname = (filePath: string): string => {
 87:   const name = basename(filePath);
 88:   const lastDot = name.lastIndexOf('.');
 89:   return lastDot > 0 ? name.substring(lastDot) : ''; // Check > 0 to avoid hidden files
 90: };
 91: */
 92: /**
 93:  * Generate an ASCII representation of the file tree for the selected files
 94:  * @param files Array of selected FileData objects
 95:  * @param rootPath The root directory path
 96:  * @param mode The FileTreeMode to use for generation
 97:  * @returns ASCII string representing the file tree
 98:  */
 99: export function generateAsciiFileTree(
100:   files: { path: string }[], 
101:   rootPath: string,
102:   mode: FileTreeMode = "selected"
103: ): string {
104:   if (!files.length) return "No files selected.";
105:   // Normalize the root path for consistent path handling
106:   const normalizedRoot = rootPath.replace(/\\/g, "/").replace(/\/$/, "");
107:   // Create a tree structure from the file paths
108:   interface TreeNode {
109:     name: string;
110:     isFile: boolean;
111:     children: Record<string, TreeNode>;
112:     // Add a flag to identify if this node contains a selected file
113:     hasSelectedFile?: boolean;
114:   }
115:   // Extract the root folder name from the path
116:   const rootName = normalizedRoot.split('/').filter(Boolean).pop() || 'root';
117:   const root: TreeNode = { 
118:     name: rootName, 
119:     isFile: false, 
120:     children: {},
121:     hasSelectedFile: false
122:   };
123:   // Insert a file path into the tree
124:   const insertPath = (filePath: string, node: TreeNode, isSelected: boolean = true) => {
125:     const normalizedPath = filePath.replace(/\\/g, "/");
126:     if (!normalizedPath.startsWith(normalizedRoot)) return;
127:     const relativePath = normalizedPath.substring(normalizedRoot.length).replace(/^\//, "");
128:     if (!relativePath) return;
129:     const pathParts = relativePath.split("/");
130:     let currentNode = node;
131:     for (let i = 0; i < pathParts.length; i++) {
132:       const part = pathParts[i];
133:       const isFile = i === pathParts.length - 1;
134:       if (!currentNode.children[part]) {
135:         currentNode.children[part] = {
136:           name: part,
137:           isFile,
138:           children: {},
139:           hasSelectedFile: isSelected && isFile
140:         };
141:       }
142:       // If this file is selected, mark this node and all parent nodes
143:       if (isSelected && isFile && i === pathParts.length - 1) {
144:         currentNode.children[part].hasSelectedFile = true;
145:       }
146:       currentNode = currentNode.children[part];
147:     }
148:     // Mark parent directories as having selected files
149:     if (isSelected) {
150:       let tempNode = node;
151:       for (let i = 0; i < pathParts.length - 1; i++) {
152:         const part = pathParts[i];
153:         if (tempNode.children[part]) {
154:           tempNode.children[part].hasSelectedFile = true;
155:           tempNode = tempNode.children[part];
156:         }
157:       }
158:     }
159:   };
160:   // Insert files into the tree based on the mode
161:   if (mode === "complete") {
162:     // In complete mode, insert all files, marking the selected ones
163:     files.forEach(file => {
164:       // Determine if this file is among the selected files
165:       // This requires a full list of files, where some might be selected and others not
166:       const isSelected = "selected" in file ? Boolean(file.selected) : true;
167:       insertPath(file.path, root, isSelected);
168:     });
169:   } else {
170:     // In selected mode or selected-with-roots mode, all files we're given are selected
171:     files.forEach(file => insertPath(file.path, root, true));
172:   }
173:   // Generate ASCII representation
174:   const generateAscii = (node: TreeNode, prefix = "", isLast = true, isRoot = true): string => {
175:     // For selected-with-roots mode, only include nodes that have selected files
176:     if (mode === "selected-with-roots" && !node.hasSelectedFile && !isRoot) {
177:       return "";
178:     }
179:     if (!isRoot) {
180:       let result = prefix;
181:       result += isLast ? "└── " : "├── ";
182:       result += node.name;
183:       // In complete mode, mark selected files with a '*'
184:       if (mode === "complete" && node.hasSelectedFile && node.isFile) {
185:         result += " *";
186:       }
187:       result += "\n";
188:       prefix += isLast ? "    " : "│   ";
189:       const children = Object.values(node.children).sort((a, b) => {
190:         // Sort by type (directories first) then by name
191:         if (a.isFile !== b.isFile) {
192:           return a.isFile ? 1 : -1;
193:         }
194:         return a.name.localeCompare(b.name);
195:       });
196:       return result + children
197:         .map((child, index) =>
198:           generateAscii(child, prefix, index === children.length - 1, false)
199:         )
200:         .join("");
201:     } else {
202:       // Root node special handling
203:       const children = Object.values(node.children).sort((a, b) => {
204:         // Sort by type (directories first) then by name
205:         if (a.isFile !== b.isFile) {
206:           return a.isFile ? 1 : -1;
207:         }
208:         return a.name.localeCompare(b.name);
209:       });
210:       return children
211:         .map((child, index) => {
212:           // For selected-with-roots mode, only include nodes that have selected files
213:           if (mode === "selected-with-roots" && !child.hasSelectedFile) {
214:             return "";
215:           }
216:           return generateAscii(child, prefix, index === children.length - 1, false);
217:         })
218:         .join("");
219:     }
220:   };
221:   return generateAscii(root);
222: }

================
File: .eslintrc.cjs
================
 1: module.exports = {
 2:   root: true,
 3:   env: { browser: true, es2020: true, node: true },
 4:   extends: [
 5:     "eslint:recommended",
 6:     "plugin:@typescript-eslint/recommended",
 7:     "plugin:react-hooks/recommended",
 8:   ],
 9:   ignorePatterns: ["dist", ".eslintrc.cjs"],
10:   parser: "@typescript-eslint/parser",
11:   plugins: ["react-refresh"],
12:   rules: {
13:     "react-refresh/only-export-components": [
14:       "warn",
15:       { allowConstantExport: true },
16:     ],
17:     "@typescript-eslint/no-explicit-any": "off", // During development, allow 'any' type
18:     "@typescript-eslint/no-unused-vars": ["warn", { "argsIgnorePattern": "^_", "varsIgnorePattern": "^_" }], // Ignore variables starting with underscore
19:   },
20:   settings: {
21:     react: {
22:       version: "detect",
23:     },
24:   },
25: };

================
File: .npmrc
================
1: node-gyp-binary-path=/opt/homebrew/bin/node-gyp
2: npm_config_cxx_std=c++20

================
File: release_notes.md
================
 1: # ContextCraft v1.0.2
 2: 
 3: This release includes important fixes for Windows compatibility and several UI improvements.
 4: 
 5: ## What's New
 6: 
 7: ### Windows Build Fix
 8: - Fixed port mismatch issue in development mode
 9: - Electron application now correctly connects to Vite on port 5173 instead of 3000
10: - Added cross-env package for cross-platform environment variables
11: - Improved handling of ELECTRON_START_URL environment variable
12: 
13: ### Path Handling Improvements
14: - Fixed file tree display issues on Windows
15: - Implemented proper handling of Windows paths and drive letters
16: - Added relativePath property to file objects for consistent cross-platform path handling
17: - Modified file tree building to use pre-calculated relative paths
18: - Ensured compatibility with existing code through fallback mechanisms
19: 
20: ### File Selection & Copy Fix
21: - Fixed issues with file selection and content copying on Windows
22: - Ensured consistent mapping between displayed paths and actual file paths
23: - Improved path normalization across the application
24: 
25: ### File Exclusion Improvements
26: - Modified filter functions to consistently filter out excluded files
27: - Ensured synchronization between file tree and file cards
28: - Prevented excluded files from appearing in search results
29: 
30: ### UI Improvements
31: - Reduced excessive toast notifications
32: - Added comprehensive wiki documentation
33: - Improved AI interaction prompts
34: 
35: ### Performance Considerations
36: - Maintained efficient debouncing (200ms)
37: - Optimized dependency arrays in React components
38: - Implemented safety mechanisms to prevent UI hanging
39: 
40: ## Compatibility
41: - Windows: Fixed major compatibility issues
42: - macOS: Maintained existing functionality 
43: - Linux: Improvements should apply equally
44: 
45: This release significantly improves the Windows experience while maintaining compatibility with macOS and Linux.

================
File: tsconfig.json
================
 1: {
 2:   "compilerOptions": {
 3:     "target": "ES2020",
 4:     "useDefineForClassFields": true,
 5:     "lib": ["ES2020", "DOM", "DOM.Iterable"],
 6:     "module": "ESNext",
 7:     "skipLibCheck": true,
 8: 
 9:     /* Bundler mode */
10:     "moduleResolution": "node",
11:     "allowImportingTsExtensions": true,
12:     "resolveJsonModule": true,
13:     "isolatedModules": true,
14:     "noEmit": true,
15:     "jsx": "react-jsx",
16: 
17:     /* Linting */
18:     "strict": true,
19:     "noUnusedLocals": false,
20:     "noUnusedParameters": false,
21:     "noFallthroughCasesInSwitch": true,
22: 
23:     /* Additional Options */
24:     "esModuleInterop": true,
25:     "allowSyntheticDefaultImports": true,
26:     "forceConsistentCasingInFileNames": true,
27: 
28:     "types": ["node", "electron"],
29:     "typeRoots": ["./node_modules/@types", "./src/types"]
30:   },
31:   "include": ["src", "src/declarations.d.ts", "src/types/**/*.d.ts"],
32:   "references": [{ "path": "./tsconfig.node.json" }]
33: }

================
File: src/components/ui/Toast/index.ts
================
1: export { default as Toast } from './Toast';
2: export { showToast } from './toastUtils';

================
File: src/components/ControlContainer.tsx
================
  1: import React, { useState, useCallback, ChangeEvent, useEffect } from 'react';
  2: import { FileTreeMode } from '../types/FileTypes';
  3: import { OutputFormatType, OUTPUT_FORMAT_OPTIONS } from '../constants/outputFormats';
  4: import { Switch, Button, ButtonGroup, DropdownAdapter } from './ui';
  5: import { Copy, Download, Check, Loader2, AlertTriangle, RefreshCw, Search, Settings, Cpu, Zap } from 'lucide-react';
  6: import styles from './ControlContainer.module.css';
  7: import { ModelInfo } from "../types/ModelTypes";
  8: // Define options for File Tree Mode Dropdown
  9: const FILE_TREE_MODE_OPTIONS = [
 10:   { value: 'none', label: 'None' },
 11:   { value: 'selected', label: 'Selected Only' },
 12:   { value: 'selected-with-roots', label: 'Selected with Path' },
 13:   { value: 'complete', label: 'Complete Tree' },
 14: ];
 15: interface ControlContainerProps {
 16:   fileTreeMode: FileTreeMode;
 17:   setFileTreeMode: (mode: FileTreeMode) => void;
 18:   showUserInstructions: boolean;
 19:   setShowUserInstructions: (show: boolean) => void;
 20:   getSelectedFilesContent: () => Promise<string>; // Make async
 21:   selectedFilesCount: number;
 22:   outputFormat: OutputFormatType;
 23:   setOutputFormat: (format: OutputFormatType) => void;
 24:   // Add new props for model selection
 25:   availableModels: ModelInfo[] | null;
 26:   selectedModelId: string | null;
 27:   onModelChange: (modelId: string | null) => void;
 28:   // Add props for token info display
 29:   totalTokenCount: number;
 30:   selectedContextLength: number | null;
 31:   // Add props for compression toggle
 32:   isCompressionEnabled: boolean;
 33:   setIsCompressionEnabled: (enabled: boolean) => void;
 34:   // Add props for comment removal
 35:   isCommentRemovalEnabled: boolean;
 36:   setIsCommentRemovalEnabled: (enabled: boolean) => void;
 37:   // Added missing props (can be used with underscore prefix)
 38:   isElectron: boolean;
 39:   processingStatus: 'idle' | 'processing' | 'complete' | 'error';
 40:   onGenerateOutput: () => void;
 41:   // Add new prop for model refreshing
 42:   onRefreshModels?: () => Promise<void>;
 43:   // Add new props for enhanced compression controls
 44:   keepDocstrings: boolean;
 45:   setKeepDocstrings: (keep: boolean) => void;
 46:   removeEmptyLines: boolean;
 47:   setRemoveEmptyLines: (remove: boolean) => void;
 48:   neverCompressPatterns: string[];
 49:   neverCompressPatternsRaw: string;
 50:   setNeverCompressPatternsRaw: (patterns: string) => void;
 51:   minCompressTokenThreshold: number;
 52:   setMinCompressTokenThreshold: (threshold: number) => void;
 53:   // Underscore-prefixed props for marking as intentionally unused
 54:   _isElectron?: boolean;
 55:   _processingStatus?: 'idle' | 'processing' | 'complete' | 'error';
 56:   _onGenerateOutput?: () => void;
 57:   _neverCompressPatterns?: string[];
 58: }
 59: const ControlContainer: React.FC<ControlContainerProps> = ({
 60:   fileTreeMode,
 61:   setFileTreeMode,
 62:   showUserInstructions,
 63:   setShowUserInstructions,
 64:   getSelectedFilesContent,
 65:   selectedFilesCount,
 66:   outputFormat,
 67:   setOutputFormat,
 68:   // Destructure new props
 69:   availableModels,
 70:   selectedModelId,
 71:   onModelChange,
 72:   // Destructure token info props
 73:   totalTokenCount,
 74:   selectedContextLength,
 75:   // Destructure compression props
 76:   isCompressionEnabled,
 77:   setIsCompressionEnabled,
 78:   // Destructure comment removal props
 79:   isCommentRemovalEnabled,
 80:   setIsCommentRemovalEnabled,
 81:   // Properly prefix unused props with underscore
 82:   isElectron: _isElectron,
 83:   processingStatus: _processingStatus,
 84:   onGenerateOutput: _onGenerateOutput,
 85:   // New prop for refreshing models
 86:   onRefreshModels,
 87:   // Destructure new props for enhanced compression controls
 88:   keepDocstrings,
 89:   setKeepDocstrings,
 90:   removeEmptyLines,
 91:   setRemoveEmptyLines,
 92:   neverCompressPatterns: _neverCompressPatterns,
 93:   neverCompressPatternsRaw,
 94:   setNeverCompressPatternsRaw,
 95:   minCompressTokenThreshold,
 96:   setMinCompressTokenThreshold,
 97: }) => {
 98:   const [copied, setCopied] = useState(false);
 99:   const [isCopying, setIsCopying] = useState(false); // Add loading state for copy
100:   const [isDownloading, setIsDownloading] = useState(false); // Add loading state for download
101:   const [isRefreshingModels, setIsRefreshingModels] = useState(false); // Add loading state for model refresh
102:   const [modelSearchTerm, setModelSearchTerm] = useState(''); // State for model search
103:   const [activeTab, setActiveTab] = useState('configure'); // State for simple tab implementation
104:   const [showControls, setShowControls] = useState(true); // New state for controls visibility
105:   const handleCopy = useCallback(async () => {
106:     if (selectedFilesCount === 0 || isCopying) return;
107:     setIsCopying(true);
108:     setCopied(false); // Reset copied state
109:     try {
110:       const content = await getSelectedFilesContent(); // Await the async function
111:       await navigator.clipboard.writeText(content);
112:       setCopied(true);
113:       setTimeout(() => setCopied(false), 2000);
114:     } catch (err) {
115:       console.error('Failed to copy:', err);
116:       // TODO: Show user error feedback
117:     } finally {
118:       setIsCopying(false);
119:     }
120:   }, [getSelectedFilesContent, selectedFilesCount, isCopying]); // Add dependencies
121:   const handleDownload = useCallback(async () => {
122:     if (selectedFilesCount === 0 || isDownloading) return;
123:     setIsDownloading(true);
124:     try {
125:         const content = await getSelectedFilesContent(); // Await the async function
126:         const blob = new Blob([content], { type: 'text/plain;charset=utf-8' }); // Specify charset
127:         const url = URL.createObjectURL(blob);
128:         const a = document.createElement('a');
129:         a.href = url;
130:         // Generate filename based on current context if possible
131:         const filename = `contextcraft_output_${new Date().toISOString().split('T')[0]}.txt`;
132:         a.download = filename;
133:         document.body.appendChild(a);
134:         a.click();
135:         document.body.removeChild(a);
136:         URL.revokeObjectURL(url);
137:     } catch (err) {
138:         console.error('Failed to download:', err);
139:         // TODO: Show user error feedback
140:     } finally {
141:         setIsDownloading(false);
142:     }
143:   }, [getSelectedFilesContent, selectedFilesCount, isDownloading]); // Add dependencies
144:   // Handle model refresh
145:   const handleRefreshModels = useCallback(async () => {
146:     if (!onRefreshModels || isRefreshingModels) return;
147:     setIsRefreshingModels(true);
148:     try {
149:       await onRefreshModels();
150:     } catch (error) {
151:       console.error('Error refreshing models:', error);
152:     } finally {
153:       setIsRefreshingModels(false);
154:     }
155:   }, [onRefreshModels, isRefreshingModels]);
156:   // Toggle controls visibility
157:   const toggleControls = () => {
158:     setShowControls(prev => !prev);
159:   };
160:   // Prepare model options, already available as prop 'availableModels'
161:   // No need to map here, adapter handles icon logic if any
162:   // Filter model options based on search term
163:   const filteredModelOptions = availableModels
164:     ? availableModels.filter(model => 
165:         model.name.toLowerCase().includes(modelSearchTerm.toLowerCase())
166:       ).map(model => ({ // Map to required { value, label } format for DropdownAdapter
167:           value: model.id,
168:           label: `${model.name} (${(model.context_length/1000).toLocaleString()}k)`,
169:         }))
170:     : [{ value: '', label: 'Loading models...', disabled: true }];
171:   // Check if token count exceeds the limit
172:   const exceedsLimit = selectedContextLength !== null && totalTokenCount > selectedContextLength;
173:   // Calculate percentage of token limit used
174:   const tokenPercentage = selectedContextLength ? Math.min(100, Math.round((totalTokenCount / selectedContextLength) * 100)) : 0;
175:   // Get token usage class
176:   const getTokenUsageClass = () => {
177:     if (tokenPercentage > 95) return styles.tokenDanger;
178:     if (tokenPercentage > 75) return styles.tokenWarning;
179:     if (tokenPercentage > 0) return styles.tokenGood;
180:     return '';
181:   };
182:   // Determine the width of the token bar with animation for visual appeal
183:   const [tokenBarWidth, setTokenBarWidth] = useState(0);
184:   // Animate token bar on changes similar to the file card implementation
185:   useEffect(() => {
186:     // Start with 0 width
187:     setTokenBarWidth(0);
188:     // Animate to the correct width with a slight delay for visual appeal
189:     const timer = setTimeout(() => {
190:       setTokenBarWidth(tokenPercentage);
191:     }, 100);
192:     return () => clearTimeout(timer);
193:   }, [tokenPercentage]);
194:   // Function to render the search input for the model dropdown
195:   const renderModelSearchHeader = () => (
196:     <div className={styles.searchContainerLocal}>
197:       <Search size={14} className={styles.searchIconLocal} />
198:       <input
199:         type="text"
200:         placeholder="Search models..."
201:         value={modelSearchTerm}
202:         onChange={(e: ChangeEvent<HTMLInputElement>) => setModelSearchTerm(e.target.value)}
203:         onClick={(e) => e.stopPropagation()} // Prevent click from closing dropdown
204:         onKeyDown={(e) => e.stopPropagation()} // Prevent arrow keys etc. from bubbling up
205:         className={styles.searchInputLocal}
206:         aria-label="Search models"
207:       />
208:     </div>
209:   );
210:   return (
211:     <div className={styles.controlContainer}>
212:       <div className={styles.controlContainerHeader}>
213:         <div className={styles.controlHeaderLeft}>
214:           <span>Controls</span>
215:           <Switch 
216:             checked={showControls} 
217:             onChange={() => toggleControls()}
218:             size="sm"
219:             className={styles.tinySwitch}
220:           />
221:           <div className={styles.headerActionButtons}>
222:             <ButtonGroup size="xs" variant="horizontal">
223:               <Button
224:                 variant="ghost"
225:                 iconOnly
226:                 startIcon={isCopying ? <Loader2 size={12} className="animate-spin" /> : copied ? <Check size={12} /> : <Copy size={12} />}
227:                 disabled={selectedFilesCount === 0 || isCopying || isDownloading}
228:                 onClick={handleCopy}
229:                 title={copied ? "Copied!" : "Copy content"}
230:               />
231:               <Button
232:                 variant="ghost"
233:                 iconOnly
234:                 startIcon={isDownloading ? <Loader2 size={12} className="animate-spin" /> : <Download size={12} />}
235:                 disabled={selectedFilesCount === 0 || isCopying || isDownloading}
236:                 onClick={handleDownload}
237:                 title="Download as text file"
238:               />
239:             </ButtonGroup>
240:           </div>
241:         </div>
242:       </div>
243:       {showControls && (
244:         <>
245:           {showUserInstructions && (
246:             <div className={styles.controlInstructions}>
247:               <p>Select files from the sidebar to include them in your output.</p>
248:             </div>
249:           )}
250:           <div className={styles.simpleTabs}>
251:             <div className={styles.simpleTabsList}>
252:               <button 
253:                 className={`${styles.simpleTabsTrigger} ${activeTab === 'configure' ? styles.simpleTabsTriggerActive : ''}`}
254:                 onClick={() => setActiveTab('configure')}
255:               >
256:                 <Settings size={12} />
257:                 <span>Configure</span>
258:               </button>
259:               <button 
260:                 className={`${styles.simpleTabsTrigger} ${activeTab === 'model' ? styles.simpleTabsTriggerActive : ''}`}
261:                 onClick={() => setActiveTab('model')}
262:               >
263:                 <Cpu size={12} />
264:                 <span>Model</span>
265:               </button>
266:               <button 
267:                 className={`${styles.simpleTabsTrigger} ${activeTab === 'optimize' ? styles.simpleTabsTriggerActive : ''}`}
268:                 onClick={() => setActiveTab('optimize')}
269:               >
270:                 <Zap size={12} />
271:                 <span>Optimize</span>
272:               </button>
273:             </div>
274:             <div className={styles.simpleTabsContent}>
275:               {activeTab === 'configure' && (
276:                 <div className={styles.controlGroup}>
277:                   <div className={styles.switchWithLabel}>
278:                     <Switch
279:                       checked={showUserInstructions}
280:                       onChange={() => setShowUserInstructions(!showUserInstructions)}
281:                       size="sm"
282:                       className={styles.tinySwitch}
283:                     />
284:                     <div>
285:                       <div className={styles.controlPrimary}>Show Instructions</div>
286:                       <div className={styles.controlHelp}>
287:                         Display helpful instructions for using the app
288:                       </div>
289:                     </div>
290:                   </div>
291:                   <div className={styles.controlItem}>
292:                     <div className={styles.controlLabel}>Output</div>
293:                     <DropdownAdapter
294:                       options={OUTPUT_FORMAT_OPTIONS}
295:                       value={outputFormat}
296:                       onChange={(val) => {
297:                         if (typeof val === 'string') {
298:                           setOutputFormat(val as OutputFormatType);
299:                         }
300:                       }}
301:                       placeholder="Format"
302:                       className={styles.configureDropdown}
303:                     />
304:                   </div>
305:                   <div className={styles.controlItem}>
306:                     <div className={styles.controlLabel}>Tree</div>
307:                     <DropdownAdapter
308:                       options={FILE_TREE_MODE_OPTIONS}
309:                       value={fileTreeMode}
310:                       onChange={(val) => {
311:                         if (typeof val === 'string') {
312:                           setFileTreeMode(val as FileTreeMode);
313:                         }
314:                       }}
315:                       placeholder="Tree Mode"
316:                       className={styles.configureDropdown}
317:                     />
318:                   </div>
319:                 </div>
320:               )}
321:               {activeTab === 'model' && (
322:                 <div className={styles.controlGroup}>
323:                   <div className={styles.controlItem}>
324:                     <div className={styles.controlLabel}>Model</div>
325:                     <div className={styles.modelSelectorContainer}>
326:                       <DropdownAdapter
327:                         options={filteredModelOptions}
328:                         value={selectedModelId || ''}
329:                         onChange={(val) => {
330:                           if (typeof val === 'string') {
331:                             onModelChange(val || null);
332:                           }
333:                         }}
334:                         placeholder="Select Model"
335:                         renderHeader={renderModelSearchHeader}
336:                         className={styles.modelDropdown}
337:                       />
338:                       <Button
339:                         variant="ghost"
340:                         size="sm"
341:                         iconOnly
342:                         startIcon={isRefreshingModels ? <Loader2 size={14} className="animate-spin" /> : <RefreshCw size={14} />}
343:                         disabled={isRefreshingModels || !onRefreshModels}
344:                         onClick={handleRefreshModels}
345:                         title="Refresh available models"
346:                       />
347:                     </div>
348:                   </div>
349:                   {/* Token usage indicator */}
350:                   <div className={styles.tokenInfo}>
351:                     <div className={styles.tokenCountText}>
352:                       {totalTokenCount.toLocaleString()} tokens
353:                       {selectedContextLength && ` / ${(selectedContextLength/1000).toLocaleString()}k context limit`}
354:                     </div>
355:                     <div className={styles.tokenUsageBar}>
356:                       <div
357:                         className={`${styles.tokenUsageFill} ${getTokenUsageClass()}`}
358:                         style={{ 
359:                           width: `${tokenBarWidth}%`,
360:                           backgroundColor: exceedsLimit ? 'var(--error-color)' : 
361:                                           (tokenPercentage > 75 ? 'var(--warning-color)' : 'var(--accent-color)')
362:                         }}
363:                       />
364:                     </div>
365:                     {exceedsLimit && (
366:                       <div className={styles.tokenWarning}>
367:                         <AlertTriangle size={12} style={{ marginRight: '6px' }} />
368:                         <span>Exceeds model context limit by {(totalTokenCount - selectedContextLength!).toLocaleString()} tokens</span>
369:                       </div>
370:                     )}
371:                   </div>
372:                 </div>
373:               )}
374:               {activeTab === 'optimize' && (
375:                 <div className={styles.controlGroup}>
376:                   <div className={styles.switchWithLabel}>
377:                     <Switch
378:                       checked={isCompressionEnabled}
379:                       onChange={() => setIsCompressionEnabled(!isCompressionEnabled)}
380:                       size="sm"
381:                       className={styles.tinySwitch}
382:                     />
383:                     <div>
384:                       <div className={styles.controlPrimary}>Compress Code</div>
385:                       <div className={styles.controlHelp}>
386:                         Reduces token count by removing code bodies from functions and methods
387:                       </div>
388:                     </div>
389:                   </div>
390:                   {isCompressionEnabled && (
391:                     <>
392:                       <div className={styles.controlItem}>
393:                         <div className={styles.controlLabel}>Min Tokens to Compress</div>
394:                         <input
395:                           type="number"
396:                           min={1}
397:                           max={10000}
398:                           value={minCompressTokenThreshold}
399:                           onChange={(e) => setMinCompressTokenThreshold(parseInt(e.target.value) || 100)}
400:                           className={styles.numberInput}
401:                           title="Minimum token count for a file to be considered for compression"
402:                         />
403:                       </div>
404:                       <div className={styles.controlItem}>
405:                         <div className={styles.controlLabel}>Never Compress Patterns</div>
406:                         <textarea
407:                           placeholder="Enter glob patterns (one per line)"
408:                           value={neverCompressPatternsRaw}
409:                           onChange={(e) => setNeverCompressPatternsRaw(e.target.value)}
410:                           className={styles.patternsTextarea}
411:                           title="Files matching these patterns will never be compressed"
412:                         />
413:                         <div className={styles.controlHelp}>
414:                           Enter glob patterns (one per line) for files/folders to exclude from body compression
415:                         </div>
416:                       </div>
417:                     </>
418:                   )}
419:                   <div className={styles.switchWithLabel}>
420:                     <Switch
421:                       checked={isCommentRemovalEnabled}
422:                       onChange={() => setIsCommentRemovalEnabled(!isCommentRemovalEnabled)}
423:                       size="sm"
424:                       className={styles.tinySwitch}
425:                     />
426:                     <div>
427:                       <div className={styles.controlPrimary}>Remove Comments</div>
428:                       <div className={styles.controlHelp}>
429:                         Reduces token count by stripping comments from code files
430:                       </div>
431:                     </div>
432:                   </div>
433:                   {isCommentRemovalEnabled && (
434:                     <div className={styles.switchWithLabel}>
435:                       <Switch
436:                         checked={keepDocstrings}
437:                         onChange={() => setKeepDocstrings(!keepDocstrings)}
438:                         size="sm"
439:                         className={styles.tinySwitch}
440:                         disabled={!isCommentRemovalEnabled}
441:                       />
442:                       <div>
443:                         <div className={styles.controlPrimary}>Keep Docstrings</div>
444:                         <div className={styles.controlHelp}>
445:                           Preserves documentation comments (e.g., JSDoc, Python docstrings) even if 'Remove Comments' is enabled
446:                         </div>
447:                       </div>
448:                     </div>
449:                   )}
450:                   <div className={styles.switchWithLabel}>
451:                     <Switch
452:                       checked={removeEmptyLines}
453:                       onChange={() => setRemoveEmptyLines(!removeEmptyLines)}
454:                       size="sm"
455:                       className={styles.tinySwitch}
456:                     />
457:                     <div>
458:                       <div className={styles.controlPrimary}>Remove Empty Lines</div>
459:                       <div className={styles.controlHelp}>
460:                         Removes blank lines from the output
461:                       </div>
462:                     </div>
463:                   </div>
464:                 </div>
465:               )}
466:             </div>
467:           </div>
468:         </>
469:       )}
470:     </div>
471:   );
472: };
473: export default ControlContainer;

================
File: src/components/GuideModal.tsx
================
 1: import React, { useCallback } from 'react';
 2: import { Dialog } from './ui/Dialog';
 3: import { Button } from './ui/Button';
 4: import { ExternalLink } from 'lucide-react';
 5: import styles from './GuideModal.module.css';
 6: interface GuideModalProps {
 7:   isOpen: boolean;
 8:   onClose: () => void;
 9: }
10: /**
11:  * In-app help component that provides basic usage information
12:  * and links to the full GitHub wiki documentation
13:  */
14: const GuideModal: React.FC<GuideModalProps> = ({ isOpen, onClose }) => {
15:   // Define a handler for opening the wiki in an external browser
16:   const _handleOpenWiki = useCallback(() => { // Prefix with underscore to indicate intentionally unused
17:     // Only available in Electron environment
18:     if (window.electron?.openExternal) {
19:       window.electron.openExternal('https://github.com/flight505/ContextCraft/wiki');
20:     } else {
21:       // Fallback for non-Electron environments
22:       window.open('https://github.com/flight505/ContextCraft/wiki', '_blank', 'noopener,noreferrer');
23:     }
24:   }, []);
25:   return (
26:     <Dialog
27:       isOpen={isOpen}
28:       onClose={onClose}
29:       title="ContextCraft Guide"
30:       size="md"
31:     >
32:       <div className={styles.guideContent}>
33:         <h2 className={styles.sectionTitle}>Quick Start</h2>
34:         <ol className={styles.guideList}>
35:           <li>Click <strong>Select Folder</strong> to choose your project directory</li>
36:           <li>Select files you want to include in your code export</li>
37:           <li>Configure output options in the right panel</li>
38:           <li>Click <strong>Copy</strong> to copy formatted code to clipboard</li>
39:         </ol>
40:         <h2 className={styles.sectionTitle}>Key Features</h2>
41:         <ul className={styles.guideList}>
42:           <li><strong>File Selection:</strong> Choose specific files from your project</li>
43:           <li><strong>File Tree Generation:</strong> Include project structure in various formats</li>
44:           <li><strong>Token Counting:</strong> Track token usage for your chosen AI model</li>
45:           <li><strong>Code Compression:</strong> Reduce token usage by simplifying function bodies</li>
46:           <li><strong>Custom Instructions:</strong> Add specific questions or context for the AI</li>
47:         </ul>
48:         <h2 className={styles.sectionTitle}>Common Actions</h2>
49:         <ul className={styles.guideList}>
50:           <li><strong>Folder Selection:</strong> Clicking a folder checkbox selects all applicable files within it.</li>
51:           <li><strong>Ignore Patterns:</strong> Configure which files to exclude from the project view</li>
52:           <li><strong>Model Selection:</strong> Choose your target AI model to optimize token usage</li>
53:           <li><strong>Output Formatting:</strong> Select from XML, Markdown, or Plain Text formats</li>
54:         </ul>
55:         <div className={styles.wikiSection}>
56:           <h2 className={styles.sectionTitle}>Complete Documentation</h2>
57:           <p>For detailed instructions documentation and ideas on VibeCoding, visit the Wiki:</p>
58:           <Button 
59:             onClick={_handleOpenWiki}
60:             variant="primary"
61:             className={styles.wikiButton}
62:             endIcon={<ExternalLink size={16} />}
63:           >
64:             Open ContextCraft Wiki
65:           </Button>
66:         </div>
67:       </div>
68:     </Dialog>
69:   );
70: };
71: export default GuideModal;

================
File: .gitignore
================
 1: # Logs
 2: logs
 3: *.log
 4: npm-debug.log*
 5: yarn-debug.log*
 6: yarn-error.log*
 7: pnpm-debug.log*
 8: lerna-debug.log*
 9: electron-debug.log*
10: 
11: # Dependencies
12: node_modules
13: .pnp
14: .pnp.js
15: 
16: # Build outputs
17: dist
18: dist-ssr
19: *.local
20: build
21: 
22: # Electron-builder output
23: out/
24: release/
25: 
26: # Editor directories and files
27: .vscode/*
28: !.vscode/extensions.json
29: .idea
30: .DS_Store
31: *.suo
32: *.ntvs*
33: *.njsproj
34: *.sln
35: *.sw?
36: 
37: # Environment variables
38: .env
39: .env.local
40: .env.development.local
41: .env.test.local
42: .env.production.local
43: 
44: # OS specific files
45: .DS_Store
46: .DS_Store?
47: ._*
48: .Spotlight-V100
49: .Trashes
50: ehthumbs.db
51: Thumbs.db
52: 
53: # IDE specific files
54: .idea/
55: .vscode/
56: *.swp
57: *.swo
58: 
59: # Release builds
60: release-builds/
61: dist/
62: 
63: # Workspace and temporary files
64: workspacesIndex.json
65: Workspace-*/
66: test-ignore.js
67: universalExclusions.js
68: *~
69: 
70: # Experimental or temporary scripts
71: *-temp.js
72: *-test.js
73: 
74: # Maintenance scripts 
75: cleanup.js
76: reset-patterns.js
77: 
78: # Local ignore files
79: .repo_ignore
80: memory.jsonl

================
File: src/components/ui/Toast/Toast.module.css
================
  1: /* =========================================
  2:  * TOAST COMPONENT STYLES
  3:  * A modular styling approach for toast notifications
  4:  * ========================================= */
  5: /* --------------------------------------
  6:  * 1. CONTAINER & POSITIONING
  7:  * -------------------------------------- */
  8: .toaster {
  9:   position: fixed;
 10:   z-index: var(--z-index-tooltip);
 11:   width: auto;
 12: }
 13: /* Position-specific shadows */
 14: .toaster[data-sonner-position^="top"] .toast {
 15:   box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
 16: }
 17: .toaster[data-sonner-position^="bottom"] .toast {
 18:   box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.15);
 19: }
 20: /* --------------------------------------
 21:  * 2. TOAST BASE LAYOUT
 22:  * -------------------------------------- */
 23: .toast {
 24:   /* Grid layout */
 25:   display: grid;
 26:   grid-template-columns: 92% 8%;
 27:   grid-template-rows: 1fr;
 28:   align-items: center;
 29:   justify-content: start;
 30:   gap: var(--spacing-xs, 6px);
 31:   /* Sizing */
 32:   max-width: 220px;
 33:   min-width: 220px;
 34:   max-height: 50px;
 35:   min-height: 50px;
 36:   width: 100%;
 37:   padding: var(--spacing-sm, 10px) var(--spacing-md, 12px);
 38:   /* Core visual styles */
 39:   background-color: transparent;
 40:   border-radius: var(--radius);
 41:   border: 1px solid var(--border-color);
 42:   border-left: 5px solid var(--border-color);
 43:   /* Typography base */
 44:   font-size: var(--font-size-xs, 8px);
 45:   line-height: 1.3;
 46:   color: var(--text-primary);
 47:   /* Base transition for non-animation properties */
 48:   transition: all 0.2s ease;
 49:   position: relative;
 50:   will-change: transform, opacity; /* Optimize animation */
 51: }
 52: /* --------------------------------------
 53:  * 3. VISUAL EFFECTS - Frosted Glass
 54:  * -------------------------------------- */
 55: .toast::before {
 56:   content: "";
 57:   position: absolute;
 58:   top: 0;
 59:   left: 0;
 60:   right: 0;
 61:   bottom: 0;
 62:   background-color: var(--card-background);
 63:   opacity: 0.9;
 64:   z-index: -1;
 65:   border-radius: inherit;
 66:   backdrop-filter: var(--backdrop-blur-md);
 67: }
 68: .toast:hover::before {
 69:   opacity: 0.98;
 70: }
 71: /* --------------------------------------
 72:  * 4. TYPOGRAPHY & CONTENT ELEMENTS
 73:  * -------------------------------------- */
 74: .title {
 75:   font-weight: 400;
 76:   font-size: var(--font-size-sm, 9px);
 77:   line-height: 1.2;
 78:   color: var(--text-primary);
 79:   margin-bottom: 2px;
 80:   grid-column: 1;
 81:   align-self: center;
 82:   justify-self: start;
 83:   padding-left: 4px;
 84:   display: flex;
 85:   width: 100%;
 86:   text-align: left;
 87:   min-height: 20px;
 88:   align-items: center;
 89: }
 90: .description {
 91:   font-size: var(--font-size-xs, 10px);
 92:   color: var(--text-secondary);
 93:   line-height: 1.3;
 94:   grid-column: 1;
 95:   align-self: center;
 96:   justify-self: start;
 97:   padding-left: 4px;
 98:   display: flex;
 99:   width: 100%;
100:   text-align: left;
101: }
102: /* --------------------------------------
103:  * 5. VARIANT STYLES
104:  * -------------------------------------- */
105: .success {
106:   border-left: 5px solid var(--success-color);
107: }
108: .error {
109:   border-left: 5px solid var(--error-color);
110: }
111: .warning {
112:   border-left: 5px solid var(--warning-color);
113: }
114: .info {
115:   border-left: 5px solid var(--accent-color);
116: }
117: /* High-density toast variant */
118: .highDensity {
119:   max-height: 40px;
120:   min-height: 40px;
121:   padding: var(--spacing-xs, 6px) var(--spacing-sm, 8px);
122: }
123: /* Single-line toast variant with better vertical centering */
124: .singleLineToast {
125:   display: flex;
126:   align-items: center;
127:   justify-content: flex-start;
128: }
129: .singleLineToast .title {
130:   margin-bottom: 0;
131:   display: flex;
132:   align-items: center;
133:   min-height: 32px;
134: }
135: /* --------------------------------------
136:  * 6. INTERACTIVE ELEMENTS
137:  * -------------------------------------- */
138: /* Action area */
139: .action {
140:   display: flex;
141:   gap: var(--spacing-xs, 6px);
142:   margin-top: var(--spacing-xxs, 4px);
143:   grid-column: 1;
144:   padding-left: 4px;
145:   align-items: center;
146:   justify-content: flex-start;
147: }
148: /* Primary action button */
149: .actionButton {
150:   background-color: var(--primary-button-background);
151:   color: var(--text-primary);
152:   border: 1px solid var(--border-color);
153:   padding: 0 var(--spacing-xs, 6px);
154:   height: 22px;
155:   border-radius: var(--radius);
156:   font-size: var(--font-size-xs, 9px);
157:   cursor: pointer;
158:   font-weight: 400;
159:   transition: all 0.15s ease;
160: }
161: .actionButton:hover {
162:   background-color: var(--primary-button-hover);
163: }
164: /* Secondary/cancel button */
165: .cancelButton {
166:   background-color: transparent;
167:   color: var(--text-secondary);
168:   border: 1px solid var(--border-color);
169:   padding: 0 var(--spacing-xs, 6px);
170:   height: 22px;
171:   border-radius: var(--radius);
172:   font-size: var(--font-size-xs, 9px);
173:   cursor: pointer;
174:   font-weight: 400;
175:   transition: all 0.15s ease;
176: }
177: .cancelButton:hover {
178:   background-color: var(--hover-color);
179: }
180: /* Close button */
181: .closeButton {
182:   width: 18px;
183:   height: 18px;
184:   display: flex;
185:   align-items: center;
186:   justify-content: center;
187:   border: none;
188:   background-color: transparent;
189:   color: var(--text-secondary);
190:   opacity: 0.7;
191:   cursor: pointer;
192:   transition: all 0.15s ease;
193:   grid-column: 2;
194:   justify-self: end;
195:   align-self: center;
196:   padding: 0;
197:   border-radius: 50%;
198: }
199: .closeButton:hover {
200:   opacity: 1;
201:   background-color: var(--hover-color);
202: }
203: /* --------------------------------------
204:  * 7. THEME VARIATIONS
205:  * -------------------------------------- */
206: /* Dark mode adjustments */
207: :global(.dark-mode) .toast::before {
208:   opacity: 0.9;
209:   backdrop-filter: var(--backdrop-blur-lg);
210: }
211: :global(.dark-mode) .toast:hover::before {
212:   opacity: 0.98;
213: }
214: :global(.dark-mode) .toaster[data-sonner-position^="top"] .toast {
215:   box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
216: }
217: :global(.dark-mode) .toaster[data-sonner-position^="bottom"] .toast {
218:   box-shadow: 0 -2px 8px rgba(0, 0, 0, 0.3);
219: }
220: /* --------------------------------------
221:  * 8. RESPONSIVE STYLES
222:  * -------------------------------------- */
223: @media (max-width: 640px) {
224:   .toast {
225:     max-width: calc(100% - 16px);
226:     width: calc(100% - 16px);
227:   }
228: } 
229: /* --------------------------------------
230:  * 9. ANIMATIONS
231:  * -------------------------------------- */
232: @keyframes toastEnter {
233:   from {
234:     opacity: 0;
235:     transform: translateY(100%);
236:   }
237:   to {
238:     opacity: 1;
239:     transform: translateY(0);
240:   }
241: }
242: @keyframes toastExit {
243:   from {
244:     opacity: 1;
245:     transform: translateY(0);
246:   }
247:   to {
248:     opacity: 0;
249:     transform: translateY(100%);
250:   }
251: }
252: .toast[data-state='open'] { animation: toastEnter 0.35s cubic-bezier(0.21, 1.02, 0.73, 1) forwards; }
253: .toast[data-state='closed'] { animation: toastExit 0.4s ease-out forwards; }

================
File: src/components/ui/Toast/Toast.tsx
================
  1: import React from 'react';
  2: import { Toaster as SonnerToaster, toast as _toast } from 'sonner';
  3: import { X } from 'lucide-react';
  4: import styles from './Toast.module.css';
  5: import { cn } from '../../../utils/cn';
  6: import { useTheme } from '../../../hooks/useTheme';
  7: /**
  8:  * Properties for Toast component
  9:  */
 10: export interface ToastProps {
 11:   /**
 12:    * Position of the toast notifications
 13:    * @default 'bottom-right'
 14:    */
 15:   position?: 'top-left' | 'top-right' | 'bottom-left' | 'bottom-right' | 'top-center' | 'bottom-center';
 16:   /**
 17:    * Gap between toast notifications
 18:    * @default 6
 19:    */
 20:   gap?: number;
 21:   /**
 22:    * Optional toast visibility duration in milliseconds
 23:    * @default 3000
 24:    */
 25:   duration?: number;
 26:   /**
 27:    * Additional class name for the toaster container
 28:    */
 29:   className?: string;
 30:   /**
 31:    * If true, toast notifications will have a close button
 32:    * @default true
 33:    */
 34:   closeButton?: boolean;
 35:   /**
 36:    * Maximum number of toast notifications shown at once
 37:    * @default 5
 38:    */
 39:   visibleToasts?: number;
 40:   /**
 41:    * Offset from the edges of the screen in pixels
 42:    * @default 12
 43:    */
 44:   offset?: number | string;
 45:   /**
 46:    * Use high-density layout (40px height instead of 50px)
 47:    * @default false
 48:    */
 49:   highDensity?: boolean;
 50: }
 51: // Define the ToastClassnames interface to match our CSS modules
 52: interface ToastClassnames {
 53:   toast?: string;
 54:   title?: string;
 55:   description?: string;
 56:   success?: string;
 57:   error?: string;
 58:   warning?: string;
 59:   info?: string;
 60:   action?: string;
 61:   actionButton?: string;
 62:   cancelButton?: string;
 63:   closeButton?: string;
 64: }
 65: /**
 66:  * Toast component for displaying notifications using sonner
 67:  */
 68: export const Toast: React.FC<ToastProps> = ({
 69:   position = 'bottom-right',
 70:   gap = 6,
 71:   duration = 3000,
 72:   className,
 73:   closeButton = true,
 74:   visibleToasts = 5,
 75:   offset = 12,
 76:   highDensity = false,
 77: }) => {
 78:   // Use the theme context to get the current theme
 79:   const { currentTheme } = useTheme();
 80:   const isDarkMode = currentTheme === 'dark';
 81:   // Custom close button with Lucide X icon
 82:   const CustomCloseButton: React.FC = () => {
 83:     return (
 84:       <button className={styles.closeButton} aria-label="Close toast">
 85:         <X size={14} color="currentColor" />
 86:       </button>
 87:     );
 88:   };
 89:   return (
 90:     <SonnerToaster
 91:       theme={isDarkMode ? 'dark' : 'light'}
 92:       className={cn(styles.toaster, className)}
 93:       position={position}
 94:       gap={gap}
 95:       duration={duration}
 96:       closeButton={closeButton}
 97:       visibleToasts={visibleToasts}
 98:       offset={offset}
 99:       toastOptions={{
100:         classNames: {
101:           toast: cn(styles.toast, highDensity && styles.highDensity),
102:           title: styles.title,
103:           description: styles.description,
104:           success: styles.success,
105:           error: styles.error,
106:           warning: styles.warning,
107:           info: styles.info,
108:           action: styles.action,
109:           actionButton: styles.actionButton,
110:           cancelButton: styles.cancelButton,
111:           closeButton: styles.closeButton,
112:         } as ToastClassnames,
113:         unstyled: true,
114:         closeButton: CustomCloseButton as unknown as boolean,
115:       }}
116:     />
117:   );
118: };
119: export default Toast;

================
File: src/components/IgnorePatterns.tsx
================
  1: import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
  2: import { ChevronDown, Plus, X, Play, Loader2 } from "lucide-react";
  3: import Editor from 'react-simple-code-editor';
  4: import Prism from 'prismjs';
  5: import 'prismjs/components/prism-clike';
  6: import 'prismjs/components/prism-ignore';
  7: import 'prismjs/themes/prism.css';
  8: import 'prismjs/themes/prism-tomorrow.css';
  9: import { Button, Switch } from "./ui";
 10: import { ErrorBoundary } from './ErrorBoundary';
 11: import styles from "./IgnorePatterns.module.css";
 12: import { SYSTEM_PATTERN_CATEGORIES, IgnorePatternsState } from "../utils/patternUtils";
 13: import { showToast } from './ui/Toast';
 14: // Props interface - Updated
 15: interface IgnorePatternsProps {
 16:   isOpen: boolean;
 17:   onClose: () => void;
 18:   // Pass the full state objects
 19:   globalPatternsState: IgnorePatternsState;
 20:   localPatternsState: IgnorePatternsState; // Only 'patterns' part is relevant here
 21:   localFolderPath?: string;
 22:   processingStatus?: {
 23:     status: "idle" | "processing" | "complete" | "error";
 24:     message: string;
 25:   };
 26:   // Callbacks to App.tsx
 27:   saveIgnorePatterns: (patterns: string, isGlobal: boolean, folderPath?: string) => Promise<void>;
 28:   resetIgnorePatterns: (isGlobal: boolean, folderPath?: string) => Promise<void>;
 29:   clearIgnorePatterns: (folderPath: string) => Promise<void>;
 30:   // For controlling excluded system patterns
 31:   onExcludedSystemPatternsChange: (patterns: string[]) => void;
 32:   systemIgnorePatterns: string[]; // Full list of available system patterns
 33:   recentFolders: string[];
 34: }
 35: // Custom error for pattern validation
 36: class PatternValidationError extends Error {
 37:  constructor(message: string) {
 38:   super(message);
 39:   this.name = 'PatternValidationError';
 40:  }
 41: }
 42: // Validates a glob pattern for syntax errors
 43: const validatePattern = (pattern: string): boolean => {
 44:   if (!pattern.trim()) {
 45:    throw new PatternValidationError(`Invalid pattern: Pattern cannot be empty`);
 46:   }
 47:   return true;
 48: };
 49: // Add type for test results
 50: interface PatternTestResult {
 51:   ignoredCount: number;
 52:   ignoredFiles: string[];
 53:   totalFilesChecked: number;
 54: }
 55: const IgnorePatternsWithErrorBoundary: React.FC<IgnorePatternsProps> = (props) => (
 56:   <ErrorBoundary fallback={ <div>Error loading ignore patterns component.</div> }>
 57:     <IgnorePatterns {...props} />
 58:   </ErrorBoundary>
 59: );
 60: // Add a helper function to truncate file paths to show only username
 61: const truncatePath = (path: string): string => {
 62:   if (!path) return '';
 63:   // For macOS/Linux paths
 64:   if (path.startsWith('/')) {
 65:     const parts = path.split('/');
 66:     // Get username part (usually the third part in /Users/username/...)
 67:     if (parts.length >= 3 && parts[1] === 'Users') {
 68:       return `~/${parts.slice(3).join('/')}`;
 69:     }
 70:   }
 71:   // For Windows paths
 72:   if (path.includes(':\\')) {
 73:     const parts = path.split('\\');
 74:     const userIndex = parts.findIndex(part => part === 'Users') + 1;
 75:     if (userIndex > 0 && userIndex < parts.length) {
 76:       return `~\\${parts.slice(userIndex + 1).join('\\')}`;
 77:     }
 78:   }
 79:   // Simple fallback for other paths
 80:   const pathParts = path.split(/[/\\]/); // Removed unnecessary escape for /
 81:   return `.../${pathParts[pathParts.length - 1]}`;
 82: };
 83: const IgnorePatterns: React.FC<IgnorePatternsProps> = ({
 84:   isOpen,
 85:   onClose,
 86:   globalPatternsState, // Now an object { patterns, excludedSystemPatterns }
 87:   localPatternsState,  // Now an object { patterns, excludedSystemPatterns } (but we only use patterns)
 88:   localFolderPath,
 89:   processingStatus = { status: "idle", message: "" },
 90:   saveIgnorePatterns,
 91:   resetIgnorePatterns,
 92:   clearIgnorePatterns,
 93:   onExcludedSystemPatternsChange,
 94:   systemIgnorePatterns,
 95:   recentFolders,
 96: }) => {
 97:   /**
 98:    * Component State Management
 99:    */
100:   const isInitialized = useRef(false);
101:   // Use safe initializers for useState, relying on useEffect for sync
102:   const [currentGlobalPatterns, setCurrentGlobalPatterns] = useState<string>('');
103:   const [currentLocalPatterns, setCurrentLocalPatterns] = useState<string>('');
104:   const [mergedPreview, setMergedPreview] = useState<Array<{ pattern: string; source: string }>>([]);
105:   const [activeTab, setActiveTab] = useState<"global" | "local">("global");
106:   const [selectedFolder, setSelectedFolder] = useState<string | undefined>(localFolderPath);
107:   const [applyingPatterns, setApplyingPatterns] = useState<boolean>(false);
108:   const [folderSelectOpen, setFolderSelectOpen] = useState(false);
109:   const [actualPatternCount, setActualPatternCount] = useState<number>(0);
110:   const [lastSavedGlobal, setLastSavedGlobal] = useState<Date | null>(null);
111:   const [lastSavedLocal, setLastSavedLocal] = useState<Record<string, Date | null>>({}); // Store by folder path
112:   const [isLoadingPatterns, setIsLoadingPatterns] = useState<boolean>(false);
113:   const [isTestingPatterns, setIsTestingPatterns] = useState<boolean>(false);
114:   const [testResults, setTestResults] = useState<PatternTestResult | null>(null);
115:   const [testError, setTestError] = useState<string | null>(null);
116:   // Add ref for the editor container
117:   const editorContainerRef = useRef<HTMLDivElement>(null);
118:   // Derive excluded patterns directly from props for controlled behavior
119:   // Add safe fallback for initial render if globalPatternsState is somehow undefined briefly
120:   const excludedSystemPatterns = useMemo(() => globalPatternsState?.excludedSystemPatterns || [], [globalPatternsState]);
121:   // Initialize with all categories collapsed
122:   const [expandedCategories, setExpandedCategories] = useState<Record<string, boolean>>(
123:     Object.keys(SYSTEM_PATTERN_CATEGORIES).reduce((acc, category) => ({ ...acc, [category]: false }), {})
124:   );
125:   /**
126:    * Sync internal state with props when modal opens or props change
127:    */
128:   useEffect(() => {
129:     if (isOpen) {
130:       // Safely access props, providing defaults if undefined during initial render cycle
131:       setCurrentGlobalPatterns(globalPatternsState?.patterns ?? '');
132:       if (selectedFolder === localFolderPath) {
133:           setCurrentLocalPatterns(localPatternsState?.patterns ?? '');
134:       } else if (!isInitialized.current) {
135:           setCurrentLocalPatterns(''); // Start fresh if different folder on init
136:       }
137:       setSelectedFolder(localFolderPath); // Sync selected folder
138:       setApplyingPatterns(processingStatus.status === 'processing');
139:       if (!isInitialized.current) {
140:         isInitialized.current = true;
141:       }
142:     } else {
143:       // Reset init flag when closed
144:       isInitialized.current = false;
145:     }
146:   }, [isOpen, globalPatternsState, localPatternsState, localFolderPath, processingStatus, selectedFolder]); // Ensure all relevant props are dependencies
147:   // Generate merged preview - Refined logic
148:   useEffect(() => {
149:     // 1. Get all potential patterns sources
150:     const currentGlobalEdit = currentGlobalPatterns.split('\n').filter(p => p.trim());
151:     const currentLocalEdit = currentLocalPatterns.split('\n').filter(p => p.trim());
152:     // Use props for saved state, providing defaults
153:     const savedGlobalPatterns = (globalPatternsState?.patterns ?? '').split('\n').filter(p => p.trim());
154:     const savedLocalPatterns = (localPatternsState?.patterns ?? '').split('\n').filter(p => p.trim());
155:     const safeExcludedSystem = Array.isArray(excludedSystemPatterns) ? excludedSystemPatterns : [];
156:     const activeSystemPatterns = systemIgnorePatterns.filter(p => !safeExcludedSystem.includes(p));
157:     // 2. Determine active patterns based on the *current* tab
158:     // Use edits for the active tab, saved state for the inactive tab
159:     const activeGlobal = (activeTab === 'global') ? currentGlobalEdit : savedGlobalPatterns;
160:     const activeLocal = (activeTab === 'local') ? currentLocalEdit : savedLocalPatterns;
161:     // 3. Combine and deduplicate, tracking source (System > Global > Local precedence)
162:     const effectivePatterns = new Map<string, 'system' | 'global' | 'local'>();
163:     // Add system patterns first
164:     activeSystemPatterns.forEach(p => effectivePatterns.set(p, 'system'));
165:     // Add global patterns (overwriting system if duplicate)
166:     activeGlobal.forEach(p => effectivePatterns.set(p, 'global'));
167:     // Add local patterns (overwriting global/system if duplicate)
168:     // Only add local patterns if a folder is selected
169:     if (selectedFolder) {
170:       activeLocal.forEach(p => effectivePatterns.set(p, 'local'));
171:     }
172:     // 4. Build the preview string array with source indicators
173:     const previewLines: { pattern: string; source: string }[] = [];
174:     // Group by source for clarity in preview
175:     const systemLines = Array.from(effectivePatterns.entries()).filter(([, src]) => src === 'system').map(([pat]) => ({ pattern: pat, source: 'system' }));
176:     const globalLines = Array.from(effectivePatterns.entries()).filter(([, src]) => src === 'global').map(([pat]) => ({ pattern: pat, source: 'global' }));
177:     const localLines = Array.from(effectivePatterns.entries()).filter(([, src]) => src === 'local').map(([pat]) => ({ pattern: pat, source: 'local' }));
178:     if (systemLines.length > 0) {
179:       previewLines.push({ pattern: "# --- System Patterns ---", source: 'comment' });
180:       previewLines.push(...systemLines);
181:     }
182:     if (globalLines.length > 0) {
183:       if (previewLines.length > 0) previewLines.push({ pattern: "", source: 'comment' }); // separator
184:       previewLines.push({ pattern: "# --- Global Patterns ---", source: 'comment' });
185:       previewLines.push(...globalLines);
186:     }
187:     if (localLines.length > 0) {
188:       if (previewLines.length > 0) previewLines.push({ pattern: "", source: 'comment' }); // separator
189:       previewLines.push({ pattern: "# --- Local Patterns ---", source: 'comment' });
190:       previewLines.push(...localLines);
191:     }
192:     // Store the preview data (more structured now)
193:     // We'll adapt the rendering logic below
194:     setMergedPreview(previewLines); // Assuming setMergedPreview can handle this array
195:     setActualPatternCount(effectivePatterns.size);
196:   }, [activeTab, currentGlobalPatterns, currentLocalPatterns, globalPatternsState, localPatternsState, systemIgnorePatterns, excludedSystemPatterns, selectedFolder]); // Added selectedFolder dependency
197:   // Effect to update last saved time when props indicate a save might have occurred elsewhere
198:   // (This is a basic check, might need refinement based on actual app logic)
199:   useEffect(() => {
200:     // Placeholder: If we had timestamps from props, we'd sync them here.
201:     // For now, we'll rely on setting it during save actions within this component.
202:   }, [globalPatternsState, localPatternsState]);
203:   // Effect to handle initial loading state
204:   useEffect(() => {
205:     if (isOpen) {
206:       setIsLoadingPatterns(true);
207:       // Simulate loading delay or use actual loading status from props if available
208:       const timer = setTimeout(() => setIsLoadingPatterns(false), 300); // Adjust delay as needed
209:       return () => clearTimeout(timer);
210:     }
211:   }, [isOpen, activeTab, selectedFolder]); // Reload when tab or folder changes
212:   // Effect to clear test results when inputs change or modal closes
213:   useEffect(() => {
214:     if (!isOpen) {
215:       setTestResults(null);
216:       setTestError(null);
217:     }
218:   }, [isOpen]);
219:   useEffect(() => {
220:     // Clear results if patterns or folder change
221:     setTestResults(null);
222:     setTestError(null);
223:   }, [currentGlobalPatterns, currentLocalPatterns, selectedFolder, excludedSystemPatterns]);
224:   /**
225:    * Event Handlers
226:    */
227:   const handleTabChange = (isGlobal: boolean) => setActiveTab(isGlobal ? "global" : "local");
228:   const handleFolderChange = (folderPath: string) => {
229:     setSelectedFolder(folderPath);
230:     setFolderSelectOpen(false);
231:     if (folderPath === localFolderPath) {
232:        // Safely access patterns from prop state
233:        setCurrentLocalPatterns(localPatternsState?.patterns ?? '');
234:     } else {
235:        setCurrentLocalPatterns('');
236:        console.warn("Selecting a different folder than the App's current one. Local patterns shown are temporary until saved for that specific folder.");
237:     }
238:   };
239:   const toggleCategory = (category: string) => {
240:     setExpandedCategories(prev => ({ ...prev, [category]: !prev[category] }));
241:   };
242:   // System pattern management - Calls the callback prop
243:   const handleToggleSystemPattern = useCallback((pattern: string) => {
244:     try {
245:       validatePattern(pattern);
246:        // Ensure excludedSystemPatterns is an array before operating on it
247:       const safeExcluded = Array.isArray(excludedSystemPatterns) ? excludedSystemPatterns : [];
248:       const newExcluded = safeExcluded.includes(pattern)
249:         ? safeExcluded.filter(p => p !== pattern)
250:         : [...safeExcluded, pattern];
251:       onExcludedSystemPatternsChange(newExcluded); // Update App state
252:       // Visual feedback (optional)
253:       const patternElement = document.querySelector(`[data-pattern="${pattern}"]`);
254:       if (patternElement) {
255:         patternElement.classList.add(styles.patternToggled);
256:         setTimeout(() => patternElement.classList.remove(styles.patternToggled), 300);
257:       }
258:     } catch (error) {
259:       console.error('Error toggling pattern:', error);
260:       if (error instanceof PatternValidationError) console.warn('Pattern validation failed:', error.message);
261:     }
262:   }, [excludedSystemPatterns, onExcludedSystemPatternsChange]); // Use derived excludedSystemPatterns
263:   // Pattern saving handlers - Use current local edits + props
264:   const handleSaveGlobalPatterns = useCallback(async () => {
265:     try {
266:       setApplyingPatterns(true);
267:       const userPatterns = currentGlobalPatterns.split('\n').filter(p => p.trim());
268:       userPatterns.forEach(validatePattern);
269:       // Format disabled patterns using the derived prop value
270:       const safeExcluded = Array.isArray(excludedSystemPatterns) ? excludedSystemPatterns : [];
271:       // Format disabled patterns section - each disabled pattern on its own line
272:       const disabledPatternsSection = safeExcluded
273:         .map(pattern => `# DISABLED: ${pattern}`)
274:         .join('\n');
275:       // Add user patterns with proper header
276:       let formattedContent = '';
277:       // Add the disabled patterns first
278:       if (disabledPatternsSection) {
279:         formattedContent += disabledPatternsSection + '\n\n';
280:       }
281:       // Then add user patterns with header
282:       if (currentGlobalPatterns.trim()) {
283:         formattedContent += '# USER PATTERNS:\n' + currentGlobalPatterns.trim();
284:       }
285:       await saveIgnorePatterns(formattedContent, true);
286:       setApplyingPatterns(false);
287:       setLastSavedGlobal(new Date()); // Set timestamp on success
288:       // Return success for handleSave
289:       return { success: true };
290:     } catch (error) {
291:       console.error('Error saving global patterns:', error);
292:       setApplyingPatterns(false);
293:       // Propagate error
294:       throw error; 
295:     }
296:   }, [currentGlobalPatterns, excludedSystemPatterns, saveIgnorePatterns]);
297:   const handleSaveLocalPatterns = useCallback(async () => {
298:     try {
299:       if (!selectedFolder) {
300:         throw new Error('No folder selected for local patterns');
301:       }
302:       setApplyingPatterns(true);
303:       // Save the patterns and get the result
304:       const result = await saveIgnorePatterns(currentLocalPatterns, false, selectedFolder);
305:       // Add visual feedback using the editorContainerRef
306:       if (editorContainerRef.current) {
307:         editorContainerRef.current.classList.add(styles.saveSuccess);
308:         setTimeout(() => {
309:           if (editorContainerRef.current) {
310:             editorContainerRef.current.classList.remove(styles.saveSuccess);
311:           }
312:         }, 500);
313:       }
314:       setApplyingPatterns(false);
315:       setLastSavedLocal(prev => ({ ...prev, [selectedFolder]: new Date() })); // Set timestamp
316:       return result; // Return result from saveIgnorePatterns
317:     } catch (error) {
318:       console.error('Error saving local patterns:', error);
319:       setApplyingPatterns(false);
320:       // Add visual error feedback using the editorContainerRef
321:       if (editorContainerRef.current) {
322:         editorContainerRef.current.classList.add(styles.saveError);
323:         setTimeout(() => {
324:           if (editorContainerRef.current) {
325:             editorContainerRef.current.classList.remove(styles.saveError);
326:           }
327:         }, 500);
328:       }
329:       throw error;
330:     }
331:   }, [currentLocalPatterns, selectedFolder, saveIgnorePatterns]);
332:   const handleSave = useCallback(async () => {
333:     try {
334:       setApplyingPatterns(true);
335:       let _result;
336:       if (activeTab === 'global') {
337:         // Save global patterns
338:         _result = await handleSaveGlobalPatterns();
339:       } else {
340:         // Save local patterns
341:         if (!selectedFolder) {
342:           throw new Error('No folder selected for local patterns');
343:         }
344:         _result = await handleSaveLocalPatterns();
345:       }
346:       // Success - both helper functions either succeed or throw errors
347:       // No need to check result.success as that's handled in the helper functions
348:       // Update the UI to show success state
349:       const editorContainer = document.querySelector(`.${styles.patternEntrySection}`);
350:       if (editorContainer) {
351:         editorContainer.classList.add(styles.success);
352:         setTimeout(() => {
353:           editorContainer.classList.remove(styles.success);
354:         }, 1000);
355:       }
356:       setApplyingPatterns(false);
357:       // Show success toast
358:       showToast.success(`${activeTab === 'global' ? 'Global' : 'Local'} patterns saved successfully`);
359:     } catch (error) {
360:       console.error('Error saving patterns:', error);
361:       // Update UI to show error state
362:       const editorContainer = document.querySelector(`.${styles.patternEntrySection}`);
363:       if (editorContainer) {
364:         editorContainer.classList.add(styles.error);
365:         setTimeout(() => {
366:           editorContainer.classList.remove(styles.error);
367:         }, 1000);
368:       }
369:       setApplyingPatterns(false);
370:       // Show error toast
371:       showToast.error('Error saving patterns', error instanceof Error ? error.message : String(error));
372:     }
373:   }, [activeTab, selectedFolder, handleSaveGlobalPatterns, handleSaveLocalPatterns]);
374:   // Keyboard shortcuts
375:   useEffect(() => {
376:     const handleKeyDown = (e: KeyboardEvent) => {
377:       if ((e.ctrlKey || e.metaKey) && e.key === 's') {
378:         e.preventDefault();
379:         handleSave();
380:       }
381:     };
382:     document.addEventListener('keydown', handleKeyDown);
383:     return () => document.removeEventListener('keydown', handleKeyDown);
384:   }, [handleSave]);
385:   const handleClearLocal = useCallback(async () => {
386:     try {
387:       if (!selectedFolder) {
388:         throw new Error('No folder selected for local patterns');
389:       }
390:       setApplyingPatterns(true);
391:       await clearIgnorePatterns(selectedFolder);
392:       setCurrentLocalPatterns(''); // Clear the textarea
393:       setLastSavedLocal(prev => ({ ...prev, [selectedFolder]: null })); // Clear timestamp
394:       setApplyingPatterns(false);
395:       // Use toast instead of custom message
396:       showToast.success('Local patterns cleared successfully');
397:     } catch (error) {
398:       console.error('Error clearing local patterns:', error);
399:       setApplyingPatterns(false);
400:       showToast.error('Error clearing local patterns', error instanceof Error ? error.message : String(error));
401:     }
402:   }, [selectedFolder, clearIgnorePatterns]);
403:   const handleResetLocal = useCallback(async () => {
404:     try {
405:       if (!selectedFolder) {
406:         throw new Error('No folder selected for local patterns');
407:       }
408:       setApplyingPatterns(true);
409:       await resetIgnorePatterns(false, selectedFolder);
410:       // Patterns will reload via event, maybe update timestamp based on that?
411:       // For now, let's clear it as we don't know the *exact* save time of the reset default
412:       setLastSavedLocal(prev => ({ ...prev, [selectedFolder]: null })); 
413:       setApplyingPatterns(false);
414:       // Use toast instead of custom message
415:       showToast.success('Local patterns reset successfully');
416:     } catch (error) {
417:       console.error('Error resetting local patterns:', error);
418:       setApplyingPatterns(false);
419:       showToast.error('Error resetting local patterns', error instanceof Error ? error.message : String(error));
420:     }
421:   }, [selectedFolder, resetIgnorePatterns]);
422:   const handleTestPatterns = useCallback(async () => {
423:     if (!selectedFolder) {
424:       setTestError("Please select a local folder to test patterns.");
425:       return;
426:     }
427:     setIsTestingPatterns(true);
428:     setTestResults(null); // Clear previous results
429:     setTestError(null);
430:     try {
431:       // 1. Construct the effective patterns (similar to preview logic)
432:       const currentGlobalEdit = currentGlobalPatterns.split('\n').filter(p => p.trim());
433:       // const currentLocalEdit = currentLocalPatterns.split('\n').filter(p => p.trim()); // Unused
434:       // const savedGlobalPatterns = (globalPatternsState?.patterns ?? '').split('\n').filter(p => p.trim()); // Unused
435:       // For testing, always use the *current edits* for the local patterns if a folder is selected
436:       const activeLocal = currentLocalPatterns.split('\n').filter(p => p.trim()); 
437:       const safeExcludedSystem = Array.isArray(excludedSystemPatterns) ? excludedSystemPatterns : [];
438:       const activeSystemPatterns = systemIgnorePatterns.filter(p => !safeExcludedSystem.includes(p));
439:       const effectivePatternsMap = new Map<string, 'system' | 'global' | 'local'>();
440:       activeSystemPatterns.forEach(p => effectivePatternsMap.set(p, 'system'));
441:       // Use current global edits for testing
442:       currentGlobalEdit.forEach(p => effectivePatternsMap.set(p, 'global'));
443:       // Use current local edits for testing
444:       activeLocal.forEach(p => effectivePatternsMap.set(p, 'local'));
445:       const patternsToTest = Array.from(effectivePatternsMap.keys());
446:       // 2. Call the IPC handler
447:       const result = await window.electron.testIgnorePatterns({
448:         folderPath: selectedFolder,
449:         patterns: patternsToTest.join('\n'), // Join array into newline-separated string
450:       });
451:       if (result.success) {
452:         setTestResults({
453:           ignoredCount: result.ignoredCount ?? 0,
454:           ignoredFiles: result.ignoredFiles ?? [],
455:           totalFilesChecked: result.totalFilesChecked ?? 0,
456:         });
457:       } else {
458:         setTestError(result.error || "Failed to test patterns.");
459:       }
460:     } catch (error) {
461:       console.error("Error invoking test-ignore-patterns:", error);
462:       setTestError(error instanceof Error ? error.message : "An unknown error occurred during testing.");
463:     } finally {
464:       setIsTestingPatterns(false);
465:     }
466:   }, [
467:     selectedFolder, 
468:     currentGlobalPatterns, 
469:     currentLocalPatterns, 
470:     systemIgnorePatterns, 
471:     excludedSystemPatterns
472:   ]);
473:   // Add explanation tooltips for the buttons
474:   const buttonTooltips = {
475:     save: 'Save current patterns',
476:     reset: 'Reset to last saved patterns',
477:     clear: 'Remove all patterns',
478:     cancel: 'Discard changes'
479:   };
480:   // Replace handleTextareaChange with a handler for the Editor component
481:   const handleEditorChange = (code: string) => {
482:     if (activeTab === 'global') setCurrentGlobalPatterns(code);
483:     else setCurrentLocalPatterns(code);
484:     // Add validation logic here if desired
485:   };
486:   // Helper to format timestamp
487:   const formatTimestamp = (date: Date | null): string => {
488:     if (!date) return '';
489:     return `Last saved: ${date.toLocaleTimeString()}`;
490:   };
491:   // Determine current timestamp to display
492:   const currentTimestamp = activeTab === 'global' 
493:     ? formatTimestamp(lastSavedGlobal)
494:     : formatTimestamp(selectedFolder ? lastSavedLocal[selectedFolder] : null);
495:   // --- Render ---
496:   if (!isOpen) return null;
497:   return (
498:     <div className={styles.modal} onClick={(e) => {
499:       if (e.target === e.currentTarget) onClose();
500:     }}>
501:       <div className={styles.content}>
502:         <div className={styles.header}>
503:           <h2>
504:             Ignore Patterns
505:             {applyingPatterns && <span className={styles.applying}>(Applying...)</span>}
506:           </h2>
507:           <Button 
508:             variant="ghost" 
509:             size="sm" 
510:             onClick={onClose} 
511:             aria-label="Close" 
512:             disabled={applyingPatterns}
513:             className={styles.closeButton}
514:           >
515:             <X size={16} />
516:           </Button>
517:         </div>
518:         <div className={styles.description}>
519:             Manage patterns to exclude files from processing. Global patterns apply everywhere, local patterns apply only to the selected folder. System patterns can be toggled on/off globally.
520:         </div>
521:         {/* Scope Selector (Tabs) */}
522:         <div className={styles.scopeSelector}>
523:             <Button variant={activeTab === "global" ? "secondary" : "ghost"} className={`${styles.scopeBtn} ${activeTab === "global" ? styles.active : ""}`} onClick={() => handleTabChange(true)} disabled={applyingPatterns}> Global </Button>
524:             <Button variant={activeTab === "local" ? "secondary" : "ghost"} className={`${styles.scopeBtn} ${activeTab === "local" ? styles.active : ""}`} onClick={() => handleTabChange(false)} disabled={applyingPatterns}> Local Folder </Button>
525:         </div>
526:         {/* Global Tab Content */}
527:         {activeTab === "global" && (
528:           <>
529:             {/* System Patterns Section */}
530:             <div className={styles.systemPatternsSection}>
531:               {/* Ensure excludedSystemPatterns is array before calculating length */}
532:               <h3 className={styles.sectionTitle}> System Defaults ({systemIgnorePatterns.length - (Array.isArray(excludedSystemPatterns) ? excludedSystemPatterns.length : 0)} active) </h3>
533:                {Object.entries(SYSTEM_PATTERN_CATEGORIES).map(([category, patternsInCategory]) => { // Renamed variable
534:                     // Ensure excludedSystemPatterns is array before filtering
535:                     const safeExcluded = Array.isArray(excludedSystemPatterns) ? excludedSystemPatterns : [];
536:                     // Filter patterns from the *main* system list that belong to this category
537:                     const categoryPatterns = systemIgnorePatterns.filter(p => patternsInCategory.includes(p));
538:                     if (categoryPatterns.length === 0) return null; // Skip empty categories
539:                     const enabledInCategory = categoryPatterns.filter(p => !safeExcluded.includes(p)).length;
540:                     return (
541:                         <div key={category} className={`${styles.patternCategory} ${expandedCategories[category] ? styles.categoryExpanded : ''}`}>
542:                           <div className={styles.categoryHeader} onClick={() => toggleCategory(category)}>
543:                             <div className={styles.categoryTitle}> {category.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())} </div>
544:                             <div className={styles.categoryMeta}>
545:                               <span className={styles.categoryCount}> {enabledInCategory}/{categoryPatterns.length} </span>
546:                               <Plus 
547:                                 size={16} 
548:                                 className={`${styles.accordionIcon} ${expandedCategories[category] ? styles.rotated : ''}`} 
549:                               />
550:                             </div>
551:                           </div>
552:                           {expandedCategories[category] && (
553:                             <div className={styles.categoryItems}>
554:                               {categoryPatterns.map(pattern => {
555:                                 // Ensure excludedSystemPatterns is array before checking includes
556:                                 const safeExcludedInner = Array.isArray(excludedSystemPatterns) ? excludedSystemPatterns : [];
557:                                 const isEnabled = !safeExcludedInner.includes(pattern);
558:                                 return (
559:                                   <div key={pattern} className={`${styles.systemPatternItem} ${isEnabled ? '' : styles.disabledPattern}`} data-pattern={pattern}>
560:                                     <span className={styles.patternText} title={pattern}>{pattern}</span>
561:                                     <Switch
562:                                         checked={isEnabled}
563:                                         onChange={() => handleToggleSystemPattern(pattern)}
564:                                         size="sm"
565:                                         className={styles.smallerSwitch}
566:                                         id={`switch-${pattern}-${category}`} // Make ID more unique
567:                                         aria-label={pattern} // Use pattern as label
568:                                     />
569:                                   </div>
570:                                 );
571:                               })}
572:                             </div>
573:                           )}
574:                         </div>
575:                     );
576:                 })}
577:             </div>
578:             {/* Global Custom Patterns Section - Use Editor */}
579:             <div className={styles.patternEntrySection}>
580:                 <div className={styles.sectionHeader}> {/* New container for title + timestamp */}
581:                   <h3 className={styles.sectionTitle}> Global Custom Patterns </h3>
582:                   {isLoadingPatterns ? (
583:                     <span className={styles.loadingIndicator}>Loading...</span>
584:                   ) : (
585:                     <span className={styles.timestamp}>{currentTimestamp}</span>
586:                   )}
587:                 </div>
588:                 <div ref={activeTab === 'global' ? editorContainerRef : null} className={styles.editorContainer}> {/* Optional: Add a container for styling */} 
589:                   <Editor
590:                     value={currentGlobalPatterns}
591:                     onValueChange={handleEditorChange}
592:                     highlight={(code) => {
593:                       // Use Prism.highlight and Prism.languages
594:                       try {
595:                         // Ensure the language is loaded before highlighting
596:                         if (Prism.languages.ignore) {
597:                           return Prism.highlight(code, Prism.languages.ignore, 'ignore');
598:                         } else {
599:                           console.warn("Prism language 'ignore' not loaded yet.");
600:                           return code; // Return unhighlighted if language missing
601:                         }
602:                       } catch (e) {
603:                         console.warn("Prism highlighting failed:", e);
604:                         return code; // Return plain code on error
605:                       }
606:                     }}
607:                     padding={10}
608:                     className={styles.patternsEditor} 
609:                     textareaClassName={styles.patternsEditorTextarea} 
610:                     style={{
611:                       // Use CSS variables for theme compatibility
612:                       backgroundColor: 'var(--background-primary)', 
613:                       fontFamily: 'var(--font-mono, "Fira code", "Fira Mono", monospace)', // Use theme mono font if available
614:                       fontSize: 14,
615:                       color: 'var(--text-primary)',
616:                       outline: 0,
617:                     }}
618:                     disabled={applyingPatterns}
619:                   />
620:                 </div>
621:                 <div className={styles.buttonGroup}>
622:                   <Button
623:                     variant="secondary"
624:                     size="sm"
625:                     onClick={() => resetIgnorePatterns(true)}
626:                     disabled={applyingPatterns}
627:                     title={buttonTooltips.reset}
628:                   >
629:                     Reset Global
630:                   </Button>
631:                   <Button
632:                     variant="secondary"
633:                     size="sm"
634:                     onClick={() => {
635:                       setCurrentGlobalPatterns('');
636:                       onExcludedSystemPatternsChange([]);
637:                     }}
638:                     disabled={applyingPatterns}
639:                     title={buttonTooltips.clear}
640:                   >
641:                     Clear Global
642:                   </Button>
643:                   <Button
644:                     variant="ghost"
645:                     size="sm"
646:                     onClick={onClose}
647:                     disabled={applyingPatterns}
648:                     title={buttonTooltips.cancel}
649:                   >
650:                     Cancel
651:                   </Button>
652:                   <Button
653:                     variant="primary"
654:                     size="sm"
655:                     onClick={handleSaveGlobalPatterns}
656:                     disabled={applyingPatterns}
657:                     title={buttonTooltips.save}
658:                   >
659:                     {applyingPatterns ? 'Saving...' : 'Save'}
660:                   </Button>
661:                 </div>
662:             </div>
663:           </>
664:         )}
665:         {/* Local Tab Content - Use Editor */}
666:         {activeTab === "local" && (
667:             <div className={styles.patternEntrySection}>
668:                 <div className={styles.sectionHeader}> {/* New container for title + timestamp */}
669:                   <h3 className={styles.sectionTitle}> Local Custom Patterns </h3>
670:                   {isLoadingPatterns ? (
671:                     <span className={styles.loadingIndicator}>Loading...</span>
672:                   ) : (
673:                     <span className={styles.timestamp}>{currentTimestamp}</span>
674:                   )}
675:                 </div>
676:                 <div className={styles.folderSelector}>
677:                     <label htmlFor="folder-select-dropdown">Select Folder</label>
678:                     <div id="folder-select-dropdown" className={styles.customSelect} onClick={() => !applyingPatterns && setFolderSelectOpen(!folderSelectOpen)} aria-haspopup="listbox">
679:                         <div className={styles.selectedValue} role="button" aria-expanded={folderSelectOpen}>
680:                             {selectedFolder ? truncatePath(selectedFolder) : 'Select a folder'}
681:                             <ChevronDown size={16} className={`${styles.chevron} ${folderSelectOpen ? styles.open : ''}`} />
682:                         </div>
683:                         {folderSelectOpen && (
684:                         <div className={styles.optionsContainer} role="listbox">
685:                             {recentFolders.length > 0 ? (
686:                             recentFolders.map((folder, index) => (
687:                                 <div key={index} className={styles.option} onClick={() => handleFolderChange(folder)} role="option" aria-selected={folder === selectedFolder}> {folder} </div>
688:                             ))
689:                             ) : (
690:                             <div className={styles.option} role="option" aria-disabled="true"> {selectedFolder || 'No recent folders'} </div>
691:                             )}
692:                         </div>
693:                         )}
694:                     </div>
695:                     <div className={styles.pathDisplay}> Path: {selectedFolder ? `${truncatePath(selectedFolder)}/.repo_ignore` : 'N/A'} </div>
696:                 </div>
697:                 <div ref={activeTab === 'local' ? editorContainerRef : null} className={styles.editorContainer}> {/* Optional: Add a container */} 
698:                   <Editor
699:                     value={currentLocalPatterns}
700:                     onValueChange={handleEditorChange}
701:                     highlight={(code) => {
702:                       // Use Prism.highlight and Prism.languages
703:                       try {
704:                         // Ensure the language is loaded before highlighting
705:                         if (Prism.languages.ignore) {
706:                           return Prism.highlight(code, Prism.languages.ignore, 'ignore');
707:                         } else {
708:                           console.warn("Prism language 'ignore' not loaded yet.");
709:                           return code; // Return unhighlighted if language missing
710:                         }
711:                       } catch (e) {
712:                         console.warn("Prism highlighting failed:", e);
713:                         return code; // Return plain code on error
714:                       }
715:                     }}
716:                     padding={10}
717:                     className={styles.patternsEditor} 
718:                     textareaClassName={styles.patternsEditorTextarea} 
719:                     style={{
720:                       // Use CSS variables for theme compatibility
721:                       backgroundColor: 'var(--background-primary)', 
722:                       fontFamily: 'var(--font-mono, "Fira code", "Fira Mono", monospace)', // Use theme mono font if available
723:                       fontSize: 14,
724:                       color: 'var(--text-primary)',
725:                       outline: 0,
726:                     }}
727:                     disabled={applyingPatterns || !selectedFolder}
728:                   />
729:                 </div>
730:                 <div className={styles.buttonGroup}>
731:                   <Button
732:                     variant="secondary"
733:                     size="sm"
734:                     onClick={handleResetLocal}
735:                     disabled={applyingPatterns || !selectedFolder}
736:                     title={buttonTooltips.reset}
737:                   >
738:                     Reset Local
739:                   </Button>
740:                   <Button
741:                     variant="secondary"
742:                     size="sm"
743:                     onClick={handleClearLocal}
744:                     disabled={applyingPatterns || !selectedFolder}
745:                     title={buttonTooltips.clear}
746:                   >
747:                     Clear Local
748:                   </Button>
749:                   <Button
750:                     variant="ghost"
751:                     size="sm"
752:                     onClick={onClose}
753:                     disabled={applyingPatterns}
754:                     title={buttonTooltips.cancel}
755:                   >
756:                     Cancel
757:                   </Button>
758:                   <Button
759:                     variant="primary"
760:                     size="sm"
761:                     onClick={handleSave}
762:                     disabled={applyingPatterns || !selectedFolder}
763:                     title={buttonTooltips.save}
764:                   >
765:                     {applyingPatterns ? 'Saving...' : 'Save'}
766:                   </Button>
767:                   <Button 
768:                     variant="secondary"
769:                     size="sm" 
770:                     onClick={handleTestPatterns} 
771:                     disabled={applyingPatterns || isTestingPatterns || !selectedFolder}
772:                     title="Test current patterns against selected folder"
773:                     className={styles.testButton} 
774:                   >
775:                     {isTestingPatterns ? (
776:                       <Loader2 size={16} className={styles.loadingIcon} />
777:                     ) : (
778:                       <Play size={16} />
779:                     )}
780:                     Test
781:                   </Button>
782:                 </div>
783:             </div>
784:         )}
785:         {/* Test Results Section (Conditionally Rendered) */}
786:         {(testResults || testError) && (
787:             <div className={styles.testResultsSection}>
788:               <h4 className={styles.testResultsHeader}>
789:                 Test Results {testResults ? `(${testResults.ignoredCount} ignored / ${testResults.totalFilesChecked} total)` : ''}
790:               </h4>
791:               {testError && (
792:                 <div className={`${styles.testResultItem} ${styles.testError}`}>Error: {testError}</div>
793:               )}
794:               {testResults && testResults.ignoredFiles.length > 0 && (
795:                 <div className={styles.testResultsList}>
796:                   {testResults.ignoredFiles.map((file, index) => (
797:                     <div key={index} className={styles.testResultItem} title={file}>{file}</div>
798:                   ))}
799:                 </div>
800:               )}
801:               {testResults && testResults.ignoredFiles.length === 0 && !testError && (
802:                 <div className={`${styles.testResultItem} ${styles.noResults}`}>No files matched the current patterns.</div>
803:               )}
804:             </div>
805:           )}
806:         {/* Preview Section (Always visible) - Updated Render Logic */}
807:         <div className={styles.previewSection}>
808:             <div className={styles.previewContainer}>
809:                 <div className={styles.previewHeader}>
810:                     <span>Effective Patterns Preview</span>
811:                     <span className={styles.patternCount}>
812:                         {actualPatternCount} active
813:                     </span>
814:                 </div>
815:                 {/* Check if mergedPreview is the new array structure */}
816:                 {Array.isArray(mergedPreview) ? mergedPreview.map((lineData, index) => {
817:                     if (!lineData.pattern.trim() && lineData.source === 'comment') {
818:                        // Render empty lines used as separators differently if needed, or skip
819:                        return <div key={index} className={styles.previewSeparator}></div>;
820:                     }
821:                     let badgeText = '';
822:                     let lineClass = '';
823:                     let badgeClass = '';
824:                     switch (lineData.source) {
825:                       case 'system':
826:                         badgeText = 'System';
827:                         lineClass = styles.previewSystem;
828:                         badgeClass = styles.previewBadgeSystem;
829:                         break;
830:                       case 'global':
831:                         badgeText = 'Global';
832:                         lineClass = styles.previewGlobal;
833:                         badgeClass = styles.previewBadgeGlobal;
834:                         break;
835:                       case 'local':
836:                         badgeText = 'Local';
837:                         lineClass = styles.previewLocal;
838:                         badgeClass = styles.previewBadgeLocal;
839:                         break;
840:                       case 'comment':
841:                         lineClass = styles.previewComment;
842:                         break;
843:                       default:
844:                         // Should not happen with the new structure
845:                         lineClass = styles.previewUnknown;
846:                         break;
847:                     }
848:                     return (
849:                         <div key={index} className={`${styles.previewLine} ${lineClass}`}>
850:                             {/* Display pattern or comment header */}
851:                             <span className={styles.previewPatternText}>{lineData.pattern}</span>
852:                              {badgeText && <span className={`${styles.previewBadge} ${badgeClass}`}>{badgeText}</span>}
853:                         </div>
854:                     );
855:                 }) : (
856:                   // Fallback for old string format (should ideally be removed later)
857:                   <div className={styles.previewLine}>Invalid preview format</div>
858:                 )}
859:             </div>
860:         </div>
861:       </div>
862:     </div>
863:   );
864: };
865: export default IgnorePatternsWithErrorBoundary;

================
File: src/components/Sidebar.tsx
================
  1: import React, { useState, useEffect, useRef, useCallback, useMemo } from "react";
  2: import { SidebarProps, TreeNode, SortOrder, FileData } from "../types/FileTypes";
  3: import TreeItem from "./TreeItem";
  4: import FileTreeHeader from "./FileTreeHeader";
  5: import IgnorePatterns from "./IgnorePatterns";
  6: import { FolderPlus } from "lucide-react";
  7: import { Button } from "./ui";
  8: import SearchBar from "./SearchBar";
  9: import styles from "./Sidebar.module.css";
 10: import { ModelInfo } from "../types/ModelTypes";
 11: import { Toast as _Toast, showToast as _showToast } from "./ui/Toast";
 12: // Extend the existing SidebarProps from FileTypes
 13: interface ExtendedSidebarProps extends SidebarProps {
 14:   reloadFolder: () => void;
 15:   clearSelection: () => void;
 16:   removeAllFolders: () => void;
 17:   setIgnorePatterns: (patterns: string) => void;
 18:   loadIgnorePatterns: (folderPath: string, isGlobal?: boolean) => Promise<void>;
 19:   saveIgnorePatterns: (patterns: string, isGlobal: boolean, folderPath?: string) => Promise<void>;
 20:   resetIgnorePatterns: (isGlobal: boolean, folderPath?: string) => Promise<void>;
 21:   systemIgnorePatterns: string[];
 22:   clearIgnorePatterns: (folderPath: string) => Promise<void>;
 23:   onClearSelectionClick: () => void;
 24:   onRemoveAllFoldersClick: () => void;
 25:   fileTreeSortOrder: SortOrder;
 26:   onSortOrderChange: (order: SortOrder) => void;
 27:   globalPatternsState: IgnorePatternsState;
 28:   localPatternsState: IgnorePatternsState;
 29:   onExcludedSystemPatternsChange: (patterns: string[]) => void;
 30:   // Add model-related properties
 31:   _availableModels: ModelInfo[] | null;
 32:   _selectedModelId: string | null;
 33:   _onModelChange: (modelId: string | null) => void;
 34: }
 35: // Define IgnorePatternsState interface
 36: interface IgnorePatternsState {
 37:   patterns: string;
 38:   excludedSystemPatterns: string[];
 39: }
 40: // Debounce delay in ms
 41: const DEBOUNCE_DELAY = 200;
 42: // Use a timeout to prevent infinite tree building loops
 43: const TREE_BUILD_TIMEOUT = 5000;
 44: const Sidebar: React.FC<ExtendedSidebarProps> = ({
 45:   selectedFolder,
 46:   openFolder,
 47:   allFiles,
 48:   selectedFiles,
 49:   toggleFileSelection,
 50:   toggleFolderSelection,
 51:   searchTerm,
 52:   onSearchChange,
 53:   selectAllFiles,
 54:   deselectAllFiles,
 55:   expandedNodes,
 56:   toggleExpanded,
 57:   reloadFolder,
 58:   clearSelection,
 59:   removeAllFolders,
 60:   setIgnorePatterns,
 61:   loadIgnorePatterns,
 62:   saveIgnorePatterns,
 63:   resetIgnorePatterns,
 64:   systemIgnorePatterns,
 65:   clearIgnorePatterns,
 66:   onClearSelectionClick,
 67:   onRemoveAllFoldersClick,
 68:   fileTreeSortOrder,
 69:   onSortOrderChange,
 70:   globalPatternsState,
 71:   localPatternsState,
 72:   onExcludedSystemPatternsChange,
 73:   // Model-related props - use proper syntax for destructuring with _ prefix
 74:   availableModels: _availableModels,
 75:   selectedModelId: _selectedModelId,
 76:   onModelChange: _onModelChange,
 77: }) => {
 78:   const [fileTree, setFileTree] = useState<TreeNode[]>([]);
 79:   const [sidebarWidth, setSidebarWidth] = useState(300);
 80:   const [isResizing, setIsResizing] = useState(false);
 81:   // State for ignore patterns modal
 82:   const [ignoreModalOpen, setIgnoreModalOpen] = useState(false);
 83:   const [globalIgnorePatterns, /*REMOVE: setGlobalIgnorePatterns*/] = useState("");
 84:   const [localIgnorePatterns, /*REMOVE: setLocalIgnorePatterns*/] = useState("");
 85:   // Min and max width constraints
 86:   const MIN_SIDEBAR_WIDTH = 200;
 87:   const MAX_SIDEBAR_WIDTH = 500;
 88:   // All component level refs need to be defined here
 89:   const loadedFoldersRef = useRef<Set<string>>(new Set());
 90:   const lastProcessedFolderRef = useRef<string | null>(null);
 91:   const isBuildingTreeRef = useRef(false);
 92:   const buildTimeoutRef = useRef<NodeJS.Timeout | null>(null);
 93:   const lastSelectedFilesRef = useRef<string[]>([]);
 94:   // Cache the previous selected files to optimize render
 95:   useEffect(() => {
 96:     lastSelectedFilesRef.current = selectedFiles;
 97:   }, [selectedFiles]);
 98:   // Helper function for file tree - Flatten the tree for rendering
 99:   const flattenTree = useCallback((nodes: TreeNode[]): TreeNode[] => {
100:     let result: TreeNode[] = [];
101:     for (const node of nodes) {
102:       result.push(node);
103:       if (node.type === "directory" && node.isExpanded && node.children && node.children.length > 0) {
104:         result = result.concat(flattenTree(node.children));
105:       }
106:     }
107:     return result;
108:   }, []);
109:   // Helper function for file tree - Filter the tree based on search term with performance optimizations
110:   const filterTree = useCallback((nodes: TreeNode[], term: string): TreeNode[] => {
111:     if (!term) return nodes;
112:     const lowerTerm = term.toLowerCase();
113:     // Helper function to check if a node or its children match the search term
114:     const hasMatch = (node: TreeNode): boolean => {
115:       if (node.name.toLowerCase().includes(lowerTerm)) {
116:         return true;
117:       }
118:       if (node.type === "directory" && node.children && node.children.length > 0) {
119:         return node.children.some(hasMatch);
120:       }
121:       return false;
122:     };
123:     const filterNode = (node: TreeNode): TreeNode | null => {
124:       if (!hasMatch(node)) {
125:         return null;
126:       }
127:       if (node.type === "file") {
128:         return node;
129:       }
130:       if (node.type === "directory") {
131:         const filteredChildren = node.children 
132:           ? node.children
133:               .map(filterNode)
134:               .filter((n): n is TreeNode => n !== null)
135:           : [];
136:         return {
137:           ...node,
138:           isExpanded: true, // Always expand matching directories
139:           children: filteredChildren
140:         };
141:       }
142:       return null;
143:     };
144:     return nodes
145:       .map(filterNode)
146:       .filter((n): n is TreeNode => n !== null);
147:   }, []);
148:   // Use memoization to avoid unnecessary recalculations
149:   const memoizedFilteredTree = useMemo(() => {
150:     return searchTerm ? filterTree(fileTree, searchTerm) : fileTree;
151:   }, [fileTree, searchTerm, filterTree]);
152:   const memoizedFlattenedTree = useMemo(() => {
153:     return flattenTree(memoizedFilteredTree);
154:   }, [memoizedFilteredTree, flattenTree]);
155:   // Handle mouse down for resizing
156:   const handleResizeStart = (e: React.MouseEvent<HTMLDivElement>) => {
157:     e.preventDefault();
158:     setIsResizing(true);
159:   };
160:   // Handle resize effect
161:   useEffect(() => {
162:     const handleResize = (e: globalThis.MouseEvent) => {
163:       if (isResizing) {
164:         const newWidth = e.clientX;
165:         if (newWidth >= MIN_SIDEBAR_WIDTH && newWidth <= MAX_SIDEBAR_WIDTH) {
166:           setSidebarWidth(newWidth);
167:         }
168:       }
169:     };
170:     const handleResizeEnd = () => {
171:       setIsResizing(false);
172:     };
173:     document.addEventListener("mousemove", handleResize);
174:     document.addEventListener("mouseup", handleResizeEnd);
175:     return () => {
176:       document.removeEventListener("mousemove", handleResize);
177:       document.removeEventListener("mouseup", handleResizeEnd);
178:     };
179:   }, [isResizing]);
180:   // Load ignore patterns when folder changes - with optimization to prevent infinite loops
181:   useEffect(() => {
182:     // Skip if no folder is selected
183:     if (!selectedFolder) return;
184:     // Skip if we already processed this exact folder
185:     if (lastProcessedFolderRef.current === selectedFolder && 
186:         loadedFoldersRef.current.has(selectedFolder)) return;
187:     // Set the last processed folder reference
188:     lastProcessedFolderRef.current = selectedFolder;
189:     // Track that we're processing this folder
190:     loadedFoldersRef.current.add(selectedFolder);
191:     // Load the patterns
192:     loadIgnorePatterns(selectedFolder, false);
193:   }, [selectedFolder, loadIgnorePatterns]);
194:   // Sort file tree nodes - memoized with useCallback to prevent recreation on every render
195:   const sortFileTreeNodes = useCallback((nodes: TreeNode[]): TreeNode[] => {
196:     if (!nodes || nodes.length === 0) return [];
197:     // Create a new array to avoid mutating the input
198:     return [...nodes].sort((a, b) => {
199:       // Always sort directories first
200:       if (a.type === "directory" && b.type === "file") return -1;
201:       if (a.type === "file" && b.type === "directory") return 1;
202:       // Sort based on selected sort order
203:       switch (fileTreeSortOrder) {
204:         case "name-ascending":
205:           return a.name.localeCompare(b.name);
206:         case "name-descending":
207:           return b.name.localeCompare(a.name);
208:         case "tokens-ascending":
209:           return (a.fileData?.tokenCount || 0) - (b.fileData?.tokenCount || 0);
210:         case "tokens-descending":
211:           return (b.fileData?.tokenCount || 0) - (a.fileData?.tokenCount || 0);
212:         case "date-ascending":
213:           return (a.fileData?.lastModified || 0) - (b.fileData?.lastModified || 0);
214:         case "date-descending":
215:           return (b.fileData?.lastModified || 0) - (a.fileData?.lastModified || 0);
216:         default:
217:           return a.name.localeCompare(b.name);
218:       }
219:     });
220:   }, [fileTreeSortOrder]);
221:   // Apply sort recursively to the entire tree
222:   const sortNodesRecursively = useCallback((nodes: TreeNode[]): TreeNode[] => {
223:     if (!nodes || nodes.length === 0) return [];
224:     // Sort the current level
225:     const sortedNodes = sortFileTreeNodes(nodes);
226:     // Recursively sort children
227:     return sortedNodes.map(node => {
228:       if (node.type === "directory" && node.children && node.children.length > 0) {
229:         return {
230:           ...node,
231:           children: sortNodesRecursively(node.children)
232:         };
233:       }
234:       return node;
235:     });
236:   }, [sortFileTreeNodes]);
237:   // Build file tree structure from flat list of files - optimized
238:   const buildFileTree = useCallback(async (files: FileData[], rootFolder: string): Promise<TreeNode[]> => {
239:     if (!files || files.length === 0) return [];
240:     // Create a stable map of paths to prevent recursion issues
241:     const pathMap = new Map<string, FileData>();
242:     files.forEach(file => {
243:       if (file.path) {
244:         pathMap.set(file.path, file);
245:       }
246:     });
247:     try {
248:       // Create a map to store the file tree structure
249:       const fileMap: Record<string, any> = {};
250:       // Process each file
251:       Array.from(pathMap.entries()).forEach(([path, file]) => {
252:         // Use the pre-calculated relativePath from the main process if available,
253:         // otherwise fall back to the current calculation method
254:         let relativePath = file.relativePath || '';
255:         // If relativePath is not provided, calculate it (fallback for backward compatibility)
256:         if (!relativePath && path.startsWith(rootFolder)) {
257:           relativePath = path.substring(rootFolder.length);
258:           if (relativePath.startsWith('/') || relativePath.startsWith('\\')) {
259:             relativePath = relativePath.substring(1);
260:           }
261:         }
262:         // Skip files with missing relative paths
263:         if (!relativePath) {
264:           console.warn(`Skipping file with missing relative path: ${path}`);
265:           return;
266:         }
267:         const parts = relativePath.split(/[/\\]/);
268:         let current = fileMap;
269:         // Build the tree structure
270:         parts.forEach((part, index) => {
271:           if (!current[part]) {
272:             const fullPath = rootFolder + '/' + parts.slice(0, index + 1).join('/');
273:             const nodeId = `${fullPath}`;
274:             current[part] = {
275:               name: part,
276:               path: fullPath,
277:               id: nodeId, 
278:               type: index === parts.length - 1 ? "file" as const : "directory" as const,
279:               children: {},
280:               fileData: index === parts.length - 1 ? file : undefined
281:             };
282:           }
283:           current = current[part].children;
284:         });
285:       });
286:       // Convert the nested object structure to an array of TreeNodes
287:       const convertToTreeNodes = (
288:         obj: Record<string, any>,
289:         level = 0
290:       ): TreeNode[] => {
291:         const nodes = Object.values(obj)
292:           .filter(item => item !== undefined)
293:           .map((item: any): TreeNode => {
294:             const nodeId = item.id;
295:             const isNodeExpanded = expandedNodes.get(nodeId);
296:             // Auto-expand first level when no explicit expansion state is saved
297:             const shouldAutoExpand = isNodeExpanded === undefined && level < 1;
298:             if (item.type === "directory") {
299:               const children = convertToTreeNodes(item.children, level + 1);
300:               return {
301:                 id: nodeId,
302:                 name: item.name,
303:                 path: item.path,
304:                 type: "directory" as const,
305:                 children: children,
306:                 isExpanded: isNodeExpanded !== undefined ? isNodeExpanded : shouldAutoExpand,
307:                 depth: level,
308:               };
309:             }
310:             return {
311:               id: nodeId,
312:               name: item.name,
313:               path: item.path,
314:               type: "file" as const,
315:               fileData: item.fileData,
316:               depth: level,
317:             };
318:           });
319:         return nodes;
320:       };
321:       // Convert with timeout protection
322:       let result = convertToTreeNodes(fileMap);
323:       // Apply sorting recursively
324:       result = sortNodesRecursively(result);
325:       return result;
326:     } catch (error) {
327:       console.error('Error building file tree:', error);
328:       return [];
329:     }
330:   }, [expandedNodes, sortNodesRecursively]);
331:   // Set up the effect for building the file tree with debouncing and cleanup
332:   useEffect(() => {
333:     if (!allFiles || allFiles.length === 0) {
334:       setFileTree([]);
335:       isBuildingTreeRef.current = false;
336:       return;
337:     }
338:     // Skip if we're already building a tree
339:     if (isBuildingTreeRef.current) {
340:       console.log('Tree building in progress, skipping...');
341:       return;
342:     }
343:     // Clear any existing timeout
344:     if (buildTimeoutRef.current) {
345:       clearTimeout(buildTimeoutRef.current);
346:       buildTimeoutRef.current = null;
347:     }
348:     let isCurrentBuild = true;
349:     const buildId = Math.random().toString(36).substring(2, 9); // Unique ID for logging
350:     const buildTreeWithDebounce = async () => {
351:       try {
352:         isBuildingTreeRef.current = true;
353:         console.log(`Starting tree build ${buildId}...`);
354:         // Safety timeout to prevent tree building from hanging
355:         const timeoutPromise = new Promise<TreeNode[]>((_, reject) => {
356:           buildTimeoutRef.current = setTimeout(() => {
357:             console.warn(`Tree build ${buildId} timed out after ${TREE_BUILD_TIMEOUT}ms`);
358:             reject(new Error('Tree build timed out'));
359:           }, TREE_BUILD_TIMEOUT);
360:         });
361:         // Actual tree building process
362:         const buildPromise = buildFileTree(allFiles, selectedFolder || "");
363:         // Race between timeout and completion
364:         const result = await Promise.race([timeoutPromise, buildPromise]);
365:         // Only update if this is still the current build and we have a valid result
366:         if (isCurrentBuild && result) {
367:           setFileTree(result);
368:           console.log(`Tree build ${buildId} completed successfully with ${result.length} root nodes`);
369:         }
370:       } catch (error) {
371:         console.error(`Tree build ${buildId} failed:`, error);
372:         if (isCurrentBuild) {
373:           setFileTree([]);
374:         }
375:       } finally {
376:         if (isCurrentBuild) {
377:           isBuildingTreeRef.current = false;
378:           if (buildTimeoutRef.current) {
379:             clearTimeout(buildTimeoutRef.current);
380:             buildTimeoutRef.current = null;
381:           }
382:         }
383:       }
384:     };
385:     // Debounce the tree build to avoid unnecessary work during rapid state changes
386:     const timeoutId = setTimeout(buildTreeWithDebounce, DEBOUNCE_DELAY);
387:     return () => {
388:       isCurrentBuild = false;
389:       clearTimeout(timeoutId);
390:       if (buildTimeoutRef.current) {
391:         clearTimeout(buildTimeoutRef.current);
392:         buildTimeoutRef.current = null;
393:       }
394:       console.log(`Cleaning up tree build ${buildId}`);
395:     };
396:   }, [allFiles, selectedFolder, buildFileTree]);
397:   // Handle opening the ignore patterns modal
398:   const handleOpenIgnorePatterns = async (isGlobal = false) => {
399:     try {
400:       setIgnoreModalOpen(true);
401:       // Ensure we have patterns loaded
402:       if (isGlobal) {
403:         await loadPatterns(true);
404:       } else {
405:         await loadPatterns(false);
406:       }
407:     } catch (error) {
408:       console.error('Error opening ignore patterns modal:', error);
409:       // Reset modal state on error
410:       setIgnoreModalOpen(false);
411:     }
412:   };
413:   // Load patterns based on global or local scope
414:   const loadPatterns = useCallback(async (isGlobal: boolean) => {
415:     try {
416:       // Load global patterns if needed
417:       if (isGlobal) {
418:         if (!globalIgnorePatterns) {
419:           await loadIgnorePatterns('', true);
420:         } else {
421:           setIgnorePatterns(globalIgnorePatterns);
422:         }
423:       } 
424:       // Load local patterns if needed
425:       else if (selectedFolder && !localIgnorePatterns) {
426:         await loadIgnorePatterns(selectedFolder, false);
427:       } else if (selectedFolder) {
428:         setIgnorePatterns(localIgnorePatterns);
429:       }
430:     } catch (err) {
431:       console.error(`Error loading ${isGlobal ? 'global' : 'local'} patterns:`, err);
432:     }
433:   }, [selectedFolder, loadIgnorePatterns, globalIgnorePatterns, localIgnorePatterns, setIgnorePatterns]);
434:   // Get a list of available folders for the folder selector
435:   const getAvailableFolders = () => {
436:     const folders = new Set<string>();
437:     // Collect all unique folder paths
438:     allFiles.forEach((file) => {
439:       if (file.path) {
440:         // Extract directory without the file name
441:         const lastSlashIndex = Math.max(
442:           file.path.lastIndexOf('/'),
443:           file.path.lastIndexOf('\\')
444:         );
445:         if (lastSlashIndex > 0) {
446:           const folder = file.path.substring(0, lastSlashIndex);
447:           folders.add(folder);
448:         }
449:       }
450:     });
451:     return Array.from(folders);
452:   };
453:   // Count files excluded by ignore patterns
454:   const countExcludedFiles = () => {
455:     return allFiles.filter(file => file.excluded).length;
456:   };
457:   // Handle sort change events
458:   const handleSortChange = (newSortOrder: SortOrder) => {
459:     // Pass the sort order change back to the parent component
460:     if (fileTreeSortOrder !== newSortOrder) {
461:       // We need to handle this in the App component, not locally
462:       if (onSortOrderChange) {
463:         onSortOrderChange(newSortOrder);
464:       }
465:     }
466:   };
467:   const handleCloseIgnorePatterns = useCallback(() => {
468:     setIgnoreModalOpen(false);
469:   }, []);
470:   return (
471:     <div className={styles.sidebar} style={{ width: `${sidebarWidth}px` }} data-testid="sidebar">
472:       <FileTreeHeader 
473:         onOpenFolder={openFolder}
474:         onSortChange={handleSortChange}
475:         onClearSelection={onClearSelectionClick || clearSelection}
476:         onRemoveAllFolders={onRemoveAllFoldersClick || removeAllFolders}
477:         onReloadFileTree={reloadFolder}
478:         onOpenIgnorePatterns={() => handleOpenIgnorePatterns(false)}
479:         excludedFilesCount={countExcludedFiles()}
480:         currentSortOrder={fileTreeSortOrder}
481:       />
482:       {selectedFolder ? (
483:         <>
484:           <div className={styles.sidebarSearch}>
485:             <SearchBar searchTerm={searchTerm} onSearchChange={onSearchChange} />
486:           </div>
487:           <div className={styles.sidebarActions}>
488:             <Button
489:               variant="primary"
490:               size="sm"
491:               onClick={selectAllFiles}
492:               title="Select all files"
493:             >
494:               Select All
495:             </Button>
496:             <Button
497:               variant="primary"
498:               size="sm"
499:               onClick={deselectAllFiles}
500:               title="Deselect all files"
501:             >
502:               Deselect All
503:             </Button>
504:           </div>
505:           <div className={styles.fileTree}>
506:             {memoizedFlattenedTree.length > 0 ? (
507:               <>
508:                 {memoizedFlattenedTree.map((node) => (
509:                   <TreeItem
510:                     key={node.id}
511:                     node={node}
512:                     selectedFiles={selectedFiles}
513:                     toggleFileSelection={toggleFileSelection}
514:                     toggleFolderSelection={toggleFolderSelection}
515:                     toggleExpanded={toggleExpanded}
516:                   />
517:                 ))}
518:               </>
519:             ) : (
520:               <div className={styles.treeEmpty}>
521:                 {searchTerm
522:                   ? "No files match your search."
523:                   : "No files in this folder."}
524:               </div>
525:             )}
526:           </div>
527:         </>
528:       ) : (
529:         <div className={styles.sidebarEmptyState}>
530:           <FolderPlus size={48} className={styles.sidebarEmptyIcon} />
531:           <h3>No Folder Selected</h3>
532:           <p>Click the folder icon above to select a project folder.</p>
533:         </div>
534:       )}
535:       <div
536:         className={styles.sidebarResizeHandle}
537:         onMouseDown={handleResizeStart}
538:         title="Resize sidebar"
539:       />
540:       <IgnorePatterns 
541:         isOpen={ignoreModalOpen}
542:         onClose={handleCloseIgnorePatterns}
543:         globalPatternsState={globalPatternsState}
544:         localPatternsState={localPatternsState}
545:         localFolderPath={selectedFolder || ""}
546:         processingStatus={{ status: "idle", message: "" }}
547:         saveIgnorePatterns={async (patterns, isGlobal, folderPath) => {
548:           await Promise.resolve(saveIgnorePatterns(patterns, isGlobal, folderPath || ""));
549:         }}
550:         resetIgnorePatterns={async (isGlobal, folderPath) => {
551:           if (resetIgnorePatterns) {
552:             await Promise.resolve(resetIgnorePatterns(isGlobal, folderPath || ""));
553:           }
554:         }}
555:         clearIgnorePatterns={async (folderPath) => {
556:           await Promise.resolve(clearIgnorePatterns(folderPath));
557:         }}
558:         onExcludedSystemPatternsChange={onExcludedSystemPatternsChange}
559:         systemIgnorePatterns={systemIgnorePatterns}
560:         recentFolders={getAvailableFolders()}
561:       />
562:     </div>
563:   );
564: };
565: export default Sidebar;

================
File: src/App.tsx
================
   1: import React, { useState, useEffect, useCallback, useMemo, useRef } from "react";
   2: import Sidebar from "./components/Sidebar";
   3: import FileList from "./components/FileList";
   4: import ControlContainer from "./components/ControlContainer";
   5: import { FileData, FileTreeMode, SortOrder } from "./types/FileTypes";
   6: import { ThemeProvider } from "./context/ThemeContext";
   7: import ThemeToggle from "./components/ThemeToggle";
   8: import { generateAsciiFileTree, normalizePath, arePathsEqual } from "./utils/pathUtils";
   9: import { Github, HelpCircle } from "lucide-react";
  10: import styles from "./App.module.css";
  11: import { Dropdown } from "./components/ui";
  12: import { ConfirmationDialog } from "./components/ui/ConfirmationDialog";
  13: import { Button } from "./components/ui/Button";
  14: import { getSortIcon } from "./utils/sortIcons";
  15: // Import utilities from patternUtils
  16: import { SYSTEM_PATTERN_CATEGORIES, parseIgnorePatternsContent, IgnorePatternsState } from "./utils/patternUtils";
  17: import { OutputFormatType, OUTPUT_FORMAT_STORAGE_KEY } from './constants/outputFormats';
  18: import { formatAsXML, formatAsMarkdown, formatAsPlain, FileContent } from './utils/formatters';
  19: import { UserInstructionsWithTemplates } from './components/UserInstructionsWithTemplates';
  20: // Import model fetching utility
  21: import { fetchModels } from './utils/modelUtils';
  22: import { ModelInfo } from "./types/ModelTypes"; // Import the new ModelInfo type
  23: import { compressCode, removeComments, getLanguageFromFilename } from './utils/compressionUtils'; // Import compression utils and getLanguageFromFilename
  24: // Import Toast component
  25: import { Toast, showToast } from './components/ui/Toast';
  26: import GuideModal from './components/GuideModal';
  27: // Keys for localStorage
  28: const STORAGE_KEYS = {
  29:   SELECTED_FOLDER: "pastemax-selected-folder",
  30:   SELECTED_FILES: "pastemax-selected-files",
  31:   SORT_ORDER: "pastemax-sort-order",
  32:   SEARCH_TERM: "pastemax-search-term",
  33:   EXPANDED_NODES: "pastemax-expanded-nodes",
  34:   GLOBAL_IGNORE_PATTERNS: "pastemax-global-ignore-patterns-v2", // Added version suffix
  35:   SELECTED_MODEL_ID: "pastemax-selected-model-id", // New key
  36: };
  37: // Default system patterns as fallback if not provided by main process
  38: const DEFAULT_SYSTEM_PATTERNS = [
  39:   // Combine categories into one list for default state
  40:   ...SYSTEM_PATTERN_CATEGORIES.versionControl,
  41:   ...SYSTEM_PATTERN_CATEGORIES.buildOutput,
  42:   ...SYSTEM_PATTERN_CATEGORIES.caches,
  43:   ...SYSTEM_PATTERN_CATEGORIES.logs,
  44:   ...SYSTEM_PATTERN_CATEGORIES.ide,
  45:   ...SYSTEM_PATTERN_CATEGORIES.temp,
  46:   ...SYSTEM_PATTERN_CATEGORIES.os,
  47:   // Other common defaults
  48:   "**/*.png", "**/*.jpg", "**/*.jpeg", "**/*.gif", "**/*.ico",
  49:   "**/*.webp", "**/*.svg", "**/*.pdf", "**/*.zip", "**/*.tar.gz",
  50:   "**/*.tgz", "**/*.rar", "**/*.7z", "**/*.mp4", "**/*.mov",
  51:   "**/*.avi", "**/*.mkv", "**/*.mp3", "**/*.wav", "**/*.flac",
  52:   "**/*.sqlite", "**/*.db", "**/*.sql",
  53:   "**/*.doc", "**/*.docx", "**/*.xls", "**/*.xlsx", "**/*.ppt", "**/*.pptx",
  54:   "**/*.iso", "**/*.bin", "**/*.exe", "**/*.dll", "**/*.so", "**/*.dylib",
  55:   "**/*.min.js", "**/*.min.css",
  56: ];
  57: // Mock type definition for ignore package
  58: interface IgnoreInstance {
  59:   ignores: (path: string) => boolean;
  60: }
  61: interface IgnoreFactory {
  62:   add: (patterns: string[] | string) => IgnoreInstance;
  63: }
  64: // This is just a simple interface to satisfy TypeScript without importing the actual package
  65: // The real implementation will be used at runtime
  66: function ignore(): IgnoreFactory {
  67:   return {
  68:     add: () => ({
  69:       ignores: () => false
  70:     })
  71:   };
  72: }
  73: const App = () => {
  74:   // Load initial state from localStorage if available
  75:   const savedFolder = localStorage.getItem(STORAGE_KEYS.SELECTED_FOLDER);
  76:   const savedFiles = localStorage.getItem(STORAGE_KEYS.SELECTED_FILES);
  77:   const savedExpandedNodes = localStorage.getItem(STORAGE_KEYS.EXPANDED_NODES);
  78:   const savedShowInstructions = localStorage.getItem('pastemax-show-instructions');
  79:   const savedModelId = localStorage.getItem(STORAGE_KEYS.SELECTED_MODEL_ID);
  80:   // State for user interface controls
  81:   const [showUserInstructions, setShowUserInstructions] = useState(
  82:     savedShowInstructions === null ? false : savedShowInstructions !== 'false'
  83:   );
  84:   const [fileTreeMode, setFileTreeMode] = useState<FileTreeMode>('complete');
  85:   // State for model information
  86:   const [availableModels, setAvailableModels] = useState<ModelInfo[] | null>(null);
  87:   const [selectedModelId, setSelectedModelId] = useState<string | null>(savedModelId);
  88:   const [selectedContextLength, setSelectedContextLength] = useState<number | null>(null);
  89:   const [isCompressionEnabled, setIsCompressionEnabled] = useState<boolean>(false);
  90:   // Initialize expanded nodes from localStorage if available
  91:   const initialExpandedNodes = useMemo(() => {
  92:     const map = new Map<string, boolean>();
  93:     if (savedExpandedNodes) {
  94:       try {
  95:         const parsedNodes = JSON.parse(savedExpandedNodes);
  96:         if (Array.isArray(parsedNodes)) {
  97:           parsedNodes.forEach(([key, value]) => {
  98:             if (typeof key === 'string' && typeof value === 'boolean') {
  99:               map.set(key, value);
 100:             }
 101:           });
 102:         }
 103:       } catch (error) {
 104:         console.error("Error parsing saved expanded nodes:", error);
 105:       }
 106:     }
 107:     return map;
 108:   }, [savedExpandedNodes]);
 109:   const [selectedFolder, setSelectedFolder] = useState<string | null>(savedFolder);
 110:   const [allFiles, setAllFiles] = useState<Omit<FileData, 'content'>[]>([]);
 111:   const [selectedFiles, setSelectedFiles] = useState<string[]>(
 112:     savedFiles ? JSON.parse(savedFiles) : []
 113:   );
 114:   const [sortOrder, setSortOrder] = useState<SortOrder>("name-ascending");
 115:   const [searchTerm, setSearchTerm] = useState("");
 116:   const [expandedNodes, setExpandedNodes] = useState<Map<string, boolean>>(initialExpandedNodes);
 117:   const [displayedFiles, setDisplayedFiles] = useState<Omit<FileData, 'content'>[]>([]);
 118:   const [processingStatus, setProcessingStatus] = useState({
 119:     status: "idle",
 120:     message: "",
 121:   } as {
 122:     status: "idle" | "processing" | "complete" | "error";
 123:     message: string;
 124:   });
 125:   const [userInstructions, setUserInstructions] = useState("");
 126:   const [fileTreeSortOrder, setFileTreeSortOrder] = useState<SortOrder>("name-ascending");
 127:   // Centralized state for ignore patterns
 128:   const [globalPatternsState, setGlobalPatternsState] = useState<IgnorePatternsState>({
 129:     patterns: '',
 130:     excludedSystemPatterns: []
 131:   });
 132:   const [localIgnorePatterns, setLocalPatterns] = useState<IgnorePatternsState>({ patterns: '', excludedSystemPatterns: [] }); // Local doesn't have excluded system patterns
 133:   const [systemIgnorePatterns, setSystemIgnorePatterns] = useState<string[]>(DEFAULT_SYSTEM_PATTERNS);
 134:   const [outputFormat, setOutputFormat] = useState<OutputFormatType>(() => {
 135:     const saved = localStorage.getItem(OUTPUT_FORMAT_STORAGE_KEY);
 136:     return (saved as OutputFormatType) || 'xml';
 137:   });
 138:   const isElectron = window.electron !== undefined;
 139:   // Add state for displayed token count after processing
 140:   const [displayedTokenCount, setDisplayedTokenCount] = useState<number>(0);
 141:   const [isCommentRemovalEnabled, setIsCommentRemovalEnabled] = useState<boolean>(false); // Add state for comment removal
 142:   // New state variables for enhanced compression controls
 143:   const [keepDocstrings, setKeepDocstrings] = useState<boolean>(true); // Default: true
 144:   const [removeEmptyLines, setRemoveEmptyLines] = useState<boolean>(false); // Default: false
 145:   const [neverCompressPatternsRaw, setNeverCompressPatternsRaw] = useState<string>(''); // Raw string input
 146:   const [neverCompressPatterns, setNeverCompressPatterns] = useState<string[]>([]); // Parsed array
 147:   const [minCompressTokenThreshold, setMinCompressTokenThreshold] = useState<number>(100); // Default: 100
 148:   // Parse raw patterns into array when the raw string changes
 149:   useEffect(() => {
 150:     const patterns = neverCompressPatternsRaw.split('\n').map(p => p.trim()).filter(p => p !== '');
 151:     setNeverCompressPatterns(patterns);
 152:   }, [neverCompressPatternsRaw]);
 153:   // Add state for model loading
 154:   const [_isLoadingModels, setIsLoadingModels] = useState<boolean>(false); // Prefix with underscore to indicate intentionally unused
 155:   const [initialModelLoadComplete, setInitialModelLoadComplete] = useState<boolean>(false);
 156:   // --- Fetch Models Effect ---
 157:   useEffect(() => {
 158:     // Skip if already completed initial load
 159:     if (initialModelLoadComplete) return;
 160:     const loadModels = async () => {
 161:       console.log("Attempting to fetch models...");
 162:       setIsLoadingModels(true);
 163:       try {
 164:         const fetchedModels = await fetchModels();
 165:         const modelsToUse = (fetchedModels as ModelInfo[] | null) || []; // Ensure we have an array
 166:         // Create fallback models if fetchedModels is empty
 167:         const fallbackModels = [
 168:           { id: "openai/gpt-4o", name: "GPT-4o (Fallback)", context_length: 128000 },
 169:           { id: "anthropic/claude-3-5-sonnet-20240620", name: "Claude 3.5 Sonnet (Fallback)", context_length: 200000 }
 170:         ];
 171:         // If no models fetched, use fallback models
 172:         const finalModels = modelsToUse.length > 0 ? modelsToUse : fallbackModels;
 173:         setAvailableModels(finalModels);
 174:         const savedModelId = localStorage.getItem(STORAGE_KEYS.SELECTED_MODEL_ID);
 175:         // Determine initial model
 176:         if (finalModels.length > 0) {
 177:           const validModelIds = finalModels.map(m => m.id);
 178:           let initialModelId: string | null = null;
 179:           if (savedModelId && validModelIds.includes(savedModelId)) {
 180:             initialModelId = savedModelId; // Keep saved ID if valid
 181:           } else {
 182:             initialModelId = finalModels[0].id; // Default to first model
 183:           }
 184:           // Set the selected model ID
 185:           setSelectedModelId(initialModelId);
 186:           console.log(`Initial model ID set to: ${initialModelId}`);
 187:           // Find the model and set context length
 188:           const initialModel = finalModels.find(m => m.id === initialModelId);
 189:           if (initialModel) {
 190:             setSelectedContextLength(initialModel.context_length);
 191:             console.log(`Initial context length set to: ${initialModel.context_length}`);
 192:           } else {
 193:             console.error("Could not find selected model to set context length.");
 194:             // Use a reasonable default
 195:             setSelectedContextLength(128000);
 196:           }
 197:         }
 198:       } catch (error) {
 199:         console.error("Error loading models:", error);
 200:       } finally {
 201:         setIsLoadingModels(false);
 202:         setInitialModelLoadComplete(true);
 203:       }
 204:     };
 205:     if (isElectron) {
 206:       loadModels();
 207:     } else {
 208:       // Handle non-electron case
 209:       const fallbackModels = [
 210:         { id: "openai/gpt-4o", name: "GPT-4o (Fallback)", context_length: 128000 },
 211:         { id: "anthropic/claude-3-5-sonnet-20240620", name: "Claude 3.5 Sonnet (Fallback)", context_length: 200000 }
 212:       ];
 213:       setAvailableModels(fallbackModels);
 214:       const savedModelId = localStorage.getItem(STORAGE_KEYS.SELECTED_MODEL_ID);
 215:       // Use saved model ID or default to first
 216:       const initialModelId = savedModelId && fallbackModels.some(m => m.id === savedModelId) 
 217:         ? savedModelId 
 218:         : fallbackModels[0].id;
 219:       setSelectedModelId(initialModelId);
 220:       // Set context length from the selected model
 221:       const initialModel = fallbackModels.find(m => m.id === initialModelId);
 222:       setSelectedContextLength(initialModel?.context_length || 128000);
 223:       console.log(`Initial model ID (non-electron): ${initialModelId}, Context: ${initialModel?.context_length ?? 'null'}`);
 224:       // Mark as complete for non-electron case too
 225:       setInitialModelLoadComplete(true);
 226:     }
 227:   // Only depend on isElectron since we want this to run just once at startup
 228:   }, [isElectron, initialModelLoadComplete]);
 229:   // Note on model persistence strategy:
 230:   // 1. Models are loaded at startup from API or fallbacks
 231:   // 2. Initial model selection reads from localStorage and is validated against available models
 232:   // 3. Persistence happens directly in the handleModelChange function, not via a separate effect
 233:   // This approach prevents feedback loops between state updates and localStorage
 234:   // Define applyFiltersAndSort early to avoid reference issues
 235:   // Ensure that displayedFiles will always exclude files that are marked as excluded, keeping both the file tree and file cards area in sync
 236:   const applyFiltersAndSort = useCallback((files: Omit<FileData, 'content'>[], sort: SortOrder, filter: string) => {
 237:     // First filter out excluded files
 238:     let filtered = files.filter(file => !file.excluded);
 239:   // Then apply search filter if present
 240:   if (filter) {
 241:     const lowerFilter = filter.toLowerCase();
 242:     filtered = filtered.filter(file =>
 243:       file.name.toLowerCase().includes(lowerFilter) ||
 244:       file.path.toLowerCase().includes(lowerFilter)
 245:     );
 246:   }
 247:     // Sort as before
 248:     const [sortKey, sortDir] = sort.split("-");
 249:     const sorted = [...filtered].sort((a, b) => {
 250:       let comparison = 0;
 251:       // Moved declarations outside switch
 252:       const aTokens = typeof a.tokenCount === 'number' ? a.tokenCount : 0;
 253:       const bTokens = typeof b.tokenCount === 'number' ? b.tokenCount : 0;
 254:       const aDate = a.lastModified || 0;
 255:       const bDate = b.lastModified || 0;
 256:       switch (sortKey) {
 257:         case "name":
 258:           comparison = a.name.localeCompare(b.name);
 259:           break;
 260:         case "tokens":
 261:           comparison = aTokens - bTokens;
 262:           break;
 263:         case "date":
 264:           comparison = Number(aDate) - Number(bDate);
 265:           break;
 266:         default:
 267:           comparison = a.name.localeCompare(b.name);
 268:       }
 269:       return sortDir === "ascending" ? comparison : -comparison;
 270:     });
 271:     setDisplayedFiles(sorted);
 272:   }, []);
 273:   // Re-run applyFiltersAndSort when relevant state changes
 274:   useEffect(() => {
 275:     applyFiltersAndSort(allFiles, sortOrder, searchTerm);
 276:   }, [allFiles, sortOrder, searchTerm, applyFiltersAndSort]); 
 277:   // --- Persist State Effects ---
 278:   useEffect(() => {
 279:     if (selectedFolder) localStorage.setItem(STORAGE_KEYS.SELECTED_FOLDER, selectedFolder);
 280:     else localStorage.removeItem(STORAGE_KEYS.SELECTED_FOLDER);
 281:   }, [selectedFolder]);
 282:   useEffect(() => {
 283:     localStorage.setItem(STORAGE_KEYS.SELECTED_FILES, JSON.stringify(selectedFiles));
 284:   }, [selectedFiles]);
 285:   useEffect(() => {
 286:     localStorage.setItem(STORAGE_KEYS.SORT_ORDER, sortOrder);
 287:   }, [sortOrder]);
 288:   useEffect(() => {
 289:     localStorage.setItem(STORAGE_KEYS.SEARCH_TERM, searchTerm);
 290:   }, [searchTerm]);
 291:   useEffect(() => {
 292:     try {
 293:       localStorage.setItem(STORAGE_KEYS.EXPANDED_NODES, JSON.stringify(Array.from(expandedNodes.entries())));
 294:     } catch (error) {
 295:       console.error("Error saving expanded nodes:", error);
 296:     }
 297:   }, [expandedNodes]);
 298:   useEffect(() => {
 299:     localStorage.setItem('pastemax-show-instructions', String(showUserInstructions));
 300:   }, [showUserInstructions]);
 301:   // Persist global ignore patterns state
 302:   useEffect(() => {
 303:     localStorage.setItem(STORAGE_KEYS.GLOBAL_IGNORE_PATTERNS, JSON.stringify(globalPatternsState));
 304:   }, [globalPatternsState]);
 305:   useEffect(() => {
 306:     localStorage.setItem(OUTPUT_FORMAT_STORAGE_KEY, outputFormat);
 307:   }, [outputFormat]);
 308:   // --- IPC Listeners ---
 309:   // Load initial data from saved folder
 310:   useEffect(() => {
 311:     if (!isElectron || !selectedFolder) return;
 312:     console.log("Loading saved folder on startup:", selectedFolder);
 313:     setProcessingStatus({ status: "processing", message: "Loading files..." });
 314:     // Add debug logging to trace the request
 315:     console.log("Requesting file list with send method");
 316:     // Either use the dedicated method or the generic send
 317:     if (window.electron.requestFileList) {
 318:       window.electron.requestFileList({ path: selectedFolder });
 319:     } else {
 320:       window.electron.send("request-file-list", selectedFolder);
 321:     }
 322:   }, [isElectron, selectedFolder]); // Keep dependency
 323:   // Listen for folder selection and file list data
 324:   useEffect(() => {
 325:     if (!isElectron) return;
 326:     const handleFolderSelected = (folderPath: string) => {
 327:       if (typeof folderPath === "string") {
 328:         console.log("Folder selected:", folderPath);
 329:         setSelectedFolder(folderPath);
 330:         // Reset selection and patterns when folder changes
 331:         setSelectedFiles([]);
 332:         setLocalPatterns({ patterns: '', excludedSystemPatterns: [] });
 333:         setProcessingStatus({ status: "processing", message: "Loading files..." });
 334:         // Use specific method if available, or generic send
 335:         window.electron.send("request-file-list", folderPath);
 336:       }
 337:     };
 338:     const handleFileListData = (filesMetadata: Omit<FileData, 'content'>[]) => {
 339:       console.log(`Received metadata for ${filesMetadata.length} files`);
 340:       // Add detailed logging for diagnostics
 341:       if (filesMetadata.length > 0) {
 342:         console.log("Sample files received:");
 343:         filesMetadata.slice(0, Math.min(5, filesMetadata.length)).forEach(file => {
 344:           console.log(`- ${file.name} (${file.path}) ${file.excluded ? '[EXCLUDED]' : ''}`);
 345:         });
 346:         // Count excluded files
 347:         const excludedCount = filesMetadata.filter(f => f.excluded).length;
 348:         if (excludedCount > 0) {
 349:           console.log(`Warning: ${excludedCount} files are excluded by patterns!`);
 350:         }
 351:       } else {
 352:         console.warn("No files received from main process!");
 353:       }
 354:       setAllFiles(filesMetadata);
 355:       applyFiltersAndSort(filesMetadata, sortOrder, searchTerm);  
 356:     };
 357:     const handleProcessingStatus = (status: { status: "idle" | "processing" | "complete" | "error"; message: string; }) => {
 358:       setProcessingStatus(status);
 359:     };
 360:     const handleIgnorePatternsLoaded = (result: { patterns: string; isGlobal: boolean; systemPatterns?: string[]; folderPath?: string }) => {
 361:       console.log(`Ignore patterns loaded (global: ${result.isGlobal})`);
 362:       if (result.systemPatterns) {
 363:         setSystemIgnorePatterns(result.systemPatterns);
 364:       }
 365:       const parsedPatterns = parseIgnorePatternsContent(result.patterns);
 366:       if (result.isGlobal) {
 367:         setGlobalPatternsState({
 368:           patterns: parsedPatterns.userPatterns,
 369:           excludedSystemPatterns: parsedPatterns.excludedPatterns
 370:         });
 371:       } else if (result.folderPath && selectedFolder && arePathsEqual(result.folderPath, selectedFolder)) {
 372:         setLocalPatterns({
 373:           patterns: parsedPatterns.userPatterns,
 374:           excludedSystemPatterns: parsedPatterns.excludedPatterns
 375:         });
 376:       }
 377:     };
 378:     // Setup IPC listeners using the exposed 'receive' method
 379:     window.electron.receive("folder-selected", handleFolderSelected);
 380:     window.electron.receive("file-list-data", handleFileListData);
 381:     window.electron.receive("file-processing-status", handleProcessingStatus);
 382:     window.electron.receive("ignore-patterns-loaded", handleIgnorePatternsLoaded);
 383:     // Cleanup function should use removeListener if it exists on the exposed API
 384:     // Assuming removeListener was exposed for symmetry with 'on'/'receive'
 385:     // If not, this cleanup might need adjustment based on preload.js structure
 386:     return () => {
 387:       // Check if ipcRenderer and removeListener method exist before calling
 388:       if (window.electron.ipcRenderer?.removeListener) {
 389:         window.electron.ipcRenderer.removeListener("folder-selected", handleFolderSelected);
 390:         window.electron.ipcRenderer.removeListener("file-list-data", handleFileListData);
 391:         window.electron.ipcRenderer.removeListener("file-processing-status", handleProcessingStatus);
 392:         window.electron.ipcRenderer.removeListener("ignore-patterns-loaded", handleIgnorePatternsLoaded);
 393:       } else {
 394:         console.warn("Cleanup: ipcRenderer.removeListener not found on window.electron");
 395:         // Alternative cleanup if needed, e.g., calling ipcRenderer.removeAllListeners(channel)
 396:       }
 397:     };
 398:   }, [isElectron, applyFiltersAndSort, sortOrder, searchTerm, selectedFolder]); // Dependencies
 399:   // Add ESC key handler
 400:   const handleEscKey = useCallback((e: KeyboardEvent) => {
 401:       if (e.key === 'Escape' && processingStatus.status === 'processing') {
 402:         console.log("Escape key pressed, cancelling directory loading...");
 403:         // Use specific method if available, or generic send
 404:         window.electron.send("cancel-directory-loading");
 405:       }
 406:     }, [processingStatus.status]);
 407:   useEffect(() => {
 408:       document.addEventListener('keydown', handleEscKey);
 409:       return () => {
 410:         document.removeEventListener('keydown', handleEscKey);
 411:       };
 412:     }, [handleEscKey]);
 413:   // Add file change detection handler
 414:   useEffect(() => {
 415:     if (!isElectron || !selectedFolder) return;
 416:     console.log("Setting up file change listener");
 417:     const handleFileChanged = (data: { type: 'add' | 'change' | 'delete', path: string }) => {
 418:       // Immediately normalize the path to match allFiles format
 419:       const { type, path } = data;
 420:       const normalizedPath = normalizePath(path);
 421:       console.log(`File ${type} event detected: ${normalizedPath}`);
 422:       if (type === 'add') {
 423:         // Fetch metadata for the new file and add it to allFiles
 424:         window.electron.getFileMetadata(normalizedPath).then((result: any) => {
 425:           if (result.success && result.fileData) {
 426:             console.log("Adding new file to allFiles:", result.fileData.path);
 427:             // Use functional update to get the latest state
 428:             setAllFiles(prev => {
 429:               const updatedFiles = [...prev, result.fileData];
 430:               // Call applyFiltersAndSort with the new array to update displayedFiles
 431:               applyFiltersAndSort(updatedFiles, sortOrder, searchTerm);
 432:               return updatedFiles;
 433:             });
 434:           }
 435:         });
 436:       } 
 437:       else if (type === 'change') {
 438:         // Update existing file's metadata
 439:         window.electron.getFileMetadata(normalizedPath).then((result: any) => {
 440:           if (result.success && result.fileData) {
 441:             console.log("Updating file in allFiles:", result.fileData.path);
 442:             setAllFiles(prev => {
 443:               const updatedFiles = prev.map(file => 
 444:                 arePathsEqual(file.path, normalizedPath) ? result.fileData : file
 445:               );
 446:               applyFiltersAndSort(updatedFiles, sortOrder, searchTerm);
 447:               return updatedFiles;
 448:             });
 449:           }
 450:         });
 451:       } 
 452:       else if (type === 'delete') {
 453:         // Remove file from allFiles and selectedFiles
 454:         console.log("Removing file from allFiles:", normalizedPath);
 455:         // Use functional update for all state setters relying on previous state
 456:         setAllFiles(prevAllFiles => {
 457:           const updatedAllFiles = prevAllFiles.filter(file => !arePathsEqual(file.path, normalizedPath));
 458:           // Call applyFiltersAndSort with the updated array
 459:           applyFiltersAndSort(updatedAllFiles, sortOrder, searchTerm);
 460:           return updatedAllFiles;
 461:         });
 462:         setSelectedFiles(prevSelectedFiles => 
 463:           prevSelectedFiles.filter(filePath => !arePathsEqual(filePath, normalizedPath))
 464:         );
 465:       }
 466:     };
 467:     // Use the receive method to listen for file-changed events
 468:     window.electron.receive("file-changed", handleFileChanged);
 469:     // Cleanup listener when component unmounts
 470:     return () => {
 471:       // Check if ipcRenderer and removeListener method exist before calling
 472:       if (window.electron.ipcRenderer?.removeListener) {
 473:         window.electron.ipcRenderer.removeListener("file-changed", handleFileChanged);
 474:       }
 475:     };
 476:   // Reduce dependencies to prevent unnecessary re-subscriptions
 477:   }, [isElectron, selectedFolder, applyFiltersAndSort, sortOrder, searchTerm]);
 478:   // --- Core Functions ---
 479:   const openFolder = async () => { // Make async
 480:     if (isElectron) {
 481:       console.log("Requesting to open folder dialog via IPC invoke...");
 482:       try {
 483:         // Use the specific invoke method
 484:         const folderPath = await window.electron.openFolder();
 485:         if (folderPath) {
 486:           console.log("Folder selected via dialog:", folderPath);
 487:           // Clear all relevant state
 488:           setAllFiles([]);
 489:           setDisplayedFiles([]);
 490:           setSelectedFiles([]);
 491:           setExpandedNodes(new Map());
 492:           setLocalPatterns({ patterns: '', excludedSystemPatterns: [] });
 493:           // Set processing status first
 494:           setProcessingStatus({ status: "processing", message: "Loading files..." });
 495:           // Then set the selected folder
 496:           setSelectedFolder(folderPath);
 497:           // Request file list for the newly selected folder
 498:           console.log("Requesting file list for:", folderPath);
 499:           if (window.electron.requestFileList) {
 500:             window.electron.requestFileList({ path: folderPath });
 501:           } else {
 502:             window.electron.send("request-file-list", folderPath);
 503:           }
 504:         } else {
 505:           console.log("Folder selection cancelled.");
 506:         }
 507:       } catch (error) {
 508:         console.error("Error opening folder dialog via IPC:", error);
 509:          setProcessingStatus({ status: "error", message: `Error opening folder: ${error instanceof Error ? error.message : error}` });
 510:       }
 511:     }
 512:   };
 513:   // Toggle file selection
 514:   const toggleFileSelection = useCallback((filePath: string) => {
 515:     const normalizedPath = normalizePath(filePath);
 516:     setSelectedFiles(prevSelected => {
 517:       const isSelected = prevSelected.some(path => arePathsEqual(path, normalizedPath));
 518:       return isSelected
 519:         ? prevSelected.filter(path => !arePathsEqual(path, normalizedPath))
 520:         : [...prevSelected, normalizedPath];
 521:     });
 522:   }, []); // Add empty dependency array
 523:   // Select all non-excluded files
 524:   const selectAllFiles = useCallback(() => {
 525:     const filesToSelect = allFiles
 526:       .filter(file => !file.isBinary && !file.isSkipped && !file.excluded)
 527:       .map(file => file.path);
 528:     setSelectedFiles(filesToSelect); // Directly set, no need to merge if it's 'select all'
 529:   }, [allFiles]);
 530:   // Deselect all files
 531:   const deselectAllFiles = useCallback(() => {
 532:     setSelectedFiles([]);
 533:   }, []);
 534:   // Toggle folder selection
 535:   const toggleFolderSelection = useCallback((folderPath: string, shouldBeSelected: boolean) => {
 536:     if (!folderPath) return;
 537:     const normalizedFolderPath = normalizePath(folderPath);
 538:     setSelectedFiles(prev => {
 539:       const newSelectionSet = new Set(prev);
 540:       allFiles.forEach(file => {
 541:         const normalizedFilePath = normalizePath(file.path);
 542:         // Check if file is within the target folder (or is the folder itself if files represent folders)
 543:         if (normalizedFilePath.startsWith(normalizedFolderPath + '/') || normalizedFilePath === normalizedFolderPath) {
 544:            // Only modify selection for non-binary, non-skipped, non-excluded files
 545:            if (!file.isBinary && !file.isSkipped && !file.excluded) {
 546:                 if (shouldBeSelected) {
 547:                     newSelectionSet.add(file.path);
 548:                 } else {
 549:                     newSelectionSet.delete(file.path);
 550:                 }
 551:            }
 552:         }
 553:       });
 554:       return Array.from(newSelectionSet);
 555:     });
 556:   }, [allFiles]); // Depends on allFiles
 557:   // Handle sort change
 558:   const handleSortChange = useCallback((value: string | string[]) => {
 559:     if (typeof value === 'string') {
 560:       setSortOrder(value as SortOrder);
 561:       // applyFiltersAndSort will be triggered by the useEffect watching sortOrder
 562:     }
 563:   }, []); // Add empty dependency array
 564:   // Handle search change
 565:   const handleSearchChange = useCallback((newSearch: string) => {
 566:     setSearchTerm(newSearch);
 567:      // applyFiltersAndSort will be triggered by the useEffect watching searchTerm
 568:   }, []); // Add empty dependency array
 569:   // Calculate total tokens (Memoized)
 570:   const _totalTokens = useMemo(() => { // Prefix with underscore to indicate intentionally unused
 571:     const fileMap = new Map(allFiles.map(f => [f.path, f.tokenCount]));
 572:     return selectedFiles.reduce((total, path) => {
 573:       return total + (fileMap.get(path) || 0);
 574:     }, 0);
 575:   }, [selectedFiles, allFiles]);
 576:   // Calculate total token count for selected files
 577:   const _totalTokenCount = useMemo(() => { // Prefix with underscore to indicate intentionally unused
 578:     // If no folder is selected, or file list/selection is empty, count is 0
 579:     if (!selectedFolder || !allFiles || allFiles.length === 0 || selectedFiles.length === 0) {
 580:       return 0;
 581:     }
 582:     // Create a set of normalized selected file paths for efficient lookup
 583:     const selectedFileSet = new Set(selectedFiles.map(normalizePath));
 584:     // Sum token counts of files whose normalized path is in the selected set
 585:     return allFiles.reduce((sum, file) => {
 586:       if (selectedFileSet.has(normalizePath(file.path))) {
 587:         // Use tokenCount if it's a valid number, otherwise default to 0
 588:         return sum + (typeof file.tokenCount === 'number' ? file.tokenCount : 0);
 589:       }
 590:       return sum;
 591:     }, 0);
 592:   }, [selectedFiles, allFiles, selectedFolder]); // Recalculate when selection, file list, or folder changes
 593:   // Calculate UNCOMPRESSED total token count for selected files (for initial display before processing)
 594:   const uncompressedTotalTokenCount = useMemo(() => {
 595:     if (!selectedFolder || !allFiles || allFiles.length === 0 || selectedFiles.length === 0) return 0;
 596:     const selectedFileSet = new Set(selectedFiles.map(normalizePath));
 597:     return allFiles.reduce((sum, file) => {
 598:       if (selectedFileSet.has(normalizePath(file.path))) {
 599:         // Use uncompressedTokenCount for this initial calculation
 600:         return sum + (typeof file.uncompressedTokenCount === 'number' ? file.uncompressedTokenCount : 0);
 601:       }
 602:       return sum;
 603:     }, 0);
 604:   }, [selectedFiles, allFiles, selectedFolder]);
 605:   // Update displayed count whenever uncompressed count changes (or after compression)
 606:   useEffect(() => {
 607:     setDisplayedTokenCount(uncompressedTotalTokenCount);
 608:     // This will be updated again within getSelectedFilesContent if compression runs
 609:   }, [uncompressedTotalTokenCount]);
 610:   // --- Moved reloadFolder definition earlier ---
 611:   const reloadFolder = useCallback(() => {
 612:     if (isElectron && selectedFolder) {
 613:       console.log(`Reloading folder: ${selectedFolder}`);
 614:       setAllFiles([]); // Clear current files
 615:       setDisplayedFiles([]);
 616:       // Optionally reset local patterns state if desired on manual reload
 617:       // setLocalPatterns({ patterns: '', excludedSystemPatterns: [] });
 618:       // Use specific method if available, or generic send
 619:       if (window.electron.requestFileList) {
 620:         window.electron.requestFileList({ path: selectedFolder, forceRefresh: true });
 621:       } else {
 622:         window.electron.send("reload-file-list", selectedFolder);
 623:       }
 624:     }
 625:   }, [isElectron, selectedFolder]); // Now defined before other callbacks
 626:   // Helper to get language identifier for compression function
 627:   const _getLanguageFromPath = (filePath: string): string | null => { // Prefix with underscore to indicate intentionally unused
 628:     // Extract extension in a browser-safe way
 629:     const lastDotIndex = filePath.lastIndexOf('.');
 630:     const extension = lastDotIndex !== -1 ? filePath.slice(lastDotIndex + 1).toLowerCase() : '';
 631:     switch (extension) {
 632:       case 'js':
 633:       case 'jsx':
 634:         return 'javascript';
 635:       case 'ts':
 636:       case 'tsx':
 637:         return 'typescript';
 638:       case 'py':
 639:         return 'python';
 640:       case 'css':
 641:         return 'css';
 642:       case 'html':
 643:       case 'htm':
 644:         return 'html';
 645:       // Add other mappings as needed
 646:       default:
 647:         return null; // Unsupported extension for compression
 648:     }
 649:   };
 650:   // Function to dynamically compress files if needed
 651:   const applyDynamicCompression = useCallback(async (
 652:     filesToProcess: FileData[],
 653:     targetTokenLimit: number,
 654:     // Add flag for comment removal
 655:     removeCommentsFlag: boolean,
 656:     // Add flag for preserving docstrings
 657:     keepDocstringsFlag: boolean = true,
 658:     // Add new parameters
 659:     neverCompressPatterns: string[] = [],
 660:     minCompressTokenThreshold: number = 100,
 661:     // Add flag for removing empty lines
 662:     removeEmptyLinesFlag: boolean = false
 663:   ): Promise<{ processedFiles: FileData[], finalTokenCount: number }> => {
 664:     if (!isElectron) {
 665:       console.warn("Compression skipped: Not running in Electron environment.");
 666:        const initialTokenCount = filesToProcess.reduce((sum, file) => sum + (file.uncompressedTokenCount || 0), 0);
 667:       return { processedFiles: filesToProcess, finalTokenCount: initialTokenCount };
 668:     }
 669:     setProcessingStatus({ status: 'processing', message: 'Analyzing files...' });
 670:     const mutableFiles: FileData[] = filesToProcess.map(f => ({
 671:         ...f,
 672:         uncompressedTokenCount: f.uncompressedTokenCount ?? f.tokenCount ?? 0,
 673:         isCompressed: false, // Reset to false - we'll determine this during processing
 674:         tokenCount: f.uncompressedTokenCount ?? f.tokenCount ?? 0, // Start with original token count
 675:         content: undefined // Start with undefined content, fetch as needed
 676:     }));
 677:     // Calculate initial total token count for comparison
 678:     let currentTotalTokens = mutableFiles.reduce(
 679:       (sum, file) => sum + (file.tokenCount || 0), 
 680:       0
 681:     );
 682:     console.log(`Initial token count: ${currentTotalTokens}, Target: ${targetTokenLimit}`);
 683:     // --- Step 1: Remove Comments (if enabled) --- PRE-COMPRESSION TOKEN COUNT
 684:     if (removeCommentsFlag) {
 685:       console.log("Attempting comment removal...");
 686:       setProcessingStatus({ status: 'processing', message: 'Removing comments...' });
 687:       let _commentsRemovedCount = 0; // Prefix with underscore to indicate intentionally unused
 688:       // Use Promise.all for potentially faster parallel processing
 689:       await Promise.all(mutableFiles.map(async (file) => {
 690:         const language = getLanguageFromFilename(file.name);
 691:         if (!language) return; // Skip unsupported
 692:         try {
 693:            let currentContent = file.content;
 694:            // Fetch content if needed
 695:            if (currentContent === undefined) {
 696:              console.log(`Fetching content for comment removal: ${file.path}`);
 697:              const result = await window.electron.getFileContent(file.path);
 698:              if (!result || !result.success) {
 699:                const error = result?.error || 'Unknown error';
 700:                console.error(`Failed to get content for ${file.path}: ${error}`);
 701:                file.content = `// Error fetching content: ${error}`;
 702:                return;
 703:              }
 704:              currentContent = result.content;
 705:            }
 706:            if (typeof currentContent !== 'string') {
 707:              console.warn(`Content for ${file.path} is not a string, skipping comment removal.`);
 708:              return;
 709:            }
 710:            const contentWithoutComments = await removeComments(currentContent, language, keepDocstringsFlag);
 711:            if (contentWithoutComments !== null && contentWithoutComments !== currentContent) {
 712:              _commentsRemovedCount++;
 713:              // Recalculate token count *after* comment removal
 714:              const newTokenCount = await window.electron.countTokens(contentWithoutComments);
 715:              // *** IMPORTANT: Store content and updated token count NOW ***
 716:              file.content = contentWithoutComments; 
 717:              file.tokenCount = typeof newTokenCount === 'number' ? newTokenCount : (file.uncompressedTokenCount ?? 0);
 718:              console.log(`Comments removed from ${file.name}. New token count: ${file.tokenCount}`);
 719:            } else {
 720:               // If no comments removed, ensure token count is original uncompressed
 721:               file.tokenCount = file.uncompressedTokenCount ?? 0;
 722:               // If we've already loaded the content, preserve it
 723:               if (currentContent !== undefined) {
 724:                 file.content = currentContent;
 725:               }
 726:            }
 727:         } catch (error) {
 728:            console.error(`Error during comment removal for ${file.path}:`, error);
 729:            // Check if error is an instance of Error before accessing message
 730:            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
 731:            file.content = `// Error removing comments: ${errorMessage}`;
 732:         }
 733:       }));
 734:       // Recalculate total token count after comment removal
 735:       currentTotalTokens = mutableFiles.reduce((sum, file) => sum + (file.tokenCount || 0), 0);
 736:       console.log(`Token count after comment removal: ${currentTotalTokens}`);
 737:     }
 738:     // Check if we need compression - only compress if we exceed the target token limit
 739:     // This is the adaptive part - we'll only compress if needed
 740:     const needsBodyCompression = currentTotalTokens > targetTokenLimit;
 741:     if (!needsBodyCompression) {
 742:       console.log("Token count is within limit, no body compression needed.");
 743:       setProcessingStatus({ status: 'idle', message: '' });
 744:       // Need to ensure content is fetched if not already present (e.g., comment removal ran but no body compression needed)
 745:       await Promise.all(mutableFiles.map(async (file) => {
 746:           if (file.content === undefined) {
 747:               try {
 748:                   console.log(`Fetching content (final pass): ${file.path}`);
 749:                   const result = await window.electron.getFileContent(file.path);
 750:                   if (!result || !result.success) {
 751:                     const error = result?.error || 'Unknown error';
 752:                     console.error(`Failed to get content for ${file.path}: ${error}`);
 753:                     file.content = `// Error fetching content: ${error}`;
 754:                   } else {
 755:                     file.content = result.content;
 756:                     // Use uncompressed count here as body compression didn't run
 757:                     file.tokenCount = file.uncompressedTokenCount ?? 0;
 758:                   }
 759:               } catch (e) { 
 760:                   console.error(`Error fetching content for ${file.path}:`, e);
 761:                   // Check if e is an instance of Error before accessing message
 762:                   const errorMessage = e instanceof Error ? e.message : 'Unknown error';
 763:                   file.content = `// Error fetching content: ${errorMessage}`; 
 764:                   file.tokenCount = 0; 
 765:               }
 766:           }
 767:       }));
 768:       return { processedFiles: mutableFiles, finalTokenCount: currentTotalTokens };
 769:     }
 770:     // --- Body Compression Loop --- 
 771:     // Only execute this if we actually need compression (token count exceeds limit)
 772:     console.log("Token count exceeds limit, starting body compression...");
 773:     setProcessingStatus({ status: 'processing', message: 'Compressing function bodies...' });
 774:     // Helper function to check if a file path matches any of the patterns
 775:     const matchesAnyPattern = (path: string, patterns: string[]): boolean => {
 776:       if (patterns.length === 0) return false;
 777:       // Normalize the path to use forward slashes for consistent matching
 778:       const normalizedPath = path.replace(/\\/g, '/');
 779:       // Get the filename for simpler patterns like *.py
 780:       const fileName = normalizedPath.split('/').pop() || '';
 781:       return patterns.some(pattern => {
 782:         // Skip empty patterns
 783:         if (!pattern.trim()) return false;
 784:         // Normalize the pattern too
 785:         const normalizedPattern = pattern.trim().replace(/\\/g, '/');
 786:         // Simple glob matching for common patterns
 787:         // Convert glob pattern to regex
 788:         const regexPattern = normalizedPattern
 789:           .replace(/\./g, '\\.')   // Escape dots
 790:           .replace(/\*\*/g, '.*')  // ** becomes .* (match anything, including slashes)
 791:           .replace(/\*/g, '[^/]*') // * becomes [^/]* (match anything except slashes)
 792:           .replace(/\?/g, '[^/]')  // ? becomes [^/] (match single character, not slash)
 793:           .replace(/\[!\]/g, '[^]'); // [!] becomes [^]
 794:         // For simple filename patterns (no slash), match against the filename only
 795:         if (!normalizedPattern.includes('/') && !normalizedPattern.includes('\\')) {
 796:           return new RegExp(`^${regexPattern}$`).test(fileName);
 797:         }
 798:         // For full path patterns, match against the full path
 799:         return new RegExp(`^${regexPattern}$`).test(normalizedPath);
 800:       });
 801:     };
 802:     // Filter files based on compression rules
 803:     const filesToCompress = [...mutableFiles]
 804:       .filter(file => {
 805:         // Skip already compressed files
 806:         if (file.isCompressed) return false;
 807:         // Skip files with too few tokens
 808:         if ((file.tokenCount || 0) < minCompressTokenThreshold) {
 809:           console.log(`Skipping ${file.name}: below token threshold (${file.tokenCount} < ${minCompressTokenThreshold})`);
 810:           return false;
 811:         }
 812:         // Skip files matching any of the never compress patterns
 813:         if (matchesAnyPattern(file.path, neverCompressPatterns)) {
 814:           console.log(`Skipping ${file.name}: matches never compress pattern`);
 815:           return false;
 816:         }
 817:         return true;
 818:       })
 819:       .sort((a, b) => (b.tokenCount || 0) - (a.tokenCount || 0));
 820:     let filesCompressedCount = 0;
 821:     for (const fileToCompress of filesToCompress) {
 822:       if (currentTotalTokens <= targetTokenLimit) {
 823:         console.log("Target token limit reached, stopping compression.");
 824:         break;
 825:       }
 826:       setProcessingStatus({ 
 827:         status: 'processing', 
 828:         message: `Compressing: ${fileToCompress.name} (${filesCompressedCount + 1}/${filesToCompress.length})` 
 829:       });
 830:       const language = getLanguageFromFilename(fileToCompress.name);
 831:       if (!language) {
 832:         console.log(`Skipping body compression for unsupported file type: ${fileToCompress.name}`);
 833:         fileToCompress.isCompressed = true; // Mark as processed even if unsupported
 834:         continue;
 835:       }
 836:       try {
 837:         let contentToCompress = fileToCompress.content;
 838:         // Fetch content ONLY if it wasn't fetched during comment removal
 839:         if (contentToCompress === undefined) {
 840:           console.log(`Fetching content for body compression: ${fileToCompress.path}`);
 841:           const result = await window.electron.getFileContent(fileToCompress.path);
 842:           if (!result || !result.success) {
 843:             const error = result?.error || 'Unknown error';
 844:             console.error(`Failed to get content for ${fileToCompress.path}: ${error}`);
 845:             fileToCompress.content = `// Error fetching content: ${error}`;
 846:             fileToCompress.isCompressed = true; // Mark as processed
 847:             continue;
 848:           }
 849:           contentToCompress = result.content;
 850:         }
 851:         if (typeof contentToCompress !== 'string') {
 852:           console.warn(`Could not get valid content for ${fileToCompress.path}, skipping body compression.`);
 853:           fileToCompress.isCompressed = true; // Mark as processed
 854:           continue;
 855:         }
 856:         const compressedSource = await compressCode(contentToCompress, language);
 857:         if (compressedSource !== null && compressedSource !== contentToCompress) {
 858:           console.log(`Recalculating tokens for body-compressed ${fileToCompress.name}`);
 859:           const newCompressedTokenCount = await window.electron.countTokens(compressedSource);
 860:           if (typeof newCompressedTokenCount === 'number') {
 861:             const reduction = (fileToCompress.tokenCount || 0) - newCompressedTokenCount;
 862:             console.log(`Body-compressed ${fileToCompress.name}. Token reduction: ${reduction}`);
 863:             fileToCompress.content = compressedSource;
 864:             fileToCompress.tokenCount = newCompressedTokenCount;
 865:             fileToCompress.isCompressed = true;
 866:             filesCompressedCount++;
 867:             // Recalculate total immediately to check if we've reached target
 868:             currentTotalTokens = mutableFiles.reduce((sum, file) => sum + (file.tokenCount || 0), 0);
 869:             // Update displayed token count in real-time
 870:             setDisplayedTokenCount(currentTotalTokens);
 871:           } else {
 872:             console.warn(`Failed to recalculate tokens for body-compressed ${fileToCompress.name}`);
 873:           }
 874:         } else {
 875:           console.log(`Body compression skipped or ineffective for ${fileToCompress.name}`);
 876:         }
 877:         fileToCompress.isCompressed = true; // Mark as processed even if ineffective
 878:       } catch (error) {
 879:         console.error(`Error during body compression for ${fileToCompress.path}:`, error);
 880:         // Check if error is an instance of Error before accessing message
 881:         const errorMessage = error instanceof Error ? error.message : 'Unknown error';
 882:         fileToCompress.content = `// Error compressing code: ${errorMessage}`;
 883:         fileToCompress.isCompressed = true; // Mark as processed
 884:       }
 885:     }
 886:     console.log(`Compression complete. Final token count: ${currentTotalTokens}`);
 887:     console.log(`Compressed ${filesCompressedCount} files.`);
 888:     setProcessingStatus({ 
 889:       status: 'complete', 
 890:       message: `Compression finished. ${filesCompressedCount} files compressed.` 
 891:     });
 892:     setTimeout(() => setProcessingStatus({ status: 'idle', message: '' }), 2000);
 893:     // --- Final Step: Remove Empty Lines if enabled ---
 894:     if (removeEmptyLinesFlag) {
 895:       console.log("Removing empty lines from files...");
 896:       let emptyLinesRemovedCount = 0;
 897:       // Process each file to remove empty lines
 898:       for (const file of mutableFiles) {
 899:         if (file.content !== undefined && typeof file.content === 'string') {
 900:           // Regex to match empty lines or lines with only whitespace
 901:           const originalContent = file.content;
 902:           file.content = file.content.replace(/^\s*$(?:\r\n?|\n)/gm, '');
 903:           if (file.content !== originalContent) {
 904:             emptyLinesRemovedCount++;
 905:             console.log(`Removed empty lines from ${file.name}`);
 906:           }
 907:         }
 908:       }
 909:       console.log(`Empty lines removed from ${emptyLinesRemovedCount} files.`);
 910:     }
 911:     // Final update of the token count
 912:     currentTotalTokens = mutableFiles.reduce((sum, file) => sum + (file.tokenCount || 0), 0);
 913:     return { processedFiles: mutableFiles, finalTokenCount: currentTotalTokens };
 914:   }, [
 915:     isElectron,
 916:     setProcessingStatus,
 917:     setDisplayedTokenCount,
 918:   ]);
 919:   // Get selected files content and apply formatting/compression
 920:   const getSelectedFilesContent = useCallback(async (): Promise<string> => {
 921:     if (selectedFiles.length === 0) {
 922:        setDisplayedTokenCount(0); // Reset displayed count
 923:       return "No files selected.";
 924:     }
 925:     setProcessingStatus({ status: 'processing', message: `Preparing ${selectedFiles.length} files...` });
 926:     try {
 927:       const selectedFileSet = new Set(selectedFiles.map(normalizePath));
 928:       const filesToProcess: FileData[] = allFiles.filter(file =>
 929:         selectedFileSet.has(normalizePath(file.path)) && !file.isBinary && !file.isSkipped
 930:       ).map(f => ({ // Ensure we map to the full FileData structure if allFiles is Omit<..., 'content'>
 931:           ...f,
 932:           content: undefined, // Start with undefined content
 933:           isCompressed: false, // Reset compression state
 934:           tokenCount: f.tokenCount ?? 0,
 935:           uncompressedTokenCount: f.uncompressedTokenCount ?? f.tokenCount ?? 0
 936:       }));
 937:       let finalTokenCount = filesToProcess.reduce((sum, file) => sum + (file.tokenCount || 0), 0);
 938:       let processedFilesForOutput: FileData[] = filesToProcess; // Start with the initial selection, now typed as FileData[]
 939:       // --- Apply Comment Removal & Compression if Enabled --- //
 940:       if (isCompressionEnabled || isCommentRemovalEnabled) {
 941:          const targetLimit = selectedContextLength ? Math.floor(selectedContextLength * 0.95) : Infinity;
 942:          // Pass all parameters to the processing function
 943:          const processingResult = await applyDynamicCompression(
 944:             filesToProcess,
 945:             targetLimit,
 946:             isCommentRemovalEnabled, // Pass comment removal flag
 947:             keepDocstrings, // Pass keepDocstrings flag
 948:             neverCompressPatterns, // Pass the never compress patterns (array)
 949:             minCompressTokenThreshold, // Pass the min tokens threshold
 950:             removeEmptyLines // Pass the removeEmptyLines flag
 951:           );
 952:          processedFilesForOutput = processingResult.processedFiles;
 953:          finalTokenCount = processingResult.finalTokenCount;
 954:          // Update the displayed token count immediately
 955:          setDisplayedTokenCount(finalTokenCount);
 956:       } else {
 957:          // If processing is disabled, calculate and display the uncompressed total
 958:          finalTokenCount = filesToProcess.reduce((sum, file) => sum + (file.uncompressedTokenCount || 0), 0);
 959:          setDisplayedTokenCount(finalTokenCount);
 960:          // Fetch content if processing was skipped
 961:          await Promise.all(processedFilesForOutput.map(async (file) => {
 962:              if (file.content === undefined) {
 963:                  try {
 964:                      console.log(`Fetching content (no compression): ${file.path}`);
 965:                      const result = await window.electron.getFileContent(file.path);
 966:                      if (!result || !result.success) {
 967:                          const error = result?.error || 'Unknown error';
 968:                          console.error(`Failed to get content for ${file.path}: ${error}`);
 969:                          file.content = `// Error fetching content: ${error}`;
 970:                      } else {
 971:                          file.content = result.content;
 972:                      }
 973:                  } catch (e) { 
 974:                      console.error(`Error fetching content for ${file.path}:`, e);
 975:                      // Check if e is an instance of Error before accessing message
 976:                      const errorMessage = e instanceof Error ? e.message : 'Unknown error';
 977:                      file.content = `// Error fetching content: ${errorMessage}`; 
 978:                  }
 979:              }
 980:          }));
 981:       }
 982:       // --- Sort the richer FileData array BEFORE extracting content --- //
 983:       const sortedProcessedFiles = [...processedFilesForOutput].sort((a, b) => {
 984:           const [sortKey, sortDir] = sortOrder.split("-");
 985:           let comparison = 0;
 986:           // Use properties directly from FileData
 987:           const aTokens = a.tokenCount ?? 0;
 988:           const bTokens = b.tokenCount ?? 0;
 989:           const aDate = a.lastModified ?? 0;
 990:           const bDate = b.lastModified ?? 0;
 991:           switch (sortKey) {
 992:             case "name": comparison = a.name.localeCompare(b.name); break;
 993:             case "tokens": comparison = aTokens - bTokens; break;
 994:             case "date": comparison = Number(aDate) - Number(bDate); break;
 995:             default: comparison = a.name.localeCompare(b.name);
 996:           }
 997:           return sortDir === "ascending" ? comparison : -comparison;
 998:       });
 999:       // --- Now create the simple FileContent array for formatters --- //
1000:       const fileContents: FileContent[] = sortedProcessedFiles.map(file => ({
1001:           path: file.path,
1002:           content: file.content ?? '// Content unavailable',
1003:           // No isCompressed, name, lastModified here as FileContent doesn't expect them
1004:       }));
1005:        // Generate file tree string if needed
1006:        let fileTreeString = "";
1007:        if (selectedFolder && fileTreeMode !== 'none') {
1008:          // Corrected call to generateAsciiFileTree with 3 arguments
1009:          // Pass only the path property from sortedProcessedFiles
1010:          const pathsForTree = sortedProcessedFiles.map(f => ({ path: f.path }));
1011:          fileTreeString = generateAsciiFileTree(pathsForTree, selectedFolder, fileTreeMode);
1012:        }
1013:       // Format the output based on the selected format
1014:       let formattedOutput = "";
1015:       // Corrected calls to formatters with 5 arguments
1016:       switch (outputFormat) {
1017:         case 'xml': formattedOutput = formatAsXML(fileContents, selectedFolder, fileTreeMode, fileTreeString, userInstructions); break;
1018:         case 'markdown': formattedOutput = formatAsMarkdown(fileContents, selectedFolder, fileTreeMode, fileTreeString, userInstructions); break;
1019:         case 'plain': default: formattedOutput = formatAsPlain(fileContents, selectedFolder, fileTreeMode, fileTreeString, userInstructions); break;
1020:       }
1021:       setProcessingStatus({ status: 'complete', message: 'Output generated successfully!' });
1022:       setTimeout(() => setProcessingStatus({ status: 'idle', message: '' }), 2000);
1023:       return formattedOutput;
1024:     } catch (error: unknown) {
1025:       const errorMessage = error instanceof Error ? error.message : 'Unknown error';
1026:       console.error('Error generating output:', error);
1027:       setProcessingStatus({ status: 'error', message: `Error: ${errorMessage}` });
1028:       return `// Error generating output: ${errorMessage}`;
1029:     }
1030:   }, [
1031:     selectedFiles,
1032:     allFiles,
1033:     isCompressionEnabled,
1034:     isCommentRemovalEnabled,
1035:     keepDocstrings,
1036:     selectedContextLength,
1037:     applyDynamicCompression,
1038:     sortOrder,
1039:     outputFormat,
1040:     selectedFolder,
1041:     fileTreeMode,
1042:     userInstructions,
1043:     setProcessingStatus,
1044:     setDisplayedTokenCount,
1045:     neverCompressPatterns,
1046:     minCompressTokenThreshold,
1047:     removeEmptyLines
1048:   ]);
1049:   // Sort options
1050:   const sortOptions = useMemo(() => [
1051:     { value: "name-ascending", label: "Name (A-Z)" },
1052:     { value: "name-descending", label: "Name (Z-A)" },
1053:     { value: "tokens-ascending", label: "Tokens (Asc)" },
1054:     { value: "tokens-descending", label: "Tokens (Desc)" },
1055:     { value: "date-ascending", label: "Date (Oldest)" },
1056:     { value: "date-descending", label: "Date (Newest)" }
1057:   ], []);
1058:   // Handle expand/collapse state changes
1059:   const toggleExpanded = useCallback((nodeId: string) => {
1060:     setExpandedNodes(prev => {
1061:       const newState = new Map(prev);
1062:       newState.set(nodeId, !prev.get(nodeId)); // Simplified toggle
1063:       // Persisted via useEffect watching expandedNodes
1064:       return newState;
1065:     });
1066:   }, []); // Add empty dependency array
1067:   // --- Ignore Pattern Functions ---
1068:   // Load patterns (global or local)
1069:   const loadIgnorePatterns = useCallback(async (folderPath: string, isGlobal: boolean = false): Promise<void> => {
1070:     if (!isElectron) return;
1071:     console.log(`Requesting load for ${isGlobal ? 'global' : 'local'} patterns${!isGlobal ? ` for ${folderPath}` : ''}`);
1072:     try {
1073:         // Invoke expects the handler to exist. The result is handled by the 'ignore-patterns-loaded' listener.
1074:         await window.electron.loadIgnorePatterns({ folderPath, isGlobal });
1075:     } catch (error: unknown) {
1076:         const errorMessage = error instanceof Error ? error.message : 'Unknown error';
1077:         console.error(`Error invoking load-ignore-patterns (${isGlobal ? 'global' : 'local'}): ${errorMessage}`);
1078:         // Set default state on error
1079:         if (isGlobal) {
1080:             setGlobalPatternsState({ patterns: '', excludedSystemPatterns: [] });
1081:             setSystemIgnorePatterns(DEFAULT_SYSTEM_PATTERNS);
1082:         } else if (folderPath === selectedFolder) {
1083:             setLocalPatterns({ patterns: '', excludedSystemPatterns: [] });
1084:         }
1085:     }
1086: }, [isElectron, selectedFolder]); // Dependencies: isElectron, selectedFolder
1087:   // Save patterns (global or local) - Now just calls IPC
1088:   const saveIgnorePatterns = useCallback(async (patterns: string, isGlobal: boolean, folderPath?: string): Promise<void> => {
1089:     if (!isElectron) return;
1090:     const targetPath = folderPath || selectedFolder; // Use provided path or current folder for local
1091:     if (!isGlobal && !targetPath) {
1092:       console.error("Cannot save local patterns without a folder path.");
1093:       setProcessingStatus({ status: "error", message: "No folder selected for local patterns." });
1094:       return;
1095:     }
1096:     setProcessingStatus({ status: "processing", message: `Saving ${isGlobal ? "global" : "local"} patterns...` });
1097:     try {
1098:       // The string passed (`patterns`) should already include `# DISABLED:` comments
1099:       // generated by IgnorePatterns.tsx's handleSaveGlobalPatterns
1100:       const result = await window.electron.saveIgnorePatterns({
1101:         patterns,
1102:         isGlobal,
1103:         folderPath: targetPath ?? undefined
1104:       });
1105:       if (result.success) {
1106:         console.log(`IPC: Save ${isGlobal ? 'global' : 'local'} patterns successful.`);
1107:         // --- Update State --- 
1108:         if (isGlobal) {
1109:           // Assuming handleSaveGlobalPatterns in IgnorePatterns.tsx formats
1110:           // the string with user patterns and # DISABLED lines.
1111:           // We need to parse it back here if we want to store excluded separately.
1112:           // Or, simplify App.tsx state to just store the raw string.
1113:           // Let's parse it back for consistency:
1114:           const { excludedPatterns, userPatterns } = parseIgnorePatternsContent(patterns);
1115:           setGlobalPatternsState({ patterns: userPatterns, excludedSystemPatterns: excludedPatterns });
1116:         } else {
1117:           // For local patterns, the raw saved string is usually fine.
1118:           setLocalPatterns(prev => ({
1119:              ...prev, // Keep excludedSystemPatterns if it were relevant for local (it's not currently)
1120:              patterns: patterns // Update with the newly saved content
1121:            }));
1122:         }
1123:         // Immediately update the selected files to exclude any newly excluded files
1124:         // This ensures UI is updated before the folder reload completes
1125:         const newSelectedFiles = selectedFiles.filter(filePath => {
1126:           // Create a temporary ignore for checking
1127:           const tempIgnore = ignore().add(patterns.split('\n').filter(line => line.trim() && !line.startsWith('#')));
1128:           return !tempIgnore.ignores(filePath);
1129:         });
1130:         // Only update if there's a change to avoid unnecessary re-renders
1131:         if (newSelectedFiles.length !== selectedFiles.length) {
1132:           console.log(`Immediately filtered out ${selectedFiles.length - newSelectedFiles.length} newly excluded files from selection`);
1133:           setSelectedFiles(newSelectedFiles);
1134:           // Also update displayed files to reflect the changes
1135:           const updatedDisplayedFiles = displayedFiles.filter(file => 
1136:             newSelectedFiles.includes(file.path)
1137:           );
1138:           setDisplayedFiles(updatedDisplayedFiles);
1139:         }
1140:         // Reload the folder data to apply new patterns
1141:         // Add a small delay to ensure file system changes are registered
1142:         setTimeout(() => {
1143:           reloadFolder();
1144:           // After reloading, update selected files again to ensure consistency
1145:           setTimeout(() => {
1146:             // Filter out files that should be excluded based on new patterns
1147:             const newSelectedFiles = selectedFiles.filter(filePath => {
1148:               // Find the file in allFiles to check if it's excluded
1149:               const file = allFiles.find(f => f.path === filePath);
1150:               return file && !file.excludedByDefault;
1151:             });
1152:             // Only update if there's a change to avoid unnecessary re-renders
1153:             if (newSelectedFiles.length !== selectedFiles.length) {
1154:               console.log(`Filtered out ${selectedFiles.length - newSelectedFiles.length} newly excluded files from selection after reload`);
1155:               setSelectedFiles(newSelectedFiles);
1156:             }
1157:           }, 500); // Wait a bit after reload to ensure allFiles is updated
1158:         }, 300);
1159:       } else {
1160:         console.error(`IPC: Save ${isGlobal ? 'global' : 'local'} patterns failed:`, result.error);
1161:         setProcessingStatus({ status: "error", message: `Save failed: ${result.error}` });
1162:       }
1163:     } catch (error: unknown) {
1164:       const errorMessage = error instanceof Error ? error.message : 'Unknown error';
1165:       console.error("Error invoking save-ignore-patterns:", error);
1166:       setProcessingStatus({ status: "error", message: `Save failed: ${errorMessage}` });
1167:     }
1168:   }, [isElectron, selectedFolder, reloadFolder, selectedFiles, allFiles, setSelectedFiles, displayedFiles, setDisplayedFiles]);
1169:   // Reset patterns (global or local)
1170:   const resetIgnorePatterns = useCallback(async (isGlobal: boolean, folderPath?: string): Promise<void> => {
1171:     if (!isElectron) return;
1172:     const targetPath = folderPath || selectedFolder;
1173:     if (!isGlobal && !targetPath) {
1174:       console.error("Cannot reset local patterns without a folder path");
1175:       setProcessingStatus({ status: "error", message: "No folder selected for local patterns." });
1176:       return;
1177:     }
1178:     setProcessingStatus({ status: "processing", message: `Resetting ${isGlobal ? "global" : "local"} patterns...` });
1179:     try {
1180:       const result = await window.electron.resetIgnorePatterns({
1181:         folderPath: targetPath || undefined,
1182:         isGlobal
1183:       });
1184:       if (result.success) {
1185:         console.log(`IPC: Reset ${isGlobal ? 'global' : 'local'} patterns successful`);
1186:         // Update state with the default values returned
1187:         if (isGlobal) {
1188:           setGlobalPatternsState({
1189:             patterns: result.patterns || '',
1190:             excludedSystemPatterns: []
1191:           });
1192:         } else {
1193:           setLocalPatterns({
1194:             patterns: result.patterns || '',
1195:             excludedSystemPatterns: []
1196:           });
1197:         }
1198:         // Immediately update selected files based on default patterns
1199:         if (result.patterns) {
1200:           const defaultPatterns = result.patterns;
1201:           const newSelectedFiles = selectedFiles.filter(filePath => {
1202:             // Create a temporary ignore for checking
1203:             const tempIgnore = ignore().add(defaultPatterns.split('\n').filter(line => line.trim() && !line.startsWith('#')));
1204:             return !tempIgnore.ignores(filePath);
1205:           });
1206:           // Only update if there's a change to avoid unnecessary re-renders
1207:           if (newSelectedFiles.length !== selectedFiles.length) {
1208:             console.log(`Immediately filtered out ${selectedFiles.length - newSelectedFiles.length} newly excluded files from selection after reset`);
1209:             setSelectedFiles(newSelectedFiles);
1210:             // Also update displayed files to reflect the changes
1211:             const updatedDisplayedFiles = displayedFiles.filter(file => 
1212:               newSelectedFiles.includes(file.path)
1213:             );
1214:             setDisplayedFiles(updatedDisplayedFiles);
1215:           }
1216:         }
1217:         // Reload the folder data to apply new patterns
1218:         setTimeout(() => {
1219:           reloadFolder();
1220:           // After reloading, update selected files again to ensure consistency
1221:           setTimeout(() => {
1222:             // Filter out files that should be excluded based on new patterns
1223:             const newSelectedFiles = selectedFiles.filter(filePath => {
1224:               // Find the file in allFiles to check if it's excluded
1225:               const file = allFiles.find(f => f.path === filePath);
1226:               return file && !file.excludedByDefault;
1227:             });
1228:             // Only update if there's a change to avoid unnecessary re-renders
1229:             if (newSelectedFiles.length !== selectedFiles.length) {
1230:               console.log(`Filtered out ${selectedFiles.length - newSelectedFiles.length} newly excluded files from selection after reload`);
1231:               setSelectedFiles(newSelectedFiles);
1232:             }
1233:           }, 500); // Wait a bit after reload to ensure allFiles is updated
1234:         }, 300);
1235:       } else {
1236:         console.error(`IPC: Reset ${isGlobal ? 'global' : 'local'} patterns failed:`, result.error);
1237:         setProcessingStatus({ status: "error", message: `Reset failed: ${result.error}` });
1238:       }
1239:     } catch (error: unknown) {
1240:       const errorMessage = error instanceof Error ? error.message : 'Unknown error';
1241:       console.error("Error invoking reset-ignore-patterns:", error);
1242:       setProcessingStatus({ status: "error", message: `Reset failed: ${errorMessage}` });
1243:     }
1244:   }, [isElectron, selectedFolder, reloadFolder, selectedFiles, allFiles, setSelectedFiles, displayedFiles, setDisplayedFiles]);
1245:   // Clear local ignore patterns (no global counterpart)
1246:   const clearLocalIgnorePatterns = useCallback(async (folderPath: string): Promise<void> => {
1247:     if (!isElectron) return;
1248:     if (!folderPath) {
1249:       console.error("Cannot clear local patterns without a folder path");
1250:       setProcessingStatus({ status: "error", message: "No folder selected for local patterns." });
1251:       return;
1252:     }
1253:     setProcessingStatus({ status: "processing", message: "Clearing local patterns..." });
1254:     try {
1255:       const result = await window.electron.clearLocalIgnorePatterns({
1256:         folderPath
1257:       });
1258:       if (result.success) {
1259:         console.log("IPC: Clear local patterns successful");
1260:         setProcessingStatus({ status: "complete", message: "Local patterns cleared." });
1261:         // Update local patterns state (empty string, no exclusions)
1262:         setLocalPatterns({
1263:           patterns: '',
1264:           excludedSystemPatterns: []
1265:         });
1266:         // Since we're clearing patterns, more files might now be included
1267:         // We don't need to filter the selected files immediately since we're removing restrictions
1268:         // But we should update the displayed files to be consistent with the allFiles list after reload
1269:         // Reload folder data to apply changes
1270:         setTimeout(() => {
1271:           reloadFolder();
1272:           // After reloading, update selected files to exclude any newly excluded files
1273:           setTimeout(() => {
1274:             // Filter out files that should be excluded based on new patterns
1275:             const newSelectedFiles = selectedFiles.filter(filePath => {
1276:               // Find the file in allFiles to check if it's excluded
1277:               const file = allFiles.find(f => f.path === filePath);
1278:               return file && !file.excludedByDefault;
1279:             });
1280:             // Only update if there's a change to avoid unnecessary re-renders
1281:             if (newSelectedFiles.length !== selectedFiles.length) {
1282:               console.log(`Filtered out ${selectedFiles.length - newSelectedFiles.length} newly excluded files from selection after reload`);
1283:               setSelectedFiles(newSelectedFiles);
1284:             }
1285:           }, 500); // Wait a bit after reload to ensure allFiles is updated
1286:         }, 300);
1287:       } else {
1288:         console.error("IPC: Clear local patterns failed:", result.error);
1289:         setProcessingStatus({ status: "error", message: `Clear failed: ${result.error}` });
1290:       }
1291:     } catch (error: unknown) {
1292:       const errorMessage = error instanceof Error ? error.message : 'Unknown error';
1293:       console.error("Error invoking clear-local-ignore-patterns:", error);
1294:       setProcessingStatus({ status: "error", message: `Clear failed: ${errorMessage}` });
1295:     }
1296:   }, [isElectron, reloadFolder, selectedFiles, allFiles, setSelectedFiles]);
1297:   // --- Dialog State & Handlers ---
1298:   const [showClearSelectionDialog, setShowClearSelectionDialog] = useState(false);
1299:   const [showRemoveAllFoldersDialog, setShowRemoveAllFoldersDialog] = useState(false);
1300:   const [showResetPatternsDialog, setShowResetPatternsDialog] = useState(false);
1301:   const [resetPatternsContext, setResetPatternsContext] = useState<{isGlobal: boolean; folderPath: string | null}>({isGlobal: false, folderPath: null});
1302:   const handleClearSelectionClick = useCallback(() => setShowClearSelectionDialog(true), []);
1303:   const clearSelection = useCallback(() => { setSelectedFiles([]); setShowClearSelectionDialog(false); }, []);
1304:   const handleRemoveAllFoldersClick = useCallback(() => setShowRemoveAllFoldersDialog(true), []);
1305:   const removeAllFolders = useCallback(() => {
1306:     setSelectedFolder(null); setAllFiles([]); setSelectedFiles([]); setDisplayedFiles([]);
1307:     setLocalPatterns({ patterns: '', excludedSystemPatterns: [] }); // Reset local patterns
1308:     localStorage.removeItem(STORAGE_KEYS.SELECTED_FOLDER);
1309:     localStorage.removeItem(STORAGE_KEYS.SELECTED_FILES);
1310:     localStorage.removeItem(STORAGE_KEYS.EXPANDED_NODES); // Also clear expanded nodes
1311:     setExpandedNodes(new Map()); // Reset map in state
1312:     sessionStorage.removeItem("hasLoadedInitialData");
1313:     setShowRemoveAllFoldersDialog(false);
1314:   }, []);
1315:   const confirmResetPatterns = useCallback(() => {
1316:     if (resetPatternsContext) {
1317:       resetIgnorePatterns(resetPatternsContext.isGlobal, resetPatternsContext.folderPath || undefined);
1318:     }
1319:     setShowResetPatternsDialog(false);
1320:     setResetPatternsContext({isGlobal: false, folderPath: null});
1321:   }, [resetPatternsContext, resetIgnorePatterns]);
1322:   // --- Helper Functions ---
1323:   const truncatePath = (path: string | null): string => {
1324:     if (!path) return "No folder selected";
1325:     const parts = path.split(/[/\\]/); // Handle both slash types
1326:     if (parts.length <= 3) return path;
1327:     const lastParts = parts.filter(p => p).slice(-2);
1328:     return `.../${lastParts.join('/')}`;
1329:   };
1330:   // Callback for IgnorePatterns component to update global excluded patterns
1331:   const handleExcludedSystemPatternsChange = useCallback((newExcluded: string[]) => {
1332:     setGlobalPatternsState((prev: IgnorePatternsState) => ({
1333:       ...prev,
1334:       excludedSystemPatterns: newExcluded
1335:     }));
1336:   }, []);
1337:   const _processingToastIds = useRef<Record<string, string>>({});
1338:   const _fileOperationRef = useRef<{ inProgress: boolean }>({ inProgress: false });
1339:   // Processing status effect - show toast notifications instead of StatusAlert
1340:   useEffect(() => {
1341:     if (processingStatus.status === 'processing') {
1342:       // For processing status
1343:       showToast.info(processingStatus.message);
1344:     } 
1345:     else if (processingStatus.status === 'complete') {
1346:       // For completion status
1347:       showToast.success(processingStatus.message);
1348:       // Auto-reset to idle after a delay
1349:       const timer = setTimeout(() => {
1350:         setProcessingStatus({ status: 'idle', message: '' });
1351:       }, 5000);
1352:       return () => clearTimeout(timer);
1353:     }
1354:     else if (processingStatus.status === 'error') {
1355:       // For error status
1356:       showToast.error(processingStatus.message);
1357:     }
1358:   }, [processingStatus.status, processingStatus.message]);
1359:   // --- Handler for Model Selection ---
1360:   const handleModelChange = useCallback((modelId: string | null) => {
1361:     console.log(`Model selected: ${modelId}`);
1362:     // Find the corresponding model info and update context length
1363:     if (modelId && availableModels) {
1364:       const selectedModel = availableModels.find(model => model.id === modelId);
1365:       if (selectedModel) {
1366:         // Update states with the valid model
1367:         setSelectedModelId(modelId);
1368:         setSelectedContextLength(selectedModel.context_length);
1369:         console.log(`Set context length: ${selectedModel.context_length}`);
1370:         // Persist to localStorage
1371:         localStorage.setItem(STORAGE_KEYS.SELECTED_MODEL_ID, modelId);
1372:         console.log(`Persisted modelId ${modelId} to localStorage`);
1373:       } else {
1374:         console.warn(`Selected model ID ${modelId} not found in available models.`);
1375:         // Try to recover with first available model
1376:         if (availableModels.length > 0) {
1377:           const firstModel = availableModels[0];
1378:           setSelectedModelId(firstModel.id);
1379:           setSelectedContextLength(firstModel.context_length);
1380:           localStorage.setItem(STORAGE_KEYS.SELECTED_MODEL_ID, firstModel.id);
1381:           console.log(`Recovered with model ${firstModel.id}, context length: ${firstModel.context_length}`);
1382:         } else {
1383:           // No models available - use sensible defaults
1384:           setSelectedModelId(null);
1385:           setSelectedContextLength(128000); // A safe default
1386:           localStorage.removeItem(STORAGE_KEYS.SELECTED_MODEL_ID);
1387:           console.warn('No models available for recovery - using defaults');
1388:         }
1389:       }
1390:     } else {
1391:       // Handle null selection (should be rare in UI)
1392:       setSelectedModelId(null);
1393:       setSelectedContextLength(null);
1394:       localStorage.removeItem(STORAGE_KEYS.SELECTED_MODEL_ID);
1395:       console.log('Cleared model selection');
1396:     }
1397:   }, [availableModels]); // Add availableModels dependency
1398:   // Handler to force refresh of models list
1399:   const handleRefreshModels = useCallback(async () => {
1400:     if (!isElectron) return;
1401:     console.log("Manually refreshing models list...");
1402:     setProcessingStatus({ status: "processing", message: "Refreshing models..." });
1403:     setIsLoadingModels(true);
1404:     try {
1405:       // Call fetchModels with forceRefresh=true to skip cache
1406:       const fetchedModels = await fetchModels(true);
1407:       const modelsToUse = (fetchedModels as ModelInfo[] | null) || [];
1408:       // If still no models, use fallbacks
1409:       const finalModels = modelsToUse.length > 0 
1410:         ? modelsToUse 
1411:         : [
1412:             { id: "openai/gpt-4o", name: "GPT-4o (Fallback)", context_length: 128000 },
1413:             { id: "anthropic/claude-3-5-sonnet-20240620", name: "Claude 3.5 Sonnet (Fallback)", context_length: 200000 }
1414:           ];
1415:       // Update available models state
1416:       setAvailableModels(finalModels);
1417:       // Update selected model if needed
1418:       if (selectedModelId) {
1419:         const selectedModel = finalModels.find(m => m.id === selectedModelId);
1420:         if (selectedModel) {
1421:           // Current model still exists, update its context length
1422:           setSelectedContextLength(selectedModel.context_length);
1423:           console.log(`Updated context length for ${selectedModelId}: ${selectedModel.context_length}`);
1424:         } else if (finalModels.length > 0) {
1425:           // Selected model no longer exists, switch to first available
1426:           const firstModel = finalModels[0];
1427:           setSelectedModelId(firstModel.id);
1428:           setSelectedContextLength(firstModel.context_length);
1429:           localStorage.setItem(STORAGE_KEYS.SELECTED_MODEL_ID, firstModel.id);
1430:           console.log(`Selected model no longer available. Switched to: ${firstModel.id}`);
1431:         }
1432:       }
1433:       setProcessingStatus({ status: "complete", message: `Refreshed ${finalModels.length} models` });
1434:       setTimeout(() => setProcessingStatus({ status: "idle", message: "" }), 2000);
1435:     } catch (error) {
1436:       console.error("Error refreshing models:", error);
1437:       setProcessingStatus({ 
1438:         status: "error", 
1439:         message: `Failed to refresh models: ${error instanceof Error ? error.message : 'Unknown error'}`
1440:       });
1441:     } finally {
1442:       setIsLoadingModels(false);
1443:       // Make sure initialModelLoadComplete stays true (just in case)
1444:       setInitialModelLoadComplete(true);
1445:     }
1446:   }, [isElectron, selectedModelId]);
1447:   const [isGuideOpen, setIsGuideOpen] = useState(false);
1448:   const handleGuideClick = () => {
1449:     setIsGuideOpen(true);
1450:   };
1451:   // --- Render ---
1452:   return (
1453:     <ThemeProvider>
1454:       <div className={styles.app}>
1455:         <Toast />
1456:         {/* Toast component added to make it available throughout the app */}
1457:         {isElectron && (
1458:           <div className={styles.appContainer}>
1459:             <header className={styles.appHeader}>
1460:               <h1>ContextCraft</h1>
1461:               <div className={styles.headerActions}>
1462:                 <Button 
1463:                   variant="ghost" 
1464:                   size="sm"
1465:                   onClick={handleGuideClick}
1466:                   startIcon={<HelpCircle size={16} />}
1467:                 >
1468:                   Guide
1469:                 </Button>
1470:                 <div className={styles.headerSeparator}></div>
1471:                 <ThemeToggle />
1472:                 <div className={styles.headerSeparator}></div>
1473:                 <a href="https://github.com/flight505/ContextCraft" target="_blank" rel="noopener noreferrer" className={styles.githubButton}>
1474:                   <Github size={16} />
1475:                 </a>
1476:               </div>
1477:             </header>
1478:             {/* Remove StatusAlert in favor of Toast notifications */}
1479:             <div className={styles.mainContainer}>
1480:               <Sidebar
1481:                 selectedFolder={selectedFolder}
1482:                 openFolder={openFolder}
1483:                 allFiles={allFiles}
1484:                 selectedFiles={selectedFiles}
1485:                 toggleFileSelection={toggleFileSelection}
1486:                 toggleFolderSelection={toggleFolderSelection}
1487:                 searchTerm={searchTerm}
1488:                 onSearchChange={handleSearchChange}
1489:                 selectAllFiles={selectAllFiles}
1490:                 deselectAllFiles={deselectAllFiles}
1491:                 expandedNodes={expandedNodes}
1492:                 toggleExpanded={toggleExpanded}
1493:                 reloadFolder={reloadFolder}
1494:                 clearSelection={clearSelection}
1495:                 removeAllFolders={removeAllFolders}
1496:                 loadIgnorePatterns={loadIgnorePatterns}
1497:                 saveIgnorePatterns={saveIgnorePatterns}
1498:                 resetIgnorePatterns={resetIgnorePatterns}
1499:                 systemIgnorePatterns={systemIgnorePatterns}
1500:                 clearIgnorePatterns={clearLocalIgnorePatterns}
1501:                 onClearSelectionClick={handleClearSelectionClick}
1502:                 onRemoveAllFoldersClick={handleRemoveAllFoldersClick}
1503:                 fileTreeSortOrder={fileTreeSortOrder}
1504:                 onSortOrderChange={setFileTreeSortOrder}
1505:                 globalPatternsState={globalPatternsState}
1506:                 localPatternsState={localIgnorePatterns}
1507:                 onExcludedSystemPatternsChange={handleExcludedSystemPatternsChange}
1508:                 setIgnorePatterns={() => {}}
1509:                 _availableModels={availableModels}
1510:                 _selectedModelId={selectedModelId}
1511:                 _onModelChange={handleModelChange}
1512:               />
1513:               {selectedFolder ? (
1514:                 <div className={styles.contentArea}>
1515:                   <div className={styles.contentHeader}>
1516:                     <div className={styles.folderPathDisplay} title={selectedFolder}>
1517:                       <span className={styles.pathLabel}>{'>_'}</span> {truncatePath(selectedFolder)}
1518:                     </div>
1519:                     <div className={styles.headerSeparator} />
1520:                     <div className={styles.contentActions}>
1521:                       <Dropdown
1522:                         options={sortOptions}
1523:                         value={sortOrder}
1524:                         onChange={handleSortChange}
1525:                         trigger={
1526:                           <Button variant="secondary" size="sm" startIcon={getSortIcon(sortOrder)}> Sort </Button>
1527:                         }
1528:                       />
1529:                     </div>
1530:                     <div className={styles.headerSeparator} />
1531:                     <div className={styles.fileStats}>
1532:                       <span>{selectedFiles.length}</span> files selected (<span>{displayedTokenCount.toLocaleString()}</span> tokens)
1533:                     </div>
1534:                   </div>
1535:                   <FileList
1536:                     files={displayedFiles} // Pass metadata only
1537:                     selectedFiles={selectedFiles}
1538:                     toggleFileSelection={toggleFileSelection}
1539:                   />
1540:                   {showUserInstructions && (
1541:                     <div className={styles.userInstructionsContainer}>
1542:                       <UserInstructionsWithTemplates
1543:                         instructions={userInstructions}
1544:                         setInstructions={setUserInstructions}
1545:                       />
1546:                     </div>
1547:                   )}
1548:                   <ControlContainer
1549:                     fileTreeMode={fileTreeMode}
1550:                     setFileTreeMode={setFileTreeMode}
1551:                     showUserInstructions={showUserInstructions}
1552:                     setShowUserInstructions={setShowUserInstructions}
1553:                     getSelectedFilesContent={getSelectedFilesContent} // Now async
1554:                     selectedFilesCount={selectedFiles.length}
1555:                     outputFormat={outputFormat}
1556:                     setOutputFormat={setOutputFormat}
1557:                     availableModels={availableModels}
1558:                     selectedModelId={selectedModelId}
1559:                     onModelChange={handleModelChange}
1560:                     isElectron={isElectron}
1561:                     processingStatus={processingStatus.status}
1562:                     onGenerateOutput={() => {}} // Assuming generateOutput uses selected model
1563:                     totalTokenCount={displayedTokenCount}
1564:                     selectedContextLength={selectedContextLength}
1565:                     isCompressionEnabled={isCompressionEnabled}
1566:                     setIsCompressionEnabled={setIsCompressionEnabled}
1567:                     isCommentRemovalEnabled={isCommentRemovalEnabled}
1568:                     setIsCommentRemovalEnabled={setIsCommentRemovalEnabled}
1569:                     onRefreshModels={handleRefreshModels}
1570:                     // Pass new props for enhanced compression controls
1571:                     keepDocstrings={keepDocstrings}
1572:                     setKeepDocstrings={setKeepDocstrings}
1573:                     removeEmptyLines={removeEmptyLines}
1574:                     setRemoveEmptyLines={setRemoveEmptyLines}
1575:                     neverCompressPatterns={neverCompressPatterns}
1576:                     neverCompressPatternsRaw={neverCompressPatternsRaw}
1577:                     setNeverCompressPatternsRaw={setNeverCompressPatternsRaw}
1578:                     minCompressTokenThreshold={minCompressTokenThreshold}
1579:                     setMinCompressTokenThreshold={setMinCompressTokenThreshold}
1580:                   />
1581:                 </div>
1582:               ) : (
1583:                 <div className={styles.contentArea}>
1584:                   <div className={styles.emptyStateContent}>
1585:                     <h2>Welcome to ContextCraft</h2>
1586:                     <p>Select a folder to get started.</p>
1587:                     <Button variant="primary" onClick={openFolder} className="mt-4"> Select Project Folder </Button>
1588:                   </div>
1589:                 </div>
1590:               )}
1591:             </div>
1592:             {/* Add GuideModal */}
1593:             <GuideModal 
1594:               isOpen={isGuideOpen} 
1595:               onClose={() => setIsGuideOpen(false)} 
1596:             />
1597:             {/* Confirmation Dialogs */}
1598:             <ConfirmationDialog isOpen={showClearSelectionDialog} onClose={() => setShowClearSelectionDialog(false)} onConfirm={clearSelection} title="Clear Selection" description="Clear all selected files?" confirmLabel="Clear" variant="destructive" />
1599:             <ConfirmationDialog isOpen={showRemoveAllFoldersDialog} onClose={() => setShowRemoveAllFoldersDialog(false)} onConfirm={removeAllFolders} title="Remove All Folders" description="Remove all folders and reset the application?" confirmLabel="Remove All" variant="destructive" />
1600:             <ConfirmationDialog isOpen={showResetPatternsDialog} onClose={() => setShowResetPatternsDialog(false)} onConfirm={confirmResetPatterns} title={`Reset ${resetPatternsContext?.isGlobal ? 'Global' : 'Local'} Ignore Patterns`} description="Reset patterns to their default values?" confirmLabel="Reset" variant="destructive" />
1601:           </div>
1602:         )}
1603:       </div>
1604:     </ThemeProvider>
1605:   );
1606: };
1607: export default App;

================
File: electron/main.js
================
   1: const { app, BrowserWindow, ipcMain, protocol, session, dialog, globalShortcut, shell } = require("electron");
   2: const fs = require("fs");
   3: const path = require("path");
   4: const os = require("os");
   5: const url = require("url");
   6: const minimatch = require("minimatch");
   7: const { promisify } = require("util");
   8: const micromatch = require('micromatch');
   9: const { networkInterfaces } = require('os');
  10: const childProcess = require('child_process');
  11: // Simplified module loading
  12: let chokidar;
  13: // No-op watcher creator function
  14: function createNoOpWatcher() {
  15:   console.log("Creating no-op file watcher as fallback");
  16:   return {
  17:     watch: () => ({
  18:       on: () => {},
  19:       close: () => {}
  20:     })
  21:   };
  22: }
  23: // In development mode, loading is straightforward
  24: if (!app.isPackaged) {
  25:   try {
  26:     chokidar = require('chokidar');
  27:     console.log("Successfully loaded chokidar in development mode");
  28:   } catch (err) {
  29:     console.error(`Failed to load chokidar in development: ${err.message}`);
  30:     chokidar = createNoOpWatcher();
  31:   }
  32: } else {
  33:   // Production mode - try multiple possible locations
  34:   try {
  35:     const resourcesPath = process.resourcesPath;
  36:     const possiblePaths = [
  37:       // Standard path in resources
  38:       path.join(resourcesPath, 'node_modules', 'chokidar'),
  39:       // Unpacked location
  40:       path.join(resourcesPath, 'app.asar.unpacked', 'node_modules', 'chokidar'),
  41:       // Temp resources paths created by fix-module-deps.js
  42:       path.join(resourcesPath, 'temp-resources', 'node_modules', 'chokidar'),
  43:       path.join(resourcesPath, 'temp-resources', 'app.asar.unpacked', 'node_modules', 'chokidar'),
  44:       // App path locations
  45:       path.join(app.getAppPath(), 'node_modules', 'chokidar'),
  46:       // Direct require (uses Node's resolution algorithm)
  47:       'chokidar'
  48:     ];
  49:     let loaded = false;
  50:     let lastError = null;
  51:     // Try each path in order
  52:     for (const modulePath of possiblePaths) {
  53:       try {
  54:         console.log(`Trying to load chokidar from: ${modulePath}`);
  55:         if (modulePath !== 'chokidar' && !fs.existsSync(modulePath)) {
  56:           console.log(`Path does not exist: ${modulePath}`);
  57:           continue;
  58:         }
  59:         chokidar = require(modulePath);
  60:         console.log(`Successfully loaded chokidar from: ${modulePath}`);
  61:         loaded = true;
  62:         break;
  63:       } catch (err) {
  64:         console.log(`Failed to load from ${modulePath}: ${err.message}`);
  65:         lastError = err;
  66:       }
  67:     }
  68:     if (!loaded) {
  69:       throw new Error(`Could not load chokidar from any location: ${lastError?.message || 'Unknown error'}`);
  70:     }
  71:   } catch (err) {
  72:     console.error(`Failed to load chokidar: ${err.message}`);
  73:     chokidar = createNoOpWatcher();
  74:   }
  75: }
  76: // Helper function to try resolving modules from multiple locations
  77: const tryLoadModule = (moduleName) => {
  78:   const possiblePaths = [
  79:     // Resources path (where extraResources copies modules)
  80:     path.join(process.resourcesPath, 'node_modules', moduleName),
  81:     // Standard node_modules path
  82:     moduleName,
  83:     // From extraResources (relative to app.getAppPath())
  84:     path.join(app.getAppPath(), 'node_modules', moduleName),
  85:     // From extraResources/asarUnpack (using resourcesPath)
  86:     path.join(process.resourcesPath, 'app.asar.unpacked', 'node_modules', moduleName)
  87:   ];
  88:   for (const modulePath of possiblePaths) {
  89:     try {
  90:       console.log(`Trying to load ${moduleName} from: ${modulePath}`);
  91:       return require(modulePath);
  92:     } catch (err) {
  93:       console.log(`Failed to load from ${modulePath}: ${err.message}`);
  94:     }
  95:   }
  96:   throw new Error(`Could not load ${moduleName} from any location`);
  97: };
  98: // Show diagnostics to help debug module loading
  99: showModuleLoadingDiagnostics();
 100: // Safely require DOMPurify and JSDOM with fallbacks for production
 101: let createDOMPurify, JSDOM, DOMPurify;
 102: try {
 103:   createDOMPurify = tryLoadModule('dompurify');
 104:   const jsdom = tryLoadModule('jsdom');
 105:   JSDOM = jsdom.JSDOM;
 106:   // Initialize DOMPurify with JSDOM window
 107:   const window = new JSDOM('').window;
 108:   DOMPurify = createDOMPurify(window);
 109:   console.log("Successfully loaded DOMPurify and JSDOM");
 110: } catch (err) {
 111:   console.warn("DOMPurify or JSDOM not available:", err.message);
 112:   // Create no-op fallback for DOMPurify.sanitize
 113:   DOMPurify = {
 114:     sanitize: (content) => {
 115:       console.warn("DOMPurify sanitize called but not available");
 116:       // Simple fallback - handle HTML escape on your own if needed
 117:       return content;
 118:     }
 119:   };
 120: }
 121: const { execSync } = require('child_process');
 122: const { excludedFiles, binaryExtensions, systemExclusions, defaultUserPatterns } = require("./excluded-files");
 123: // Load ignore module with resilience
 124: let ignore;
 125: try {
 126:   ignore = tryLoadModule("ignore");
 127:   console.log("Successfully loaded ignore module");
 128: } catch (err) {
 129:   console.error("Failed to load ignore module:", err);
 130:   // Simple fallback implementation for when the ignore module fails to load
 131:   ignore = {
 132:     // Simple implementation that just matches exact paths
 133:     createFilter: () => {
 134:       return (path) => !excludedFiles.includes(path);
 135:     },
 136:   };
 137:   console.log("Using fallback for ignore module");
 138: }
 139: // Add require for the new TreeSitter utilities with improved error handling
 140: let mainProcessCompressCode = null;
 141: let mainProcessRemoveComments = null;
 142: // Helper function to try loading a module from multiple possible paths
 143: const tryRequireFromPaths = (modulePath) => {
 144:   const possiblePaths = [
 145:     // For resources path (extraResources)
 146:     path.join(process.resourcesPath, 'node_modules/tree-sitter'),
 147:     // Standard relative path
 148:     modulePath,
 149:     // From app path
 150:     path.join(app.getAppPath(), modulePath),
 151:     // Absolute path for packaged app
 152:     path.join(process.resourcesPath, 'app.asar', modulePath),
 153:     // For unpacked resources
 154:     path.join(process.resourcesPath, 'app.asar.unpacked', modulePath),
 155:   ];
 156:   for (const tryPath of possiblePaths) {
 157:     try {
 158:       return require(tryPath);
 159:     } catch (err) {
 160:       console.log(`Failed to load from ${tryPath}`);
 161:       // Continue to next path
 162:     }
 163:   }
 164:   throw new Error(`Failed to load module from any location: ${modulePath}`);
 165: };
 166: try {
 167:   // Try to load tree-sitter utils from multiple possible locations
 168:   const treeSitterUtils = tryLoadModule('./utils/treeSitterUtils');
 169:   mainProcessCompressCode = treeSitterUtils.mainProcessCompressCode;
 170:   mainProcessRemoveComments = treeSitterUtils.mainProcessRemoveComments;
 171:   console.log("Successfully loaded TreeSitter utilities");
 172: } catch (err) {
 173:   console.error("Failed to load TreeSitter utilities:", err.message);
 174:   // Create no-op fallbacks for the functions
 175:   mainProcessCompressCode = (source) => {
 176:     console.warn("TreeSitter compressCode called but not available");
 177:     return source; // Return original source as fallback
 178:   };
 179:   mainProcessRemoveComments = (source) => {
 180:     console.warn("TreeSitter removeComments called but not available");
 181:     return source; // Return original source as fallback
 182:   };
 183: }
 184: // For backward compatibility - use systemExclusions as the new single source of truth
 185: const DEFAULT_EXCLUSIONS = systemExclusions;
 186: // Function to show diagnostics about the environment to help debug module loading issues
 187: function showModuleLoadingDiagnostics() {
 188:   const os = require('os');
 189:   const { execSync } = require('child_process');
 190:   console.log('\n============= MODULE LOADING DIAGNOSTICS =============');
 191:   console.log(`App location: ${app.getAppPath()}`);
 192:   console.log(`Resources path: ${process.resourcesPath || 'Not available'}`);
 193:   console.log(`Executable path: ${app.getPath('exe')}`);
 194:   console.log(`Current directory: ${process.cwd()}`);
 195:   console.log(`Is packaged: ${app.isPackaged}`);
 196:   console.log(`Platform: ${process.platform}`);
 197:   console.log(`Architecture: ${process.arch}`);
 198:   console.log(`Node.js version: ${process.version}`);
 199:   console.log(`Electron version: ${process.versions.electron}`);
 200:   // Check module resolution paths
 201:   console.log(`\nNode module paths:`);
 202:   try {
 203:     const modulePaths = module.paths;
 204:     modulePaths.forEach((p, i) => console.log(`  ${i+1}. ${p}`));
 205:   } catch (err) {
 206:     console.error(`Error getting module paths: ${err.message}`);
 207:   }
 208:   // File system permissions check
 209:   console.log('\nFile system access checks:');
 210:   const pathsToCheck = [
 211:     process.resourcesPath,
 212:     process.cwd(),
 213:     app.getAppPath(),
 214:     path.join(process.resourcesPath, 'node_modules'),
 215:     path.join(process.resourcesPath, 'app.asar.unpacked'),
 216:     path.join(app.getAppPath(), 'node_modules')
 217:   ];
 218:   pathsToCheck.forEach(p => {
 219:     if (!p) return;
 220:     try {
 221:       console.log(`Checking access to ${p}:`);
 222:       if (fs.existsSync(p)) {
 223:         console.log(`  ✓ Path exists`);
 224:         try {
 225:           const stats = fs.statSync(p);
 226:           console.log(`  ✓ Is directory: ${stats.isDirectory()}`);
 227:           if (stats.isDirectory()) {
 228:             try {
 229:               const items = fs.readdirSync(p);
 230:               console.log(`  ✓ Contains ${items.length} items`);
 231:               if (items.length <= 10) {
 232:                 console.log(`    Contents: ${items.join(', ')}`);
 233:               } else {
 234:                 console.log(`    First 10 items: ${items.slice(0, 10).join(', ')}...`);
 235:               }
 236:             } catch (err) {
 237:               console.log(`  ✗ Cannot read directory: ${err.message}`);
 238:             }
 239:           }
 240:         } catch (err) {
 241:           console.log(`  ✗ Cannot stat path: ${err.message}`);
 242:         }
 243:       } else {
 244:         console.log(`  ✗ Path does not exist`);
 245:       }
 246:     } catch (err) {
 247:       console.log(`  ✗ Error checking path: ${err.message}`);
 248:     }
 249:   });
 250:   // Environment variables (filter out sensitive ones)
 251:   console.log('\nRelevant environment variables:');
 252:   const safeEnvVars = ['PATH', 'NODE_PATH', 'ELECTRON_RUN_AS_NODE', 'ELECTRON_NO_ASAR'];
 253:   safeEnvVars.forEach(name => {
 254:     console.log(`  ${name}: ${process.env[name] || 'not set'}`);
 255:   });
 256:   // Network interfaces
 257:   console.log('\nNetwork information:');
 258:   try {
 259:     const networkInterfaces = os.networkInterfaces();
 260:     Object.keys(networkInterfaces).forEach(ifName => {
 261:       networkInterfaces[ifName].forEach(iface => {
 262:         // Filter out internal IP addresses and sensitive info
 263:         if (!iface.internal) {
 264:           console.log(`  Interface: ${ifName}, IP: ${iface.address}, Family: IPv${iface.family}`);
 265:         }
 266:       });
 267:     });
 268:   } catch (err) {
 269:     console.error(`Error getting network interfaces: ${err.message}`);
 270:   }
 271:   console.log('\n====================================================\n');
 272: }
 273: // Global variables for directory loading control
 274: let isLoadingDirectory = false;
 275: let loadingTimeoutId = null;
 276: const MAX_DIRECTORY_LOAD_TIME = 30000; // 30 seconds timeout
 277: // Global variable for file watcher
 278: let fileWatcher = null;
 279: let addDebounce = null;
 280: let changeDebounce = null;
 281: let deleteDebounce = null;
 282: const WATCH_DEBOUNCE_TIME = 300; // 300ms debounce time for file changes
 283: /**
 284:  * Safer fs.watch wrapper that handles errors and works across platforms
 285:  * @param {string} dir Directory to watch
 286:  * @param {Function} callback Callback function(eventType, filename)
 287:  * @returns {object} Watcher object with close method
 288:  */
 289: function safeFsWatch(dir, callback) {
 290:   if (!fs.existsSync(dir)) {
 291:     return { close: () => {} };
 292:   }
 293:   try {
 294:     const watcher = fs.watch(dir, { recursive: false }, (eventType, filename) => {
 295:       if (!filename) return;
 296:       try {
 297:         callback(eventType, filename);
 298:       } catch (err) {
 299:         console.error(`Error in watch callback for ${dir}/${filename}:`, err);
 300:       }
 301:     });
 302:     return watcher;
 303:   } catch (err) {
 304:     console.error(`Error watching directory ${dir}:`, err);
 305:     return { close: () => {} };
 306:   }
 307: }
 308: // Cache for directory contents to avoid repeated processing
 309: const directoryCache = {
 310:   // Format: { path: { timestamp: Date, files: [] } }
 311:   cache: {},
 312:   // Cache expiration time (5 minutes)
 313:   CACHE_EXPIRY: 5 * 60 * 1000,
 314:   // Get files from cache if available and not expired
 315:   get: function(path) {
 316:     const normalizedPath = normalizePath(path);
 317:     const entry = this.cache[normalizedPath];
 318:     if (!entry) return null;
 319:     // Check if cache is expired
 320:     const now = new Date().getTime();
 321:     if (now - entry.timestamp > this.CACHE_EXPIRY) {
 322:       delete this.cache[normalizedPath];
 323:       return null;
 324:     }
 325:     console.log(`Using cached directory content for ${normalizedPath}`);
 326:     return entry.files;
 327:   },
 328:   // Store files in cache
 329:   set: function(path, files) {
 330:     const normalizedPath = normalizePath(path);
 331:     this.cache[normalizedPath] = {
 332:       timestamp: new Date().getTime(),
 333:       files: files
 334:     };
 335:     console.log(`Cached directory content for ${normalizedPath}`);
 336:   },
 337:   // Clear cache for a specific path or all paths
 338:   clear: function(path = null) {
 339:     if (path) {
 340:       const normalizedPath = normalizePath(path);
 341:       delete this.cache[normalizedPath];
 342:       console.log(`Cleared cache for ${normalizedPath}`);
 343:     } else {
 344:       this.clearAll();
 345:     }
 346:   },
 347:   // Clear all cached entries
 348:   clearAll: function() {
 349:     this.cache = {};
 350:     console.log('Cleared all directory caches');
 351:   }
 352: };
 353: /**
 354:  * Normalize file paths to use forward slashes regardless of OS
 355:  * This ensures consistent path formatting between main and renderer processes
 356:  */
 357: function normalizePath(filePath) {
 358:   if (!filePath) return filePath;
 359:   return filePath.replace(/\\/g, '/');
 360: }
 361: /**
 362:  * Get the platform-specific path separator
 363:  */
 364: function getPathSeparator() {
 365:   return os.platform() === 'win32' ? '\\' : '/';
 366: }
 367: // Initialize tokenizer with better error handling
 368: let tiktoken;
 369: try {
 370:   tiktoken = tryLoadModule("tiktoken");
 371:   console.log("Successfully loaded tiktoken module");
 372: } catch (err) {
 373:   console.error("Failed to load tiktoken module:", err);
 374:   tiktoken = null;
 375: }
 376: // Initialize the encoder once at startup with better error handling
 377: let encoder;
 378: try {
 379:   if (tiktoken) {
 380:     encoder = tiktoken.get_encoding("o200k_base"); // gpt-4o encoding
 381:     console.log("Tiktoken encoder initialized successfully");
 382:   } else {
 383:     throw new Error("Tiktoken module not available");
 384:   }
 385: } catch (err) {
 386:   console.error("Failed to initialize tiktoken encoder:", err);
 387:   // Fallback to a simpler method if tiktoken fails
 388:   console.log("Using fallback token counter");
 389:   encoder = null;
 390: }
 391: // Binary file extensions that should be excluded from token counting
 392: const BINARY_EXTENSIONS = [
 393:   // Images
 394:   ".jpg",
 395:   ".jpeg",
 396:   ".png",
 397:   ".gif",
 398:   ".bmp",
 399:   ".tiff",
 400:   ".ico",
 401:   ".webp",
 402:   ".svg",
 403:   // Audio/Video
 404:   ".mp3",
 405:   ".mp4",
 406:   ".wav",
 407:   ".ogg",
 408:   ".avi",
 409:   ".mov",
 410:   ".mkv",
 411:   ".flac",
 412:   // Archives
 413:   ".zip",
 414:   ".rar",
 415:   ".tar",
 416:   ".gz",
 417:   ".7z",
 418:   // Documents
 419:   ".pdf",
 420:   ".doc",
 421:   ".docx",
 422:   ".ppt",
 423:   ".pptx",
 424:   ".xls",
 425:   ".xlsx",
 426:   // Compiled
 427:   ".exe",
 428:   ".dll",
 429:   ".so",
 430:   ".class",
 431:   ".o",
 432:   ".pyc",
 433:   // Database
 434:   ".db",
 435:   ".sqlite",
 436:   ".sqlite3",
 437:   // Others
 438:   ".bin",
 439:   ".dat",
 440: ].concat(binaryExtensions || []); // Add any additional binary extensions from excluded-files.js
 441: // Max file size to read (5MB)
 442: const MAX_FILE_SIZE = 200 * 1024 * 1024;
 443: // Global reference to the mainWindow to prevent garbage collection
 444: let mainWindow;
 445: // Add promisify for fs operations
 446: const readFile = promisify(fs.readFile);
 447: const writeFile = promisify(fs.writeFile);
 448: const unlink = promisify(fs.unlink);
 449: // Create a clear pattern organization system with three distinct categories:
 450: // 1. SYSTEM_EXCLUSIONS: Always excluded, not user-configurable (binary files, media, etc.)
 451: // 2. DEFAULT_USER_PATTERNS: Initial user-editable patterns, restored on reset
 452: // 3. Current user patterns: Stored in global_patterns.ignore or .repo_ignore files
 453: // Category 1: System-level exclusions (not user-editable)
 454: const SYSTEM_EXCLUSIONS = [
 455:   // Version control
 456:   "**/.git/**",
 457:   "**/.svn/**",
 458:   "**/.hg/**",
 459:   // Build artifacts and dependencies
 460:   "**/node_modules/**", 
 461:   "**/dist/**",
 462:   "**/build/**",
 463:   "**/.next/**",
 464:   // Cache files
 465:   "**/.cache/**",
 466:   "**/__pycache__/**",
 467:   // Logs
 468:   "**/logs/**",
 469:   "**/*.log",
 470:   // IDE files
 471:   "**/.idea/**",
 472:   "**/.vscode/**",
 473:   // OS files
 474:   "**/.DS_Store",
 475:   "**/Thumbs.db"
 476: ];
 477: // Category 2: Default user patterns (user-editable, used when resetting to defaults)
 478: const DEFAULT_USER_PATTERNS = ""; // Start with empty patterns
 479: // Add diagnostic function for path resolution
 480: function logPathDiagnostics() {
 481:   console.log('======== PATH DIAGNOSTICS ========');
 482:   console.log('__dirname:', __dirname);
 483:   console.log('process.cwd():', process.cwd());
 484:   console.log('app.getAppPath():', app.getAppPath());
 485:   console.log('app.getPath(userData):', app.getPath('userData'));
 486:   console.log('app.getPath(exe):', app.getPath('exe'));
 487:   console.log('process.resourcesPath:', process.resourcesPath);
 488:   // Check for dist directory
 489:   const possibleDistPaths = [
 490:     path.resolve(__dirname, '../dist'),
 491:     path.join(process.resourcesPath, 'app.asar/dist'),
 492:     path.join(app.getAppPath(), 'dist')
 493:   ];
 494:   console.log('Checking dist directory existence:');
 495:   for (const distPath of possibleDistPaths) {
 496:     try {
 497:       const exists = fs.existsSync(distPath);
 498:       console.log(`- ${distPath}: ${exists ? 'EXISTS' : 'NOT FOUND'}`);
 499:       if (exists) {
 500:         // Check for index.html
 501:         const indexPath = path.join(distPath, 'index.html');
 502:         const indexExists = fs.existsSync(indexPath);
 503:         console.log(`  - index.html: ${indexExists ? 'EXISTS' : 'NOT FOUND'}`);
 504:       }
 505:     } catch (err) {
 506:       console.error(`- ${distPath}: ERROR - ${err.message}`);
 507:     }
 508:   }
 509:   console.log('==================================');
 510: }
 511: function createWindow() {
 512:   mainWindow = new BrowserWindow({
 513:     width: 1000,
 514:     height: 700,
 515:     title: "ContextCraft",
 516:     webPreferences: {
 517:       nodeIntegration: false,      contextIsolation: true,
 518:       preload: path.join(__dirname, "preload.js"),
 519:     },
 520:   });
 521:   console.log('Main window created.');
 522:   // Log diagnostic info during startup
 523:   logPathDiagnostics();
 524:   // Set Content Security Policy
 525:   mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
 526:     callback({
 527:       responseHeaders: {
 528:         ...details.responseHeaders,
 529:         'Content-Security-Policy': [
 530:           "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data:; connect-src 'self' https://openrouter.ai"
 531:         ]
 532:       }
 533:     });
 534:   });
 535:   // Load the app - fix path for production builds
 536:   let startUrl;
 537:   if (process.env.ELECTRON_START_URL) {
 538:     // Development mode
 539:     startUrl = process.env.ELECTRON_START_URL;
 540:   } else {
 541:     // Production mode
 542:     // Check if we're in an asar package
 543:     const isPackaged = app.isPackaged;
 544:     if (isPackaged) {
 545:       // We're in a packaged app
 546:       // For packaged apps, more reliable to use path.resolve with __dirname
 547:       // This ensures proper asar path resolution
 548:       startUrl = url.format({
 549:         pathname: path.resolve(__dirname, '../dist/index.html'),
 550:         protocol: 'file:',
 551:         slashes: true
 552:       });
 553:       console.log(`Packaged app path resolved to: ${path.resolve(__dirname, '../dist/index.html')}`);
 554:       // Fallback path to try if the app fails to load
 555:       const fallbackPath = path.join(process.resourcesPath, 'app.asar/dist/index.html');
 556:       console.log(`Fallback path if needed: ${fallbackPath}`);
 557:     } else {
 558:       // Not packaged, but still in production mode
 559:       startUrl = url.format({
 560:         pathname: path.resolve(__dirname, '../dist/index.html'),
 561:         protocol: 'file:',
 562:         slashes: true
 563:       });
 564:     }
 565:   }
 566:   console.log(`Attempting to load URL: ${startUrl}`);
 567:   mainWindow.loadURL(startUrl);
 568:   // Open external links in browser
 569:   mainWindow.webContents.setWindowOpenHandler(({ url }) => {
 570:     shell.openExternal(url);
 571:     return { action: "deny" };
 572:   });
 573:   // Open dev tools in development
 574:   if (process.env.ELECTRON_START_URL) {
 575:     mainWindow.webContents.openDevTools();
 576:   }
 577:   // Add basic error handling for failed loads
 578:   mainWindow.webContents.on(
 579:     "did-fail-load",
 580:     (event, errorCode, errorDescription, validatedURL, isMainFrame) => {
 581:       // Log only for the main frame failures
 582:       if (isMainFrame) {
 583:         console.error(`FAILED TO LOAD URL: ${validatedURL}`);
 584:         console.error(`Error Code: ${errorCode}`);
 585:         console.error(`Description: ${errorDescription}`);
 586:         // Add more context if available
 587:         console.error(`Is Packaged App: ${app.isPackaged}`);
 588:         console.error(`Resources Path: ${process.resourcesPath}`);
 589:         logPathDiagnostics(); // Re-run diagnostics on failure
 590:         // Retry with an explicit file URL if in production
 591:         if (!process.env.ELECTRON_START_URL) {
 592:           // Try multiple fallback paths in order
 593:           const fallbackPaths = [
 594:             // Path 1: Using process.resourcesPath (most reliable in packaged app)
 595:             path.join(process.resourcesPath, 'app.asar/dist/index.html'),
 596:             // Path 2: Using direct path to Applications folder (specific to macOS)
 597:             app.isPackaged && process.platform === 'darwin' 
 598:               ? '/Applications/ContextCraft.app/Contents/Resources/app.asar/dist/index.html' 
 599:               : null,
 600:             // Path 3: Using app.getAppPath() 
 601:             path.join(app.getAppPath(), 'dist/index.html'),
 602:             // Path 4: Original fallback as last resort
 603:             app.isPackaged 
 604:               ? path.join(process.resourcesPath, 'app.asar/dist/index.html') 
 605:               : path.resolve(__dirname, '../dist/index.html'),
 606:           ].filter(Boolean); // Remove any null entries
 607:           // Try each fallback path
 608:           let fallbackIndex = 0;
 609:           const tryNextFallback = () => {
 610:             if (fallbackIndex >= fallbackPaths.length) {
 611:               console.error('All fallback paths failed to load. Cannot recover.');
 612:               return;
 613:             }
 614:             const currentPath = fallbackPaths[fallbackIndex++];
 615:             console.log(`Trying fallback path ${fallbackIndex}/${fallbackPaths.length}: ${currentPath}`);
 616:             const fallbackUrl = url.format({
 617:               pathname: currentPath,
 618:               protocol: 'file:',
 619:               slashes: true
 620:             });
 621:             // Set up one-time handler for next failure
 622:             if (fallbackIndex < fallbackPaths.length) {
 623:               mainWindow.webContents.once('did-fail-load', () => {
 624:                 tryNextFallback();
 625:               });
 626:             }
 627:             mainWindow.loadURL(fallbackUrl);
 628:           };
 629:           tryNextFallback();
 630:         }
 631:       } else {
 632:         console.warn(`Failed to load non-main frame: ${validatedURL} (${errorCode})`);
 633:       }
 634:     },
 635:   );
 636:   // Handle window ready-to-show event
 637:   mainWindow.once('ready-to-show', () => {
 638:     mainWindow.show();
 639:   });
 640:   // Handle window closed event
 641:   mainWindow.on('closed', () => {
 642:     mainWindow = null;
 643:   });
 644: }
 645: app.whenReady().then(() => {
 646:   console.log('App ready. Verifying critical modules...');
 647:   try {
 648:     // Try to load critical modules using our resilient method
 649:     tryLoadModule('tree-sitter');
 650:     tryLoadModule('chokidar');
 651:     console.log('Critical native modules loaded successfully.');
 652:     createWindow();
 653:   } catch (moduleError) {
 654:     console.error('FATAL: Failed to load critical module:', moduleError);
 655:     // Show error dialog but continue anyway - don't exit
 656:     // This allows the app to at least try to start even if a module is missing
 657:     dialog.showErrorBox('Module Loading Warning', 
 658:       `Some required modules could not be loaded. Some features may not work correctly.\nError: ${moduleError.message}`);
 659:     // Continue with app startup despite the error
 660:     createWindow();
 661:   }
 662:   app.on("activate", () => {
 663:     if (BrowserWindow.getAllWindows().length === 0) createWindow();
 664:   });
 665: });
 666: app.on("window-all-closed", () => {
 667:   if (process.platform !== "darwin") {
 668:     app.quit();
 669:   }
 670: });
 671: // Clean up shortcuts on app quit
 672: app.on('will-quit', () => {
 673:   globalShortcut.unregisterAll();
 674: });
 675: // Helper function to check if window is valid and can receive messages
 676: function isWindowValid(window) {
 677:   try {
 678:     return window && !window.isDestroyed() && window.webContents;
 679:   } catch (error) {
 680:     console.error('Error checking window validity:', error);
 681:     return false;
 682:   }
 683: }
 684: // Function to safely send to renderer
 685: function safeRendererSend(window, channel, ...args) {
 686:   try {
 687:     if (!isWindowValid(window)) {
 688:       console.warn(`Cannot send to renderer (${channel}): window is not valid`);
 689:       return false;
 690:     }
 691:     window.webContents.send(channel, ...args);
 692:     return true;
 693:   } catch (error) {
 694:     console.error(`Error sending to renderer (${channel}):`, error);
 695:     return false;
 696:   }
 697: }
 698: // Function to get all patterns (system + user)
 699: function getAllPatterns(userPatterns) {
 700:   // Combine system exclusions with user patterns
 701:   // System exclusions always apply and come first
 702:   return [...SYSTEM_EXCLUSIONS, ...(userPatterns || [])];
 703: }
 704: // Parse patterns to extract disabled system patterns
 705: const parsePatterns = (content) => {
 706:   const lines = content.split('\n');
 707:   const excludedPatterns = [];
 708:   const userPatterns = [];
 709:   lines.forEach(line => {
 710:     const trimmed = line.trim();
 711:     if (trimmed.startsWith('# DISABLED:')) {
 712:       excludedPatterns.push(trimmed.substring('# DISABLED:'.length).trim());
 713:     } else if (trimmed !== '' && !trimmed.startsWith('#')) {
 714:       userPatterns.push(line);
 715:     }
 716:   });
 717:   return {
 718:     excludedPatterns,
 719:     userPatterns: userPatterns.join('\n')
 720:   };
 721: };
 722: // Update IPC handlers with improved error handling
 723: ipcMain.handle("open-folder", async () => {
 724:   try {
 725:     const result = await dialog.showOpenDialog({ properties: ["openDirectory"] });
 726:     if (!result.canceled && result.filePaths.length > 0) {
 727:       return result.filePaths[0];
 728:     }
 729:     return null; // Return null if canceled or no path selected
 730:   } catch (error) {
 731:     console.error("Error opening folder dialog:", error);
 732:     return null; // Return null or throw error as appropriate
 733:   }
 734: });
 735: ipcMain.handle("read-file", async (event, filePath) => {
 736:   try {
 737:     if (!filePath || typeof filePath !== 'string') {
 738:       throw new Error("Invalid file path provided.");
 739:     }
 740:     // Security check: Ensure filePath is within a reasonable scope if necessary
 741:     // e.g., check if it's within the selected project directory
 742:     // (Need access to the root directory state for this check)
 743:     // Add file size limit check
 744:     const stats = await fs.promises.stat(filePath);
 745:     if (stats.size > MAX_FILE_SIZE) {
 746:        console.warn(`Skipping large file (>${MAX_FILE_SIZE / 1024 / 1024}MB): ${filePath}`);
 747:       return null; // Or return an indicator that the file is too large
 748:     }
 749:     const content = await readFile(filePath, "utf-8");
 750:     return content;
 751:   } catch (error) {
 752:     console.error(`Error reading file ${filePath}:`, error);
 753:     // Send error back to renderer or return null
 754:     return null; // Or throw an error that the renderer can catch
 755:   }
 756: });
 757: // Add handler for the get-file-content IPC channel
 758: ipcMain.handle("get-file-content", async (event, filePath) => {
 759:   try {
 760:     if (!filePath || typeof filePath !== 'string') {
 761:       throw new Error("Invalid file path provided for get-file-content.");
 762:     }
 763:     console.log(`Getting content for file: ${filePath}`);
 764:     // Check if file exists
 765:     if (!fs.existsSync(filePath)) {
 766:       console.error(`File does not exist: ${filePath}`);
 767:       return { 
 768:         success: false, 
 769:         error: `File does not exist: ${filePath}` 
 770:       };
 771:     }
 772:     // Get file stats
 773:     const stats = await fs.promises.stat(filePath);
 774:     // Check if file is too large
 775:     if (stats.size > MAX_FILE_SIZE) {
 776:       console.warn(`Skipping large file (>${MAX_FILE_SIZE / 1024 / 1024}MB): ${filePath}`);
 777:       return { 
 778:         success: false, 
 779:         error: `File is too large (>${MAX_FILE_SIZE / 1024 / 1024}MB)`, 
 780:         size: stats.size 
 781:       };
 782:     }
 783:     // Read file content
 784:     try {
 785:       const content = await readFile(filePath, "utf-8");
 786:       const lastModified = stats.mtime.getTime();
 787:       return {
 788:         success: true,
 789:         content,
 790:         size: stats.size,
 791:         lastModified
 792:       };
 793:     } catch (e) {
 794:       // Try to identify encoding-related errors
 795:       if (e.message && e.message.includes('invalid or unsupported encoding')) {
 796:         console.error(`Encoding error reading file ${filePath}:`, e);
 797:         return { 
 798:           success: false, 
 799:           error: `File encoding not supported (not UTF-8): ${e.message}` 
 800:         };
 801:       }
 802:       // Other read errors
 803:       console.error(`Error reading file ${filePath}:`, e);
 804:       return { 
 805:         success: false, 
 806:         error: e.message || "Unknown error reading file" 
 807:       };
 808:     }
 809:   } catch (error) {
 810:     console.error(`Error in get-file-content for ${filePath}:`, error);
 811:     return { 
 812:       success: false, 
 813:       error: error.message || "Unknown error reading file" 
 814:     };
 815:   }
 816: });
 817: ipcMain.on("request-file-list", (event, folderPath) => {
 818:   try {
 819:     if (!isWindowValid(mainWindow)) {
 820:       console.warn("Window is not valid for request-file-list");
 821:       return;
 822:     }
 823:     console.log("Received request-file-list event for:", folderPath);
 824:     // Call the handleRequestFileList directly with the event object
 825:     handleRequestFileList(event, folderPath);
 826:   } catch (error) {
 827:     console.error("Error in request-file-list handler:", error);
 828:     if (isWindowValid(mainWindow)) {
 829:       mainWindow.webContents.send("file-processing-status", {
 830:         status: "error",
 831:         message: `Error loading directory: ${error.message}`,
 832:       });
 833:     }
 834:   }
 835: });
 836: // Keep the handle method for backward compatibility but log a warning
 837: ipcMain.handle("request-file-list", async (event, data) => {
 838:   console.warn("Using deprecated ipcMain.handle for request-file-list. This should use the 'on' method instead.");
 839:   // The handler should just acknowledge but actual processing happens through events
 840:   return { acknowledged: true };
 841: });
 842: ipcMain.handle('compress-code', async (event, { source, language }) => {
 843:   try {
 844:     if (!source || !language) {
 845:       throw new Error("Source code and language are required for compression.");
 846:     }
 847:     // Input validation/sanitization if necessary
 848:     const compressed = await mainProcessCompressCode(String(source), String(language));
 849:     return compressed;
 850:   } catch (error) {
 851:     console.error("Error in compress-code IPC handler:", error);
 852:     return null; // Return null on error
 853:   }
 854: });
 855: ipcMain.handle('remove-comments', async (event, { source, language, keepDocstrings }) => {
 856:   try {
 857:     if (!source || !language) {
 858:       throw new Error("Source code and language are required for comment removal.");
 859:     }
 860:     // Input validation/sanitization if necessary
 861:     const uncommented = await mainProcessRemoveComments(String(source), String(language), Boolean(keepDocstrings));
 862:     return uncommented;
 863:   } catch (error) {
 864:     console.error("Error in remove-comments IPC handler:", error);
 865:     return null; // Return null on error
 866:   }
 867: });
 868: ipcMain.on("reload-file-list", (event, folderPath) => {
 869:   try {
 870:     if (!isWindowValid(mainWindow)) {
 871:       console.warn("Window is not valid for reload-file-list");
 872:       return;
 873:     }
 874:     if (!folderPath) return;
 875:     console.log(`Forcing reload of file list for ${folderPath}`);
 876:     directoryCache.clear(folderPath);
 877:     mainWindow.webContents.send("file-processing-status", {
 878:       status: "processing",
 879:       message: "Reloading directory...",
 880:     });
 881:     // Process the request directly using the same handler for request-file-list
 882:     try {
 883:       // Create data object with force refresh flag
 884:       const data = {
 885:         path: folderPath,
 886:         forceRefresh: true
 887:       };
 888:       // Handle the request-file-list directly
 889:       handleRequestFileList(event, data);
 890:     } catch (err) {
 891:       console.error("Error reloading file list:", err);
 892:       if (isWindowValid(mainWindow)) {
 893:         mainWindow.webContents.send("file-processing-status", {
 894:           status: "error",
 895:           message: `Error reloading directory: ${err.message}`,
 896:         });
 897:       }
 898:     }
 899:   } catch (error) {
 900:     console.error("Error in reload-file-list handler:", error);
 901:   }
 902: });
 903: // Function to cancel loading directory with improved error handling
 904: function cancelDirectoryLoading(window) {
 905:   try {
 906:     if (!isWindowValid(window)) {
 907:       console.warn("Window is not valid for cancelDirectoryLoading");
 908:       return;
 909:     }
 910:     isLoadingDirectory = false;
 911:     if (loadingTimeoutId) {
 912:       clearTimeout(loadingTimeoutId);
 913:       loadingTimeoutId = null;
 914:     }
 915:     safeRendererSend(window, "file-processing-status", {
 916:       status: "error",
 917:       message: "Directory loading cancelled - try selecting a smaller directory",
 918:     });
 919:   } catch (error) {
 920:     console.error("Error in cancelDirectoryLoading:", error);
 921:     // Try to reset state even if sending to renderer failed
 922:     isLoadingDirectory = false;
 923:     loadingTimeoutId = null;
 924:   }
 925: }
 926: // Handler for directory loading timeout with improved error handling
 927: function setupDirectoryLoadingTimeout(window, folderPath) {
 928:   try {
 929:     if (!isWindowValid(window)) {
 930:       console.warn("Window is not valid for setupDirectoryLoadingTimeout");
 931:       return;
 932:     }
 933:     // Clear any existing timeout
 934:     if (loadingTimeoutId) {
 935:       clearTimeout(loadingTimeoutId);
 936:     }
 937:     // Set a new timeout
 938:     loadingTimeoutId = setTimeout(() => {
 939:       try {
 940:         console.log(`Directory loading timed out after ${MAX_DIRECTORY_LOAD_TIME / 1000} seconds: ${folderPath}`);
 941:         if (isWindowValid(window)) {
 942:           cancelDirectoryLoading(window);
 943:         } else {
 944:           // Just clean up the loading state without window reference
 945:           isLoadingDirectory = false;
 946:           loadingTimeoutId = null;
 947:           console.log("Directory loading timed out but window is no longer available");
 948:         }
 949:       } catch (error) {
 950:         console.error("Error in directory loading timeout handler:", error);
 951:         // Ensure we clean up state even if there's an error
 952:         isLoadingDirectory = false;
 953:         loadingTimeoutId = null;
 954:       }
 955:     }, MAX_DIRECTORY_LOAD_TIME);
 956:   } catch (error) {
 957:     console.error("Error setting up directory loading timeout:", error);
 958:     // Clean up state on error
 959:     isLoadingDirectory = false;
 960:     if (loadingTimeoutId) {
 961:       clearTimeout(loadingTimeoutId);
 962:       loadingTimeoutId = null;
 963:     }
 964:   }
 965: }
 966: ipcMain.on("cancel-directory-loading", (event) => {
 967:   try {
 968:     if (!isWindowValid(mainWindow)) {
 969:       console.warn("Window is not valid for cancel-directory-loading");
 970:       return;
 971:     }
 972:     if (isLoadingDirectory) {
 973:       console.log("Received cancel directory loading request");
 974:       cancelDirectoryLoading(mainWindow);
 975:     }
 976:   } catch (error) {
 977:     console.error("Error in cancel-directory-loading handler:", error);
 978:   }
 979: });
 980: // Update async handlers with improved error handling and window checks
 981: ipcMain.handle('load-ignore-patterns', async (event, { folderPath, isGlobal }) => {
 982:   try {
 983:     if (!isWindowValid(mainWindow)) {
 984:       console.warn("Window not initialized yet or destroyed");
 985:       return { 
 986:         success: true, 
 987:         patterns: isGlobal ? DEFAULT_USER_PATTERNS : '',
 988:         systemPatterns: SYSTEM_EXCLUSIONS,
 989:         excludedPatterns: []
 990:       };
 991:     }
 992:     if (isGlobal) {
 993:       try {
 994:         const appDataPath = app.getPath('userData');
 995:         const globalIgnorePath = path.join(appDataPath, 'global_patterns.ignore');
 996:         if (fs.existsSync(globalIgnorePath)) {
 997:           const content = await readFile(globalIgnorePath, 'utf8');
 998:           const { excludedPatterns, userPatterns } = parsePatterns(content);
 999:           console.log(`Loaded global ignore patterns from ${globalIgnorePath}`);
1000:           return { 
1001:             success: true, 
1002:             patterns: userPatterns,
1003:             systemPatterns: SYSTEM_EXCLUSIONS,
1004:             excludedPatterns
1005:           };
1006:         } else {
1007:           console.log('No global ignore patterns file found, creating with defaults');
1008:           try {
1009:             if (!fs.existsSync(appDataPath)) {
1010:               fs.mkdirSync(appDataPath, { recursive: true });
1011:             }
1012:             await writeFile(globalIgnorePath, DEFAULT_USER_PATTERNS, 'utf8');
1013:             console.log(`Created default global ignore patterns at ${globalIgnorePath}`);
1014:           } catch (error) {
1015:             console.error('Error creating default global patterns:', error);
1016:           }
1017:           return { 
1018:             success: true, 
1019:             patterns: DEFAULT_USER_PATTERNS,
1020:             systemPatterns: SYSTEM_EXCLUSIONS,
1021:             excludedPatterns: []
1022:           };
1023:         }
1024:       } catch (error) {
1025:         console.error('Error handling global patterns:', error);
1026:         return { 
1027:           success: true, 
1028:           patterns: DEFAULT_USER_PATTERNS,
1029:           systemPatterns: SYSTEM_EXCLUSIONS,
1030:           excludedPatterns: []
1031:         };
1032:       }
1033:     } else {
1034:       try {
1035:         if (!folderPath) {
1036:           return { 
1037:             success: true, 
1038:             patterns: '',
1039:             systemPatterns: SYSTEM_EXCLUSIONS,
1040:             excludedPatterns: []
1041:           };
1042:         }
1043:         const ignoreFilePath = path.join(folderPath, '.repo_ignore');
1044:         if (fs.existsSync(ignoreFilePath)) {
1045:           const content = await readFile(ignoreFilePath, 'utf8');
1046:           const { excludedPatterns, userPatterns } = parsePatterns(content);
1047:           console.log(`Loaded local ignore patterns from ${ignoreFilePath}`);
1048:           return { 
1049:             success: true, 
1050:             patterns: userPatterns,
1051:             systemPatterns: SYSTEM_EXCLUSIONS,
1052:             excludedPatterns
1053:           };
1054:         } else {
1055:           console.log(`No local ignore patterns file found at ${ignoreFilePath}`);
1056:           return { 
1057:             success: true, 
1058:             patterns: '',
1059:             systemPatterns: SYSTEM_EXCLUSIONS,
1060:             excludedPatterns: []
1061:           };
1062:         }
1063:       } catch (error) {
1064:         console.error('Error handling local patterns:', error);
1065:         return { 
1066:           success: true, 
1067:           patterns: '',
1068:           systemPatterns: SYSTEM_EXCLUSIONS,
1069:           excludedPatterns: []
1070:         };
1071:       }
1072:     }
1073:   } catch (error) {
1074:     console.error('Error in load-ignore-patterns handler:', error);
1075:     return { 
1076:       success: true, 
1077:       patterns: isGlobal ? DEFAULT_USER_PATTERNS : '',
1078:       systemPatterns: SYSTEM_EXCLUSIONS,
1079:       excludedPatterns: []
1080:     };
1081:   }
1082: });
1083: // Function to parse .gitignore file if it exists
1084: function loadGitignore(rootDir) {
1085:   const ig = ignore();
1086:   const gitignorePath = path.join(rootDir, ".gitignore");
1087:   if (fs.existsSync(gitignorePath)) {
1088:     const gitignoreContent = fs.readFileSync(gitignorePath, "utf8");
1089:     ig.add(gitignoreContent);
1090:   }
1091:   // Add some default ignores that are common
1092:   ig.add([".git", "node_modules", ".DS_Store"]);
1093:   // Add the excludedFiles patterns for gitignore-based exclusion
1094:   ig.add(excludedFiles);
1095:   return ig;
1096: }
1097: // Check if file is binary based on extension
1098: function isBinaryFile(filePath) {
1099:   const ext = path.extname(filePath).toLowerCase();
1100:   return BINARY_EXTENSIONS.includes(ext);
1101: }
1102: // Count tokens using tiktoken with o200k_base encoding
1103: function countTokens(text) {
1104:   if (!text) return 0;
1105:   // Very large files (over 100K) - use approximate counting only
1106:   if (text.length > 100000) {
1107:     console.log(`Using approximate token count for large file (${text.length} chars)`);
1108:     // Rough approximation: ~4 characters per token on average
1109:     return Math.ceil(text.length / 4);
1110:   }
1111:   // Normal files - use tiktoken if available
1112:   if (encoder) {
1113:     try {
1114:       const tokens = encoder.encode(text);
1115:       return tokens.length;
1116:     } catch (err) {
1117:       console.error("Error counting tokens:", err);
1118:       // Fallback to character-based estimation on error
1119:       return Math.ceil(text.length / 4);
1120:     }
1121:   } else {
1122:     // Fallback for when tiktoken is not available
1123:     return Math.ceil(text.length / 4);
1124:   }
1125: }
1126: // Function to recursively read files from a directory
1127: function readFilesRecursively(dir, rootDir, ignoreFilter) {
1128:   rootDir = rootDir || dir;
1129:   ignoreFilter = ignoreFilter || loadGitignore(rootDir);
1130:   // Normalize paths for consistent comparisons
1131:   dir = normalizePath(dir);
1132:   rootDir = normalizePath(rootDir);
1133:   console.log(`Reading directory: ${dir}`);
1134:   let results = [];
1135:   // Skip directories that are obviously going to be very large or problematic
1136:   const dirName = path.basename(dir);
1137:   const skipDirectories = [
1138:     'node_modules', '.git', 'dist', 'build', 'target',
1139:     'bin', 'obj', 'venv', 'env', '.venv', '.env',
1140:     '.next', '.idea', '.gradle', '.cache', 'coverage'
1141:   ];
1142:   if (skipDirectories.includes(dirName)) {
1143:     console.log(`Skipping known large directory: ${dir}`);
1144:     return results;
1145:   }
1146:   // Get actual app paths for comparison
1147:   const appDirectoryPath = normalizePath(app.getAppPath());
1148:   const resourcesPath = path.dirname(appDirectoryPath);
1149:   // Skip ONLY if it's the exact running app directory or its Resources parent
1150:   const isRunningAppDirectory = 
1151:       dir === appDirectoryPath || 
1152:       dir === resourcesPath || 
1153:       dir === normalizePath(path.resolve(__dirname));
1154:   if (isRunningAppDirectory) {
1155:     console.log(`Skipping running application directory: ${dir}`);
1156:     return [{
1157:       name: "_APP_DIRECTORY_",
1158:       path: dir,
1159:       relativePath: "", // Add empty relativePath for app directory
1160:       content: "Please select a project directory instead of the ContextCraft application directory.",
1161:       tokenCount: 0,
1162:       size: 0,
1163:       isBinary: false,
1164:       isSkipped: true,
1165:       error: "This is the running ContextCraft application directory. Please select a different project directory.",
1166:       isAppDirectory: true
1167:     }];
1168:   }
1169:   try {
1170:     // Try to read the directory
1171:     let dirents;
1172:     try {
1173:       dirents = fs.readdirSync(dir, { withFileTypes: true });
1174:     } catch (err) {
1175:       console.error(`Error reading directory ${dir}:`, err);
1176:       return results;
1177:     }
1178:     // Quick check if there are too many files in this directory (likely not useful)
1179:     if (dirents.length > 10000) {
1180:       console.log(`Skipping directory with too many files (${dirents.length}): ${dir}`);
1181:       return results;
1182:     }
1183:     // Process directories first, then files
1184:     const directories = [];
1185:     const files = [];
1186:     // First pass: quick filtering
1187:     for (const dirent of dirents) {
1188:       const name = dirent.name;
1189:       // Skip hidden files and directories (starting with .)
1190:       if (name.startsWith('.') && name !== '.gitignore') {
1191:         continue;
1192:       }
1193:       const fullPath = path.join(dir, name);
1194:       const normalizedPath = normalizePath(fullPath);
1195:       const relativePath = path.relative(rootDir, normalizedPath);
1196:       // Skip if the path is ignored
1197:       if (ignoreFilter.ignores(relativePath)) {
1198:         continue;
1199:       }
1200:       if (dirent.isDirectory()) {
1201:         // Skip .app directories (macOS application bundles)
1202:         if (name.endsWith('.app')) {
1203:           continue;
1204:         }
1205:         // Skip the application's own directory if we're somehow inside it
1206:         const appDirectoryPath = normalizePath(app.getAppPath());
1207:         const resourcesPath = path.dirname(appDirectoryPath);
1208:         // Compare with exact app path instead of just checking if it starts with app path
1209:         if (normalizedPath === appDirectoryPath || normalizedPath === resourcesPath) {
1210:           console.log(`Skipping running app directory: ${normalizedPath}`);
1211:           continue;
1212:         }
1213:         directories.push(dirent);
1214:       } else if (dirent.isFile()) {
1215:         // Skip file if it's a binary file or too large (quick check by extension)
1216:         const ext = path.extname(name).toLowerCase();
1217:         if (BINARY_EXTENSIONS.includes(ext)) {
1218:           // Add it to results but mark as binary
1219:           results.push({
1220:             name: name,
1221:             path: normalizedPath,
1222:             relativePath: normalizePath(path.relative(rootDir, normalizedPath)), // Add relative path property
1223:             tokenCount: 0,
1224:             size: 0,
1225:             content: "",
1226:             isBinary: true,
1227:             isSkipped: false,
1228:             fileType: ext.substring(1).toUpperCase(),
1229:           });
1230:         } else {
1231:           files.push(dirent);
1232:         }
1233:       }
1234:     }
1235:     // Process directories recursively but limit depth and count
1236:     let dirCount = 0;
1237:     for (const dirent of directories) {
1238:       if (dirCount++ > 100) {
1239:         console.log(`Limiting directory processing to 100 subdirectories in ${dir}`);
1240:         break;
1241:       }
1242:       const fullPath = path.join(dir, dirent.name);
1243:       const normalizedPath = normalizePath(fullPath);
1244:       // Recursively read subdirectory
1245:       const subResults = readFilesRecursively(normalizedPath, rootDir, ignoreFilter);
1246:       results = results.concat(subResults);
1247:     }
1248:     // Process files but limit to a reasonable number
1249:     let fileCount = 0;
1250:     for (const dirent of files) {
1251:       if (fileCount++ > 1000) {
1252:         console.log(`Limiting file processing to 1000 files in ${dir}`);
1253:         break;
1254:       }
1255:       const fullPath = path.join(dir, dirent.name);
1256:       const normalizedPath = normalizePath(fullPath);
1257:       try {
1258:         // Get file stats for size
1259:         const stats = fs.statSync(normalizedPath);
1260:         const fileSize = stats.size;
1261:         // Skip files that are too large
1262:         if (fileSize > MAX_FILE_SIZE) {
1263:           results.push({
1264:             name: dirent.name,
1265:             path: normalizedPath,
1266:             relativePath: normalizePath(path.relative(rootDir, normalizedPath)), // Add relative path property
1267:             tokenCount: 0,
1268:             size: fileSize,
1269:             content: "",
1270:             isBinary: true,
1271:             isSkipped: true,
1272:             error: "File too large to process",
1273:           });
1274:           continue;
1275:         }
1276:         // Check if the file is binary
1277:         const isBinary = isBinaryFile(normalizedPath);
1278:         // *** Add Enhanced Logging Here ***
1279:         const relativePathForLog = normalizePath(path.relative(rootDir, normalizedPath));
1280:         if (!relativePathForLog) { // Log specifically when relativePath is missing/empty
1281:             console.error(`[CRITICAL main.js] Missing relativePath! rootDir='${rootDir}', normalizedPath='${normalizedPath}', calculatedRelative='${path.relative(rootDir, normalizedPath)}'`);
1282:         } else if (debugCounter < MAX_DEBUG_FILES) { // Limit successful logs
1283:             console.log(`[Debug main.js] Adding file: Name=${dirent.name}, Path=${normalizedPath}, RelativePath=${relativePathForLog}`);
1284:             debugCounter++;
1285:         }
1286:         // *** End Enhanced Logging ***
1287:         if (isBinary) {
1288:           // Skip token counting for binary files
1289:           results.push({
1290:             name: dirent.name,
1291:             path: normalizedPath,
1292:             relativePath: normalizePath(path.relative(rootDir, normalizedPath)), // Add relative path property
1293:             tokenCount: 0,
1294:             size: fileSize,
1295:             content: "",
1296:             isBinary: true,
1297:             isSkipped: false,
1298:             fileType: path.extname(normalizedPath).substring(1).toUpperCase(),
1299:           });
1300:         } else {
1301:           // Read file content
1302:           const fileContent = fs.readFileSync(normalizedPath, "utf8");
1303:           // Calculate token count (this is the initial, uncompressed count)
1304:           const initialTokenCount = countTokens(fileContent);
1305:           // Add file info with content and token count
1306:           results.push({
1307:             name: dirent.name,
1308:             path: normalizedPath,
1309:             relativePath: normalizePath(path.relative(rootDir, normalizedPath)), // Add relative path property
1310:             content: fileContent, // Note: Consider not sending full content initially if memory is a concern
1311:             tokenCount: initialTokenCount, // Initialize current count with uncompressed count
1312:             uncompressedTokenCount: initialTokenCount, // Store the original count
1313:             isCompressed: false, // Initially not compressed
1314:             size: fileSize,
1315:             isBinary: false,
1316:             isSkipped: false,
1317:           });
1318:         }
1319:       } catch (err) {
1320:         console.error(`Error reading file ${normalizedPath}:`, err);
1321:         // *** Add Enhanced Logging Here Too for Errors ***
1322:         const relativePathForErrLog = normalizePath(path.relative(rootDir, normalizedPath));
1323:         if (!relativePathForErrLog) {
1324:             console.error(`[CRITICAL main.js ERROR CASE] Missing relativePath! rootDir='${rootDir}', normalizedPath='${normalizedPath}', calculatedRelative='${path.relative(rootDir, normalizedPath)}'`);
1325:         }
1326:         // *** End Enhanced Logging ***
1327:         results.push({
1328:           name: dirent.name,
1329:           path: normalizedPath,
1330:           relativePath: normalizePath(path.relative(rootDir, normalizedPath)), // Add relative path property
1331:           tokenCount: 0,
1332:           size: 0,
1333:           isBinary: false,
1334:           isSkipped: true,
1335:           error: "Could not read file",
1336:         });
1337:       }
1338:     }
1339:   } catch (err) {
1340:     console.error(`Error processing directory ${dir}:`, err);
1341:   }
1342:   return results;
1343: }
1344: // Extract file list processing into a reusable function
1345: function handleRequestFileList(event, data) {
1346:   try {
1347:     // Allow either simple string or object with options
1348:     const folderPath = typeof data === 'string' ? data : data.path;
1349:     if (!folderPath) {
1350:       console.log("No folder path provided");
1351:       event.sender.send("file-processing-status", {
1352:         status: "error",
1353:         message: "No folder selected. Please select a project directory.",
1354:       });
1355:       return;
1356:     }
1357:     const forceRefresh = typeof data === 'object' && data.forceRefresh === true;
1358:     console.log("Processing file list for folder:", folderPath);
1359:     console.log("OS platform:", os.platform());
1360:     console.log("Path separator:", getPathSeparator());
1361:     // Get actual app paths for comparison
1362:     const normalizedFolderPath = normalizePath(folderPath);
1363:     const appDirectoryPath = normalizePath(app.getAppPath());
1364:     const resourcesPath = path.dirname(appDirectoryPath);
1365:     // Check ONLY if it's the exact running app directory or its Resources parent
1366:     const isRunningAppDirectory = 
1367:         normalizedFolderPath === appDirectoryPath || 
1368:         normalizedFolderPath === resourcesPath || 
1369:         normalizedFolderPath === normalizePath(path.resolve(__dirname));
1370:     if (isRunningAppDirectory) {
1371:       console.log(`Preventing recursive scan of running app instance at: ${appDirectoryPath}`);
1372:       console.log(`Selected path: ${normalizedFolderPath}`);
1373:       event.sender.send("file-list-data", [{
1374:         name: "_APP_DIRECTORY_",
1375:         path: normalizedFolderPath,
1376:         relativePath: "", // Add empty relativePath for app directory
1377:         content: "Please select a project directory instead of the ContextCraft application directory.",
1378:         tokenCount: 0,
1379:         size: 0,
1380:         isBinary: false,
1381:         isSkipped: true,
1382:         error: "This is the running ContextCraft application directory. Please select a different project directory.",
1383:         isAppDirectory: true
1384:       }]);
1385:       event.sender.send("file-processing-status", {
1386:         status: "error",
1387:         message: "Please select a project directory instead of the ContextCraft application.",
1388:       });
1389:       return;
1390:     }
1391:     // Check cache first (unless forced refresh)
1392:     if (!forceRefresh) {
1393:       const cachedFiles = directoryCache.get(folderPath);
1394:       if (cachedFiles) {
1395:         console.log(`Using ${cachedFiles.length} cached files for ${folderPath}`);
1396:         // Check cached files for reload functionality too
1397:         if (data.forceRefresh) {
1398:           // If forceRefresh is specified, ensure excluded property is set correctly
1399:           cachedFiles = cachedFiles.map(file => {
1400:             const normalizedPath = normalizePath(file.path);
1401:             const isExcluded = shouldExcludeByDefault(normalizedPath, folderPath);
1402:             return {
1403:               ...file,
1404:               excludedByDefault: isExcluded,
1405:               excluded: isExcluded
1406:             };
1407:           });
1408:         }
1409:         event.sender.send("file-list-data", cachedFiles);
1410:         // Set up file watcher even when using cached files
1411:         setupFileWatcher(folderPath, mainWindow);
1412:         return;
1413:       }
1414:     } else {
1415:       console.log("Force refreshing directory:", folderPath);
1416:       directoryCache.clear(folderPath);
1417:     }
1418:     // Set loading flag
1419:     isLoadingDirectory = true;
1420:     // Set timeout to abort if it takes too long
1421:     if (loadingTimeoutId) {
1422:       clearTimeout(loadingTimeoutId);
1423:     }
1424:     loadingTimeoutId = setTimeout(() => {
1425:       if (isLoadingDirectory) {
1426:         console.log("Loading directory timed out");
1427:         cancelDirectoryLoading(mainWindow);
1428:       }
1429:     }, 120000); // 2 minutes timeout
1430:     // Rest of your original file processing logic
1431:     // ...
1432:     // Start processing files logic goes here (unchanged from the original function)
1433:     const processFiles = () => {
1434:       console.log("Starting file scan in:", folderPath);
1435:       console.log("OS normalized path:", normalizePath(folderPath));
1436:       // Force clear the directory cache for this path to ensure fresh scan
1437:       directoryCache.clear(folderPath);
1438:       // First, get all files in the directory
1439:       const files = readFilesRecursively(folderPath, folderPath);
1440:       console.log(`Found ${files.length} files in ${folderPath}`);
1441:       // Debug log of first few files
1442:       if (files.length > 0) {
1443:         console.log("First few files found:");
1444:         files.slice(0, Math.min(5, files.length)).forEach(f => {
1445:           console.log(`- ${f.name} (${f.path})`);
1446:         });
1447:       } else {
1448:         console.log("WARNING: No files found in directory!");
1449:       }
1450:       // Optimize chunk size based on file count
1451:       const CHUNK_SIZE = files.length < 100 ? 50 : 20; // Larger chunks for small directories
1452:       let currentIndex = 0;
1453:       const processedFiles = [];
1454:       const processNextChunk = () => {
1455:         // Calculate the end index for this chunk
1456:         const endIndex = Math.min(currentIndex + CHUNK_SIZE, files.length);
1457:         // Get the chunk of files to process
1458:         const currentChunk = files.slice(currentIndex, endIndex);
1459:         // Process each file in the chunk
1460:         currentChunk.forEach(file => {
1461:           // Normalize the path to use forward slashes consistently
1462:           const normalizedPath = normalizePath(file.path);
1463:           // Check if file should be excluded by patterns
1464:           const isExcluded = shouldExcludeByDefault(normalizedPath, folderPath);
1465:           // Create a clean file object
1466:           processedFiles.push({
1467:             name: file.name ? String(file.name) : "",
1468:             path: normalizedPath, // Use normalized path
1469:             tokenCount: typeof file.tokenCount === "number" ? file.tokenCount : 0,
1470:             uncompressedTokenCount: typeof file.uncompressedTokenCount === "number" ? file.uncompressedTokenCount : 0,
1471:             isCompressed: typeof file.isCompressed === "boolean" ? file.isCompressed : false,
1472:             size: typeof file.size === "number" ? file.size : 0,
1473:             content: file.isBinary
1474:               ? ""
1475:               : typeof file.content === "string"
1476:               ? file.content
1477:               : "",
1478:             isBinary: Boolean(file.isBinary),
1479:             isSkipped: Boolean(file.isSkipped),
1480:             error: file.error ? String(file.error) : null,
1481:             fileType: file.fileType ? String(file.fileType) : null,
1482:             excludedByDefault: isExcluded,
1483:             excluded: isExcluded, // Set the excluded property as well
1484:           });
1485:         });
1486:         // Update the current index
1487:         currentIndex = endIndex;
1488:         // If there are more files to process, schedule the next chunk
1489:         if (currentIndex < files.length) {
1490:           // Use setTimeout to allow the UI to update between chunks
1491:           setTimeout(processNextChunk, 0);
1492:         } else {
1493:           // All files processed, send the complete list
1494:           console.log(`Finished processing all ${processedFiles.length} files`);
1495:           // Cache the processed files
1496:           directoryCache.set(folderPath, processedFiles);
1497:           try {
1498:             console.log(`Sending ${processedFiles.length} files to renderer`);
1499:             // Log a sample of paths to check normalization
1500:             if (processedFiles.length > 0) {
1501:               console.log("Sample file paths (first 3):");
1502:               processedFiles.slice(0, 3).forEach(file => {
1503:                 console.log(`- ${file.path}`);
1504:               });
1505:             }
1506:             // Send the files to the renderer process
1507:             event.sender.send("file-list-data", processedFiles);
1508:             // Clear loading state
1509:             isLoadingDirectory = false;
1510:             if (loadingTimeoutId) {
1511:               clearTimeout(loadingTimeoutId);
1512:               loadingTimeoutId = null;
1513:             }
1514:             // Set up file watcher after successfully loading the directory
1515:             setupFileWatcher(folderPath, mainWindow);
1516:           } catch (sendErr) {
1517:             console.error("Error sending file data:", sendErr);
1518:             // If sending fails, try again with minimal data
1519:             const minimalFiles = processedFiles.map((file) => ({
1520:               name: file.name,
1521:               path: file.path,
1522:               tokenCount: file.tokenCount,
1523:               uncompressedTokenCount: file.uncompressedTokenCount,
1524:               isCompressed: file.isCompressed,
1525:               size: file.size,
1526:               isBinary: file.isBinary,
1527:               isSkipped: file.isSkipped,
1528:               excludedByDefault: file.excludedByDefault,
1529:             }));
1530:             event.sender.send("file-list-data", minimalFiles);
1531:             // Clear loading state
1532:             isLoadingDirectory = false;
1533:             if (loadingTimeoutId) {
1534:               clearTimeout(loadingTimeoutId);
1535:               loadingTimeoutId = null;
1536:             }
1537:           }
1538:         }
1539:       };
1540:       // Start processing the first chunk
1541:       processNextChunk();
1542:     };
1543:     // Start processing files
1544:     processFiles();
1545:   } catch (error) {
1546:     console.error("Error processing files:", error);
1547:     event.sender.send("file-processing-status", {
1548:       status: "error",
1549:       message: `Error processing files: ${error.message}`,
1550:     });
1551:     // Clear loading state
1552:     isLoadingDirectory = false;
1553:     if (loadingTimeoutId) {
1554:       clearTimeout(loadingTimeoutId);
1555:       loadingTimeoutId = null;
1556:     }
1557:   }
1558: }
1559: // Check if a file should be excluded by default, using gitignore-style pattern matching
1560: // Create a pattern cache to avoid recreating ignore instances
1561: const patternCache = {
1562:   global: null,
1563:   local: {},  // Cache by rootDir
1564:   combined: {}, // Cache by rootDir
1565:   excludedLocal: {}, // Initialize excludedLocal object
1566:   excludedGlobal: [] // Initialize excludedGlobal array
1567: };
1568: // Counter to limit debug output
1569: let debugCounter = 0;
1570: const MAX_DEBUG_FILES = 5;
1571: function shouldExcludeByDefault(filePath, rootDir) {
1572:   // Normalize both paths to ensure consistent handling
1573:   const normalizedPath = normalizePath(filePath);
1574:   const normalizedRoot = normalizePath(rootDir);
1575:   // Use cached ignore instance if available
1576:   if (!patternCache.combined[rootDir]) {
1577:     // Initialize cache for this root directory
1578:     const ig = ignore();
1579:     // Track all patterns for debugging
1580:     let allPatterns = [];
1581:     // Add built-in patterns - convert array to a proper string format for the ignore package
1582:     const builtInPatterns = [...excludedFiles, ...DEFAULT_EXCLUSIONS];
1583:     ig.add(builtInPatterns);
1584:     allPatterns = builtInPatterns;
1585:     // Try to load global patterns if not already cached
1586:     if (!patternCache.global) {
1587:       try {
1588:         const appDataPath = app.getPath('userData');
1589:         const globalIgnorePath = path.join(appDataPath, 'global_patterns.ignore');
1590:         if (fs.existsSync(globalIgnorePath)) {
1591:           const content = fs.readFileSync(globalIgnorePath, 'utf8');
1592:           if (content.trim()) {
1593:             const { excludedPatterns, userPatterns } = parsePatterns(content);
1594:             // Cache global patterns and excluded patterns
1595:             patternCache.global = userPatterns;
1596:             patternCache.excludedGlobal = excludedPatterns;
1597:           }
1598:         }
1599:       } catch (err) {
1600:         console.error('Error loading global ignore patterns:', err);
1601:         patternCache.global = '';
1602:         patternCache.excludedGlobal = [];
1603:       }
1604:     }
1605:     // Add global patterns if available
1606:     if (patternCache.global) {
1607:       ig.add(patternCache.global);
1608:     }
1609:     // Try to load local patterns if not already cached
1610:     if (!patternCache.local[rootDir]) {
1611:       try {
1612:         const ignoreFilePath = path.join(rootDir, '.repo_ignore');
1613:         if (fs.existsSync(ignoreFilePath)) {
1614:           const content = fs.readFileSync(ignoreFilePath, 'utf8');
1615:           if (content.trim()) {
1616:             const { excludedPatterns, userPatterns } = parsePatterns(content);
1617:             // Cache local patterns and excluded patterns
1618:             patternCache.local[rootDir] = userPatterns;
1619:             patternCache.excludedLocal[rootDir] = excludedPatterns;
1620:           } else {
1621:             patternCache.local[rootDir] = '';
1622:             patternCache.excludedLocal[rootDir] = [];
1623:           }
1624:         } else {
1625:           patternCache.local[rootDir] = '';
1626:           patternCache.excludedLocal[rootDir] = [];
1627:         }
1628:       } catch (err) {
1629:         console.error('Error loading local ignore patterns:', err);
1630:         patternCache.local[rootDir] = '';
1631:         patternCache.excludedLocal[rootDir] = [];
1632:       }
1633:     }
1634:     // Add local patterns if available
1635:     if (patternCache.local[rootDir]) {
1636:       ig.add(patternCache.local[rootDir]);
1637:     }
1638:     // Cache the ignore instance
1639:     patternCache.combined[rootDir] = ig;
1640:   }
1641:   // Get the ignore instance from cache
1642:   const ig = patternCache.combined[rootDir];
1643:   // Check if the file should be ignored
1644:   const relativePath = path.relative(normalizedRoot, normalizedPath);
1645:   const shouldIgnore = ig.ignores(relativePath);
1646:   // Check if the pattern that would ignore this file is disabled
1647:   if (shouldIgnore) {
1648:     const excludedGlobal = patternCache.excludedGlobal || [];
1649:     const excludedLocal = patternCache.excludedLocal[rootDir] || [];
1650:     const allExcluded = [...excludedGlobal, ...excludedLocal];
1651:     // If any pattern that would match this file is disabled, don't ignore it
1652:     for (const pattern of allExcluded) {
1653:       try {
1654:         if (minimatch(relativePath, pattern)) {
1655:           return false;
1656:         }
1657:       } catch (e) {
1658:         console.error(`Error with minimatch for pattern "${pattern}":`, e);
1659:         // Continue processing other patterns if one fails
1660:       }
1661:     }
1662:   }
1663:   return shouldIgnore;
1664: }
1665: // Function to clear pattern cache when patterns change
1666: function clearPatternCache(rootDir) {
1667:   if (rootDir) {
1668:     delete patternCache.local[rootDir];
1669:     delete patternCache.combined[rootDir];
1670:     delete patternCache.excludedLocal[rootDir];
1671:   } else {
1672:     patternCache.global = null;
1673:     patternCache.local = {};
1674:     patternCache.combined = {};
1675:     patternCache.excludedLocal = {};
1676:     patternCache.excludedGlobal = [];
1677:   }
1678:   debugCounter = 0;
1679: }
1680: // IPC handler for counting tokens in a given text string
1681: ipcMain.handle('count-tokens', async (event, text) => {
1682:   try {
1683:     if (typeof text !== 'string') {
1684:       // Return 0 or throw error if input is not a string
1685:       return 0; 
1686:     }
1687:     return countTokens(text); // Reuse the existing countTokens function
1688:   } catch (error) {
1689:     console.error("Error handling 'count-tokens' IPC:", error);
1690:     // Return 0 or throw? Let's return 0 for robustness in the renderer.
1691:     return 0; 
1692:   }
1693: });
1694: // Add a debug handler for file selection
1695: ipcMain.on("debug-file-selection", (event, data) => {
1696:   console.log("DEBUG - File Selection:", data);
1697: });
1698: // Handle resetting patterns to defaults
1699: ipcMain.handle('reset-ignore-patterns', async (event, { folderPath, isGlobal }) => {
1700:   try {
1701:     if (isGlobal) {
1702:       // Reset global patterns to defaults
1703:       const appDataPath = app.getPath('userData');
1704:       const globalIgnorePath = path.join(appDataPath, 'global_patterns.ignore');
1705:       // Write default patterns to the file
1706:       await writeFile(globalIgnorePath, DEFAULT_USER_PATTERNS);
1707:       console.log(`Reset global ignore patterns to defaults at ${globalIgnorePath}`);
1708:       // Clear all pattern caches to ensure new patterns are applied
1709:       clearPatternCache();
1710:       // Clear all directory caches to ensure new patterns are applied
1711:       directoryCache.clearAll();
1712:       return { 
1713:         success: true, 
1714:         patterns: DEFAULT_USER_PATTERNS,
1715:         systemPatterns: SYSTEM_EXCLUSIONS
1716:       };
1717:     } else {
1718:       // Reset local patterns (delete the file)
1719:       if (!folderPath) {
1720:         return { success: false, error: 'No folder path provided' };
1721:       }
1722:       const ignoreFilePath = path.join(folderPath, '.repo_ignore');
1723:       if (fs.existsSync(ignoreFilePath)) {
1724:         fs.unlinkSync(ignoreFilePath);
1725:         console.log(`Deleted local ignore file at ${ignoreFilePath}`);
1726:       }
1727:       // Clear pattern cache for this folder
1728:       clearPatternCache(folderPath);
1729:       // Clear cache for this folder
1730:       directoryCache.clear(folderPath);
1731:       return { 
1732:         success: true, 
1733:         patterns: '',
1734:         systemPatterns: SYSTEM_EXCLUSIONS
1735:       };
1736:     }
1737:   } catch (error) {
1738:     console.error('Error resetting ignore patterns:', error);
1739:     return { success: false, error: error.message };
1740:   }
1741: });
1742: // Handle clearing ignore patterns (only for local patterns)
1743: ipcMain.handle('clear-local-ignore-patterns', async (event, { folderPath }) => {
1744:   console.log('Clearing local ignore patterns for:', folderPath);
1745:   try {
1746:     if (!folderPath) {
1747:       return { success: false, error: 'No folder path provided' };
1748:     }
1749:     const result = await clearLocalIgnorePatterns(folderPath);
1750:     // Clear the cache for this folder to ensure patterns are reloaded
1751:     if (patternCache.combined[folderPath]) {
1752:       delete patternCache.combined[folderPath];
1753:     }
1754:     return { success: true };
1755:   } catch (error) {
1756:     console.error('Error in clear-local-ignore-patterns handler:', error);
1757:     return { success: false, error: String(error) };
1758:   }
1759: });
1760: // Disable security warnings in development mode
1761: // These warnings don't appear in production builds anyway
1762: process.env.ELECTRON_DISABLE_SECURITY_WARNINGS = 'true';
1763: // Enable clipboard reading/writing (for security reasons, this is restricted by default)
1764: app.commandLine.appendSwitch('enable-features', 'SharedArrayBuffer');
1765: // This module pattern is preserved
1766: module.exports = { 
1767:   app, 
1768:   BrowserWindow,
1769:   // Export pattern-related functions
1770:   shouldExcludeByDefault,
1771:   getAllPatterns,
1772:   loadGitignore,
1773:   normalizePath
1774: };
1775: /**
1776:  * Clears local ignore patterns for a specific folder
1777:  * @param {string} folderPath - Path of the folder for which to clear ignore patterns
1778:  * @returns {Promise<boolean>} - True if successful, false otherwise
1779:  */
1780: async function clearLocalIgnorePatterns(folderPath) {
1781:   try {
1782:     const ignoreFilePath = path.join(folderPath, '.repo_ignore');
1783:     // Delete the file if it exists
1784:     if (fs.existsSync(ignoreFilePath)) {
1785:       await unlink(ignoreFilePath);
1786:       console.log(`Cleared local ignore patterns by deleting ${ignoreFilePath}`);
1787:     } else {
1788:       console.log(`No local ignore file found at ${ignoreFilePath}, nothing to clear`);
1789:     }
1790:     // Clear pattern cache for this folder using the correct cache variable
1791:     if (patternCache) {
1792:       // Clear local patterns
1793:       if (patternCache.local && patternCache.local[folderPath]) {
1794:         delete patternCache.local[folderPath];
1795:       }
1796:       // Clear combined patterns
1797:       if (patternCache.combined && patternCache.combined[folderPath]) {
1798:         delete patternCache.combined[folderPath];
1799:       }
1800:       // Clear excluded local patterns
1801:       if (patternCache.excludedLocal && patternCache.excludedLocal[folderPath]) {
1802:         delete patternCache.excludedLocal[folderPath];
1803:       }
1804:       console.log(`Cleared pattern cache for ${folderPath}`);
1805:     }
1806:     // Clear directory cache for this folder
1807:     if (directoryCache && typeof directoryCache.clear === 'function') {
1808:       directoryCache.clear(folderPath);
1809:     }
1810:     return true;
1811:   } catch (error) {
1812:     console.error('Error clearing local ignore patterns:', error);
1813:     throw error;
1814:   }
1815: }
1816: // Handle saving ignore patterns
1817: ipcMain.handle('save-ignore-patterns', async (event, { patterns, isGlobal, folderPath }) => {
1818:   try {
1819:     if (!isWindowValid(mainWindow)) {
1820:       console.warn("Window not initialized yet or destroyed");
1821:       return { success: false, error: 'Window not initialized' };
1822:     }
1823:     if (isGlobal) {
1824:       try {
1825:         const appDataPath = app.getPath('userData');
1826:         const globalIgnorePath = path.join(appDataPath, 'global_patterns.ignore');
1827:         // Ensure directory exists
1828:         if (!fs.existsSync(appDataPath)) {
1829:           await fs.promises.mkdir(appDataPath, { recursive: true });
1830:         }
1831:         // Write patterns to file
1832:         await fs.promises.writeFile(globalIgnorePath, patterns, 'utf8');
1833:         console.log(`Saved global ignore patterns to ${globalIgnorePath}`);
1834:         // Clear pattern cache to ensure new patterns are applied
1835:         clearPatternCache();
1836:         // Clear all directory caches to ensure new patterns are applied
1837:         directoryCache.clearAll();
1838:         return { success: true };
1839:       } catch (error) {
1840:         console.error('Error saving global patterns:', error);
1841:         return { success: false, error: error.message };
1842:       }
1843:     } else {
1844:       if (!folderPath) {
1845:         return { success: false, error: 'No folder path provided for local patterns' };
1846:       }
1847:       try {
1848:         const ignoreFilePath = path.join(folderPath, '.repo_ignore');
1849:         // Write patterns to file
1850:         await fs.promises.writeFile(ignoreFilePath, patterns, 'utf8');
1851:         console.log(`Saved local ignore patterns to ${ignoreFilePath}`);
1852:         // Clear pattern cache for this folder
1853:         clearPatternCache(folderPath);
1854:         // Clear cache for this folder
1855:         directoryCache.clear(folderPath);
1856:         return { success: true };
1857:       } catch (error) {
1858:         console.error('Error saving local patterns:', error);
1859:         return { success: false, error: error.message };
1860:       }
1861:     }
1862:   } catch (error) {
1863:     console.error('Error in save-ignore-patterns handler:', error);
1864:     return { success: false, error: error.message };
1865:   }
1866: });
1867: // Handle testing ignore patterns against a folder
1868: ipcMain.handle('test-ignore-patterns', async (event, { folderPath, patterns }) => {
1869:   console.log(`Testing patterns for folder: ${folderPath}`);
1870:   if (!folderPath || !patterns) {
1871:     return { success: false, error: 'Missing folderPath or patterns' };
1872:   }
1873:   try {
1874:     // 1. Create an ignore instance with the provided patterns
1875:     // Note: These patterns should already be combined (system+global+local)
1876:     // from the frontend logic, matching the current edits.
1877:     const ig = ignore().add(patterns);
1878:     // 2. Get the list of all files in the directory (recursively)
1879:     // We can reuse or adapt the file listing logic, ensuring it respects basic system ignores
1880:     // but *not* applying the user patterns yet, as we want to test against the raw list.
1881:     const allFiles = [];
1882:     const files = await fs.promises.readdir(folderPath, { withFileTypes: true });
1883:     // Basic recursive function to get all file paths relative to the root
1884:     // This needs to be robust and handle potential errors/symlinks etc.
1885:     // For simplicity here, we use a basic traversal. Consider reusing `walkDirectory` logic if available.
1886:     async function traverseDir(currentPath) {
1887:       try {
1888:         const entries = await fs.promises.readdir(currentPath, { withFileTypes: true });
1889:         for (const entry of entries) {
1890:           const fullPath = path.join(currentPath, entry.name);
1891:           const relativePath = path.relative(folderPath, fullPath);
1892:           // Basic exclusion (e.g., node_modules, .git) - apply system defaults if needed
1893:           // Or rely on the provided patterns to handle this.
1894:           // For now, let's assume the provided `patterns` include system defaults.
1895:           if (entry.isDirectory()) {
1896:             // Check if directory itself is ignored before traversing
1897:             if (!ig.ignores(relativePath + '/')) { // Add trailing slash for directories
1898:               await traverseDir(fullPath);
1899:             }
1900:           } else if (entry.isFile()) {
1901:             allFiles.push(normalizePath(relativePath)); // Add normalized relative path
1902:           }
1903:         }
1904:       } catch (error) {
1905:         // Log errors but continue if possible
1906:         console.warn(`Error reading directory ${currentPath}:`, error.message);
1907:       }
1908:     }
1909:     await traverseDir(folderPath);
1910:     // 3. Filter the file list using the ignore instance
1911:     const ignoredFiles = allFiles.filter(relativePath => ig.ignores(relativePath));
1912:     console.log(`Found ${allFiles.length} total files, ${ignoredFiles.length} would be ignored.`);
1913:     return {
1914:       success: true,
1915:       ignoredCount: ignoredFiles.length,
1916:       ignoredFiles: ignoredFiles, // Return the list of ignored relative paths
1917:       totalFilesChecked: allFiles.length
1918:     };
1919:   } catch (error) {
1920:     console.error('Error testing ignore patterns:', error);
1921:     return { success: false, error: error.message };
1922:   }
1923: });
1924: // Setup file watcher for real-time file change detection
1925: function setupFileWatcher(folderPath, window) {
1926:   // Close any existing watcher
1927:   if (fileWatcher) {
1928:     console.log("Closing existing file watcher");
1929:     fileWatcher.close();
1930:     fileWatcher = null;
1931:   }
1932:   // Close all existing watchers if we're maintaining an array of them
1933:   if (global.allWatchers && Array.isArray(global.allWatchers)) {
1934:     console.log(`Closing ${global.allWatchers.length} existing watchers`);
1935:     global.allWatchers.forEach(w => {
1936:       try {
1937:         w.close();
1938:       } catch (err) {
1939:         // Ignore errors when closing
1940:       }
1941:     });
1942:     global.allWatchers = [];
1943:   } else {
1944:     global.allWatchers = [];
1945:   }
1946:   if (!folderPath || !window || !isWindowValid(window)) {
1947:     console.log("Cannot setup file watcher: missing dependencies");
1948:     return;
1949:   }
1950:   console.log(`Setting up file watcher for ${folderPath}`);
1951:   try {
1952:     // Get ignore patterns for this folder to avoid watching excluded files
1953:     const allPatterns = getAllPatterns(folderPath);
1954:     const ig = ignore().add(allPatterns);
1955:     // Create ignored function for filtering
1956:     const isIgnored = (watchPath) => {
1957:       // Check for empty or invalid paths
1958:       if (!watchPath || typeof watchPath !== 'string' || watchPath.trim() === '') {
1959:         console.warn(`Attempted to check an empty or invalid path for ignoring. Treating as not ignored.`);
1960:         return false; // Don't ignore empty paths
1961:       }
1962:       // Always ignore node_modules and other large directories
1963:       if (watchPath.includes('node_modules') || 
1964:           watchPath.includes('.git') || 
1965:           watchPath.includes('dist') || 
1966:           watchPath.includes('build')) {
1967:         return true;
1968:       }
1969:       // The ignore package requires relative paths
1970:       try {
1971:         const normalizedWatchPath = normalizePath(watchPath);
1972:         const normalizedFolderPath = normalizePath(folderPath);
1973:         // Convert absolute path to relative path
1974:         const relativePath = path.relative(normalizedFolderPath, normalizedWatchPath);
1975:         // Check that relativePath is not empty before passing to ignores()
1976:         if (!relativePath || relativePath.trim() === '') {
1977:           console.warn(`Empty relative path generated from: ${watchPath}. Treating as not ignored.`);
1978:           return false;
1979:         }
1980:         // Now pass the relative path to ignores()
1981:         return ig.ignores(relativePath);
1982:       } catch (err) {
1983:         console.warn(`Error checking if path is ignored: ${watchPath}`, err);
1984:         return false; // Don't ignore if there's an error
1985:       }
1986:     };
1987:     // Use chokidar if available, otherwise fall back to native fs.watch
1988:     if (chokidar && typeof chokidar.watch === 'function' && 
1989:         chokidar.watch.toString().includes('function')) {
1990:       // Start watching the folder with appropriate options using chokidar
1991:       try {
1992:         console.log("Using chokidar for file watching with optimized settings");
1993:         fileWatcher = chokidar.watch(folderPath, {
1994:           ignored: [
1995:             isIgnored,
1996:             /(^|[\/\\])\../, // Ignore dotfiles
1997:             '**/node_modules/**',
1998:             '**/.git/**'
1999:           ],
2000:           persistent: true,
2001:           ignoreInitial: true, // Don't fire events for existing files
2002:           awaitWriteFinish: {
2003:             stabilityThreshold: 500, // Wait 500ms after last change
2004:             pollInterval: 100 // Poll every 100ms
2005:           },
2006:           depth: 5, // Limit watch depth to 5 levels to prevent excessive watchers
2007:           useFsEvents: true, // Use native filesystem events if available
2008:           alwaysStat: false, // Don't get stats for all files (performance)
2009:           usePolling: false // Don't use polling (uses more CPU)
2010:         });
2011:         // Set up event handlers with debouncing to avoid too many updates
2012:         let addDebounce = null;
2013:         let changeDebounce = null;
2014:         let deleteDebounce = null;
2015:         fileWatcher
2016:           .on('add', path => {
2017:             if (addDebounce) clearTimeout(addDebounce);
2018:             addDebounce = setTimeout(() => {
2019:               console.log(`File added (raw path): ${path}`);
2020:               // Ensure consistent path format
2021:               const normalizedPath = normalizePath(path);
2022:               safeRendererSend(window, 'file-changed', { type: 'add', path: normalizedPath });
2023:             }, WATCH_DEBOUNCE_TIME);
2024:           })
2025:           .on('change', path => {
2026:             if (changeDebounce) clearTimeout(changeDebounce);
2027:             changeDebounce = setTimeout(() => {
2028:               console.log(`File changed (raw path): ${path}`);
2029:               // Ensure consistent path format
2030:               const normalizedPath = normalizePath(path);
2031:               safeRendererSend(window, 'file-changed', { type: 'change', path: normalizedPath });
2032:             }, WATCH_DEBOUNCE_TIME);
2033:           })
2034:           .on('unlink', path => {
2035:             if (deleteDebounce) clearTimeout(deleteDebounce);
2036:             deleteDebounce = setTimeout(() => {
2037:               console.log(`File deleted (raw path): ${path}`);
2038:               // Ensure consistent path format
2039:               const normalizedPath = normalizePath(path);
2040:               safeRendererSend(window, 'file-changed', { type: 'delete', path: normalizedPath });
2041:             }, WATCH_DEBOUNCE_TIME);
2042:           })
2043:           .on('error', error => {
2044:             // Handle errors specifically
2045:             if (error.code === 'EMFILE') {
2046:               console.error('Too many files to watch! Some changes may not be detected.');
2047:               console.error('You can increase the limit with: ulimit -n <number> (macOS/Linux)');
2048:               safeRendererSend(window, 'file-processing-status', {
2049:                 status: 'warning',
2050:                 message: 'Too many files to watch. Some changes may not be detected.'
2051:               });
2052:             } else {
2053:               console.error(`File watcher error: ${error}`);
2054:             }
2055:           });
2056:         console.log("Chokidar file watcher set up successfully");
2057:       } catch (err) {
2058:         console.error(`Error setting up chokidar watcher: ${err}`);
2059:         // Fall back to fs.watch on chokidar failure
2060:         useFsWatchFallback();
2061:       }
2062:     } else {
2063:       // Fall back to native fs.watch
2064:       useFsWatchFallback();
2065:     }
2066:     // Function for using fs.watch as a fallback
2067:     function useFsWatchFallback() {
2068:       console.log("Using optimized native fs.watch fallback for file watching");
2069:       // This will store all the watchers we create
2070:       const watchers = [];
2071:       let addDebounce = null;
2072:       let deleteDebounce = null;
2073:       let changeDebounce = null;
2074:       // Create a watcher manager to handle errors and limits
2075:       const watcherManager = {
2076:         // Track the number of watchers and depth
2077:         count: 0,
2078:         // Maximum number of watchers to create
2079:         MAX_WATCHERS: 1000,
2080:         // Maximum directory depth to watch
2081:         MAX_DEPTH: 4,
2082:         // Add a watcher if we haven't hit the limit
2083:         addWatcher: function(watcher) {
2084:           if (this.count >= this.MAX_WATCHERS) {
2085:             console.warn(`Reached maximum watcher limit (${this.MAX_WATCHERS}). Some changes may not be detected.`);
2086:             return false;
2087:           }
2088:           watchers.push(watcher);
2089:           global.allWatchers.push(watcher); // Also add to global tracker
2090:           this.count++;
2091:           return true;
2092:         },
2093:         // Check if we can add more watchers
2094:         canAddWatchers: function() {
2095:           return this.count < this.MAX_WATCHERS;
2096:         }
2097:       };
2098:       // Function to watch a directory and its subdirectories
2099:       const watchDirectory = (dir, depth = 0) => {
2100:         // Validate directory path before proceeding
2101:         if (!dir || typeof dir !== 'string' || dir.trim() === '') {
2102:           console.warn('Attempted to watch an empty or invalid directory path. Skipping.');
2103:           return;
2104:         }
2105:         // Check depth limit to avoid excessive recursion
2106:         if (depth > watcherManager.MAX_DEPTH) {
2107:           console.log(`Reached maximum watch depth (${watcherManager.MAX_DEPTH}) for ${dir}. Skipping deeper directories.`);
2108:           return;
2109:         }
2110:         // Check if we should ignore this directory
2111:         if (isIgnored(dir)) {
2112:           return;
2113:         }
2114:         // Check if we've hit the watcher limit
2115:         if (!watcherManager.canAddWatchers()) {
2116:           return;
2117:         }
2118:         try {
2119:           // Watch the current directory
2120:           const watcher = safeFsWatch(dir, (eventType, filename) => {
2121:             // Validate filename before using it
2122:             if (!filename || typeof filename !== 'string' || filename.trim() === '') {
2123:               console.warn(`Received empty or invalid filename in watcher event for ${dir}. Skipping.`);
2124:               return;
2125:             }
2126:             const fullPath = path.join(dir, filename);
2127:             // Skip ignored files/directories
2128:             if (isIgnored(fullPath)) return;
2129:             try {
2130:               // Check if the path still exists
2131:               const exists = fs.existsSync(fullPath);
2132:               const stats = exists ? fs.statSync(fullPath) : null;
2133:               if (eventType === 'rename') {
2134:                 if (exists && stats) {
2135:                   // It's an add event
2136:                   if (addDebounce) clearTimeout(addDebounce);
2137:                   addDebounce = setTimeout(() => {
2138:                     console.log(`File added (raw path): ${fullPath}`);
2139:                     // Ensure consistent path format
2140:                     const normalizedPath = normalizePath(fullPath);
2141:                     safeRendererSend(window, 'file-changed', { type: 'add', path: normalizedPath });
2142:                     // If it's a directory, watch it too (but respect depth limit)
2143:                     if (stats.isDirectory() && depth < watcherManager.MAX_DEPTH) {
2144:                       watchDirectory(fullPath, depth + 1);
2145:                     }
2146:                   }, WATCH_DEBOUNCE_TIME);
2147:                 } else {
2148:                   // It's a delete event
2149:                   if (deleteDebounce) clearTimeout(deleteDebounce);
2150:                   deleteDebounce = setTimeout(() => {
2151:                     console.log(`File deleted (raw path): ${fullPath}`);
2152:                     // Ensure consistent path format
2153:                     const normalizedPath = normalizePath(fullPath);
2154:                     safeRendererSend(window, 'file-changed', { type: 'delete', path: normalizedPath });
2155:                   }, WATCH_DEBOUNCE_TIME);
2156:                 }
2157:               } else if (eventType === 'change' && exists && stats && !stats.isDirectory()) {
2158:                 // It's a file change event
2159:                 if (changeDebounce) clearTimeout(changeDebounce);
2160:                 changeDebounce = setTimeout(() => {
2161:                   console.log(`File changed (raw path): ${fullPath}`);
2162:                   // Ensure consistent path format
2163:                   const normalizedPath = normalizePath(fullPath);
2164:                   safeRendererSend(window, 'file-changed', { type: 'change', path: normalizedPath });
2165:                 }, WATCH_DEBOUNCE_TIME);
2166:               }
2167:             } catch (err) {
2168:               console.error(`Error handling file event for ${fullPath}:`, err);
2169:             }
2170:           });
2171:           // Add to our tracked watchers
2172:           if (watcher && watcherManager.addWatcher(watcher)) {
2173:             if (depth === 0) {
2174:               console.log(`Set up root watcher for ${dir}`);
2175:             }
2176:           }
2177:           // Recursively watch subdirectories (with depth limit)
2178:           try {
2179:             if (watcherManager.canAddWatchers()) {
2180:               const entries = fs.readdirSync(dir, { withFileTypes: true });
2181:               // Process only directories
2182:               const directories = entries.filter(entry => entry.isDirectory());
2183:               // Limit the number of directories to watch at each level
2184:               const MAX_DIRS_PER_LEVEL = 50;
2185:               if (directories.length > MAX_DIRS_PER_LEVEL) {
2186:                 console.log(`Limiting subdirectory watching to ${MAX_DIRS_PER_LEVEL} at ${dir}`);
2187:                 directories.length = MAX_DIRS_PER_LEVEL;
2188:               }
2189:               for (const entry of directories) {
2190:                 if (!watcherManager.canAddWatchers()) {
2191:                   console.log(`Reached watcher limit. Stopping directory traversal at ${dir}`);
2192:                   break;
2193:                 }
2194:                 const subDir = path.join(dir, entry.name);
2195:                 if (!isIgnored(subDir)) {
2196:                   watchDirectory(subDir, depth + 1);
2197:                 }
2198:               }
2199:             }
2200:           } catch (err) {
2201:             console.error(`Error reading directory ${dir}:`, err);
2202:           }
2203:         } catch (err) {
2204:           // Handle EMFILE error specifically
2205:           if (err.code === 'EMFILE') {
2206:             console.error('Too many open files. No more watchers will be created.');
2207:             safeRendererSend(window, 'file-processing-status', {
2208:               status: 'warning',
2209:               message: 'Too many files to watch. Some changes may not be detected.'
2210:             });
2211:           } else {
2212:             console.error(`Error setting up watcher for ${dir}:`, err);
2213:           }
2214:         }
2215:       };
2216:       // Start watching from the root folder
2217:       watchDirectory(folderPath);
2218:       // Create a fileWatcher-like object with a close method
2219:       fileWatcher = {
2220:         close: () => {
2221:           watchers.forEach(watcher => {
2222:             try {
2223:               watcher.close();
2224:             } catch (err) {
2225:               console.error("Error closing watcher:", err);
2226:             }
2227:           });
2228:           console.log(`Closed ${watchers.length} watchers`);
2229:         }
2230:       };
2231:       console.log(`Native fs.watch fallback set up with ${watchers.length} watchers`);
2232:     }
2233:     console.log("File watcher set up successfully");
2234:   } catch (error) {
2235:     console.error("Error setting up file watcher:", error);
2236:     // Notify the renderer of the error
2237:     safeRendererSend(window, 'file-processing-status', {
2238:       status: 'error',
2239:       message: `Error setting up file watcher: ${error.message}`
2240:     });
2241:   }
2242: }
2243: // Handle get-file-metadata request
2244: ipcMain.handle("get-file-metadata", async (event, filePath) => {
2245:   try {
2246:     console.log(`Getting metadata for file: ${filePath}`);
2247:     if (!filePath) {
2248:       return { success: false, error: "No file path provided" };
2249:     }
2250:     // Check if file exists
2251:     if (!fs.existsSync(filePath)) {
2252:       return { success: false, error: "File does not exist" };
2253:     }
2254:     // Get file stats
2255:     const stats = fs.statSync(filePath);
2256:     // Skip if it's a directory
2257:     if (stats.isDirectory()) {
2258:       return { success: false, error: "Path is a directory, not a file" };
2259:     }
2260:     // Check if it's a binary file
2261:     const isBinary = isBinaryFile(filePath);
2262:     // Get base file info
2263:     const fileName = path.basename(filePath);
2264:     const normalizedPath = normalizePath(filePath);
2265:     // Find parent directory to check ignore patterns
2266:     const parentDir = path.dirname(filePath);
2267:     const isExcluded = shouldExcludeByDefault(normalizedPath, parentDir);
2268:     // Create file metadata object
2269:     const fileData = {
2270:       name: fileName,
2271:       path: normalizedPath,
2272:       size: stats.size,
2273:       lastModified: stats.mtime.getTime(),
2274:       isBinary: isBinary,
2275:       excludedByDefault: isExcluded,
2276:       excluded: isExcluded,
2277:       isSkipped: isBinary || isExcluded || stats.size > MAX_FILE_SIZE,
2278:       tokenCount: 0, // Will be calculated on demand
2279:       uncompressedTokenCount: 0
2280:     };
2281:     // If it's a small text file, count tokens
2282:     if (!isBinary && stats.size <= MAX_FILE_SIZE) {
2283:       try {
2284:         const content = fs.readFileSync(filePath, "utf-8");
2285:         fileData.tokenCount = countTokens(content);
2286:         fileData.uncompressedTokenCount = fileData.tokenCount;
2287:       } catch (error) {
2288:         console.error(`Error reading file content for ${filePath}:`, error);
2289:         fileData.error = `Error reading file: ${error.message}`;
2290:       }
2291:     }
2292:     return {
2293:       success: true,
2294:       fileData
2295:     };
2296:   } catch (error) {
2297:     console.error(`Error getting file metadata for ${filePath}:`, error);
2298:     return {
2299:       success: false,
2300:       error: `Error: ${error.message}`
2301:     };
2302:   }
2303: });
2304: // Add diagnostics function
2305: function showModuleLoadingDiagnostics() {
2306:   console.log('============= MODULE LOADING DIAGNOSTICS =============');
2307:   console.log(`App location: ${app.getAppPath()}`);
2308:   console.log(`Resources path: ${process.resourcesPath || 'Not available'}`);
2309:   console.log(`Executable path: ${app.getPath('exe')}`);
2310:   console.log(`Current directory: ${process.cwd()}`);
2311:   console.log(`Is packaged: ${app.isPackaged}`);
2312:   // Try to list some directories to verify access
2313:   try {
2314:     if (process.resourcesPath) {
2315:       console.log(`Resources directory contents:`);
2316:       fs.readdirSync(process.resourcesPath).forEach(item => {
2317:         console.log(`  - ${item}`);
2318:       });
2319:     }
2320:   } catch (err) {
2321:     console.error(`Error reading resources directory: ${err.message}`);
2322:   }
2323:   console.log('====================================================');
2324: }

================
File: README.md
================
  1: # ContextCraft
  2: 
  3: <div align="center">
  4:   <img src="https://github.com/user-attachments/assets/ecd72a53-65be-4175-9a03-2cf141948dae" alt="ContextCraft Logo" width="180">
  5:   <p>A powerful code formatter and exporter for sharing code with AI models.</p>
  6: </div>
  7: 
  8: ## Overview
  9: 
 10: ContextCraft is a desktop application designed to help developers easily format and export their code for sharing with AI models like Claude, ChatGPT, and others. It provides an intuitive interface to select specific files from your project, generate file trees, add custom instructions, and export everything in a well-formatted manner that preserves context.
 11: 
 12: <div align="center">
 13:  <img width="480" alt="ContextCraft Interface" src="https://github.com/user-attachments/assets/ba6aeac4-55bb-4dda-af03-fb3dd0345aef" />
 14: </div>
 15: 
 16: ## Documentation
 17: 
 18: Comprehensive documentation is available on our [GitHub Wiki](https://github.com/flight505/ContextCraft/wiki).
 19: 
 20: The wiki includes:
 21: - Detailed installation instructions
 22: - Feature guides and examples
 23: - Configuration options
 24: - Troubleshooting steps
 25: - Best practices for AI prompting
 26: 
 27: ## Features
 28: 
 29: - 🗂️ **Project Navigation**: Browse and select files from your project directory
 30: - 🌲 **File Tree Generation**: Create an ASCII file tree representation of your project structure
 31: - 🔍 **Smart Search**: Filter files by name or content
 32: - 📝 **Custom Instructions**: Add context or specific instructions for AI models
 33: - 🔄 **Multiple File Tree Modes**: None, Selected, Selected with Roots, Complete
 34: - 🚫 **Ignore Patterns**: Configure glob patterns for files to exclude
 35: - 🌗 **Light/Dark/System Theme**: Choose your preferred appearance mode
 36: - 📊 **Token Counting**: Track token usage to stay within AI model limits
 37: - 📋 **One-Click Copy**: Easily copy formatted output to clipboard
 38: 
 39: ## Features in Detail
 40: 
 41: ### 🎯 Smart Prompt Management
 42: - **Built-in Templates**: Pre-configured prompts for common use cases like code review, bug fixing, and feature implementation
 43: - **Custom Instructions**: Create and save your own prompt templates with placeholders for dynamic content
 44: - **Context Variables**: Use variables like `{selected_files}`, `{file_tree}`, and `{custom_notes}` in your prompts
 45: - **Preview Mode**: Real-time preview of how your prompt will look with the current selection
 46: 
 47: ### 🌳 File Tree Visualization
 48: - **Multiple View Modes**:
 49:   - `None`: Clean output without directory structure
 50:   - `Selected`: Show only chosen files in tree view
 51:   - `Selected with Roots`: Display selected files with their parent directories
 52:   - `Complete`: Full project structure visualization
 53: - **Smart Path Display**: Automatically collapses long paths for better readability
 54: - **Interactive Navigation**: Click to expand/collapse directories
 55: - **Search & Filter**: Quickly find files with fuzzy search and pattern matching
 56: 
 57: ### 📊 AI Model Integration
 58: - **Token Management**:
 59:   - Real-time token counting for selected content
 60:   - Visual indicators for context limit warnings
 61:   - Support for 290 models (GPT-4, o3, o1-pro, Claude 3.5 - 3.7, etc.)
 62:   - Automatic content optimization suggestions when approaching limits
 63: - **Model-Specific Features**:
 64:   - Customizable context windows per model
 65:   - Token budget allocation for responses
 66:   - Smart content truncation to fit model limits
 67: 
 68: ### ⚡ Code Optimization Tools
 69: - **Smart Compression**:
 70:   - Intelligent whitespace reduction
 71:   - Comment density optimization
 72:   - Import statement consolidation
 73:   - Unused code detection
 74: - **Content Filtering**:
 75:   - Selective comment removal
 76:   - Docstring preservation options
 77:   - Keep/remove TODO markers
 78:   - License and copyright notice handling
 79: - **Format Controls**:
 80:   - Preserve or strip markdown formatting
 81:   - Code block style options
 82:   - Line number inclusion toggle
 83:   - Syntax highlighting preferences
 84: 
 85: ### 🔧 Advanced Configuration
 86: - **Ignore Patterns**:
 87:   - GitIgnore-style pattern support
 88:   - Custom exclusion rules
 89:   - Directory-specific settings
 90:   - Binary file handling
 91: - **Output Formatting**:
 92:   - Customizable indentation
 93:   - Line ending normalization
 94:   - Character encoding options
 95:   - Maximum line length control
 96: 
 97: ### 💾 Session Management
 98: - **Workspace Memory**:
 99:   - Auto-save selected files
100:   - Restore previous sessions
101:   - Multiple workspace support
102:   - Custom workspace naming
103: - **Export Options**:
104:   - Copy to clipboard
105:   - Save as markdown
106:   - Export as formatted text
107:   - Generate shareable links
108: 
109: ## Installation
110: 
111: ### macOS
112: Download the latest version from the [Releases](https://github.com/flight505/ContextCraft/releases) page.
113: 
114: You have two options:
115: 1. **DMG Installer (Recommended)**: Download the latest `ContextCraft-[version]-arm64-mac.dmg`
116:    - Open the DMG file
117:    - Drag the ContextCraft app to your Applications folder
118:    - Launch the app from your Applications folder or Launchpad
119: 
120: 2. **ZIP Archive**: Download the latest `ContextCraft-[version]-arm64-mac.zip`
121:    - Extract the ZIP file
122:    - Move the extracted ContextCraft app to your Applications folder
123:    - Launch the app from your Applications folder or Launchpad
124: 
125: ContextCraft is properly signed and notarized with an Apple Developer Certificate, ensuring a smooth installation experience. You should be able to open the application without any security warnings.
126: 
127: ### Windows
128: Download the latest Windows build from the [Releases](https://github.com/flight505/ContextCraft/releases) page. You have two options:
129: 
130: #### Option 1: Standard Installation (Recommended)
131: 1. Download `ContextCraft-[version]-x64-setup.exe`
132: 2. Double-click the installer
133: 3. Follow the installation wizard
134: 4. The app will be installed in your Program Files directory
135: 5. Launch from the Start Menu or desktop shortcut
136: 
137: #### Option 2: Portable Version
138: 1. Download `ContextCraft-[version]-x64-portable.exe`
139: 2. Move the .exe file to your preferred location
140: 3. Double-click to run directly - no installation needed
141: 4. Can be moved between computers or run from a USB drive
142: 
143: #### Windows Security Notice
144: When running for the first time, Windows may show a SmartScreen warning:
145: 1. Click "More info"
146: 2. Click "Run anyway"
147: This happens because the app isn't signed with a Microsoft certificate. The app is safe to use, but Windows shows this warning for all new/unknown applications.
148: 
149: #### System Requirements
150: - Windows 10 or later (64-bit)
151: - 4GB RAM minimum (8GB recommended)
152: - 200MB free disk space
153: 
154: ## Quick Start
155: 
156: 1. **Select a Project**: Click "Select Folder" to choose your project directory
157: 2. **Choose Files**: Select the files you want to include
158: 3. **Configure**: Choose your file tree mode and add any custom instructions
159: 4. **Export**: Click "Copy" to copy the formatted content
160: 5. **Share**: Paste directly into your preferred AI model
161: 
162: ## Development
163: 
164: ### Prerequisites
165: - Node.js 18+
166: - npm or yarn
167: 
168: ### Setup
169: ```bash
170: # Clone the repository
171: git clone https://github.com/flight505/ContextCraft.git
172: cd ContextCraft
173: 
174: # Install dependencies
175: npm install
176: 
177: # Start development
178: npm run dev:electron
179: ```
180: 
181: ### Building
182: ```bash
183: # Build for all platforms
184: npm run package:all
185: 
186: # Or specific platforms
187: npm run package:mac
188: npm run package:win
189: npm run package:linux
190: ```
191: 
192: ## License
193: 
194: Completely rewritten by me and AI and it is completely free and open source.
195: 
196: For full disclosure, this is based on a video by Kevin Leneway, which you can find at https://www.youtube.com/@kevinleneway2290 
197: Follow his channel for more great content!
198: ---
199: 
200: <div align="center">
201:   <p>Built with ❤️ using Electron and React</p>
202: </div>
203: 
204: 
205: ## Credits
206: 
207: - [Kevin Leneway](https://github.com/flight505) - Original author of the ContextCraft project
208: - [ChatGPT](https://github.com/openai/chatgpt) - AI-powered code generation
209: - [Cursor](https://github.com/cursor-ai/cursor) - AI-powered code generation

================
File: package.json
================
  1: {
  2:   "name": "contextcraft",
  3:   "version": "1.0.19",
  4:   "main": "electron/main.js",
  5:   "scripts": {
  6:     "start": "electron .",
  7:     "dev": "vite",
  8:     "vite": "vite build",
  9:     "dev:electron": "cross-env ELECTRON_START_URL=http://localhost:5173 node scripts/dev.js",
 10:     "dev:c++20": "node scripts/dev-with-c++20.js",
 11:     "build": "node scripts/fix-module-deps.js && vite build",
 12:     "build-electron": "node scripts/fix-module-deps.js && vite build",
 13:     "verify-build": "node scripts/verify-build.js",
 14:     "test-build": "node scripts/test-local-build.js",
 15:     "test-build:mac": "node scripts/test-local-build.js mac",
 16:     "test-build:mac-full": "node scripts/test-local-mac-build.js",
 17:     "test-build:mac-no-sign": "node scripts/test-local-mac-build.js --skip-signing",
 18:     "test-build:mac-unsigned": "node scripts/fix-module-deps.js && vite build && electron-builder --mac --x64 --arm64 --publish=never -c.mac.target=zip -c.mac.identity=null --skip-signing",
 19:     "test-build:mac-diagnostics": "node -e \"console.log('=== macOS Build Diagnostics ===\\n\\nElectron-builder version:', require('electron-builder/package.json').version, '\\nElectron version:', require('electron/package.json').version, '\\nMac OS version:', require('os').release())\"",
 20:     "test-build:win": "node scripts/test-local-build.js win",
 21:     "test-build:linux": "node scripts/test-local-build.js linux",
 22:     "test-build:cross": "node scripts/cross-platform-build.js",
 23:     "test-all": "npm test && npm run rebuild-native-modules && npm run test-build:mac && npm run test-build:win",
 24:     "test-comprehensive": "node scripts/test-comprehensive.js",
 25:     "test-signing-credentials": "node scripts/test-credentials.js",
 26:     "debug-gh-release": "git tag debug-v$(date +'%Y%m%d%H%M%S') && git push origin --tags",
 27:     "diagnose-mac": "node scripts/diagnose-build.js",
 28:     "fix-html-path": "node scripts/fix-html-path.js",
 29:     "debug-tree-sitter": "NODE_DEBUG=module,treesitter DEBUG=electron-builder electron .",
 30:     "debug-build-mac": "NODE_DEBUG=module,treesitter DEBUG=electron-builder npm run package:mac -- --verbose",
 31:     "cleanup": "node scripts/cleanup-builds.js",
 32:     "package": "npm run cleanup && node scripts/fix-module-deps.js && vite build && electron-builder --publish=never",
 33:     "package:mac": "npm run cleanup && npm run rebuild-native-modules && node scripts/fix-module-deps.js && vite build && node scripts/mac-build.js",
 34:     "package:win": "npm run cleanup && npm run rebuild-native-modules && node scripts/fix-module-deps.js && vite build && node scripts/windows-build.js",
 35:     "package:linux": "npm run cleanup && npm run rebuild-native-modules && node scripts/fix-module-deps.js && vite build && electron-builder --linux --publish=never",
 36:     "package:all": "npm run cleanup && npm run rebuild-native-modules && node scripts/fix-module-deps.js && vite build && electron-builder -mwl --publish=never",
 37:     "package:all-no-sign": "node scripts/build-all-platforms-no-sign.js",
 38:     "release": "npm run cleanup && node scripts/fix-module-deps.js && vite build && electron-builder --publish=onTagOrDraft",
 39:     "postinstall": "electron-builder install-app-deps",
 40:     "rebuild-native-modules": "node scripts/rebuild-native-modules.js",
 41:     "fix-tree-sitter": "node scripts/fix-tree-sitter.js",
 42:     "fix-module-deps": "node scripts/fix-module-deps.js",
 43:     "lint": "eslint . --ext ts,tsx --report-unused-disable-directives",
 44:     "lint:strict": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
 45:     "preview": "vite preview",
 46:     "test": "jest",
 47:     "test:watch": "jest --watch",
 48:     "test:coverage": "jest --coverage"
 49:   },
 50:   "keywords": [
 51:     "clipboard",
 52:     "code",
 53:     "developer-tools",
 54:     "electron",
 55:     "file-viewer"
 56:   ],
 57:   "author": {
 58:     "name": "flight505",
 59:     "email": "jesper_vang@me.com"
 60:   },
 61:   "license": "MIT",
 62:   "description": "A modern file viewer application for developers to easily navigate, search, and copy code from repositories.",
 63:   "build": {
 64:     "appId": "com.contextcraft.app",
 65:     "productName": "ContextCraft",
 66:     "directories": {
 67:       "output": "release-builds",
 68:       "buildResources": "build"
 69:     },
 70:     "files": [
 71:       "dist/**/*",
 72:       "electron/**/*",
 73:       "!node_modules/**",
 74:       "package.json"
 75:     ],
 76:     "extraResources": [
 77:       {
 78:         "from": "node_modules",
 79:         "to": "node_modules",
 80:         "filter": [
 81:           "minimatch/**",
 82:           "brace-expansion/**",
 83:           "balanced-match/**",
 84:           "ignore/**",
 85:           "micromatch/**",
 86:           "braces/**",
 87:           "fill-range/**",
 88:           "to-regex-range/**",
 89:           "is-number/**",
 90:           "picomatch/**",
 91:           "chokidar/**",
 92:           "readdirp/**",
 93:           "tree-sitter/**/*",
 94:           "tree-sitter-javascript/**/*",
 95:           "tree-sitter-typescript/**/*",
 96:           "tree-sitter-python/**/*",
 97:           "tree-sitter-css/**/*",
 98:           "tree-sitter-html/**/*",
 99:           "jsdom/**",
100:           "dompurify/**",
101:           "tiktoken/**",
102:           "gpt-3-encoder/**",
103:           "node-gyp-build/**"
104:         ]
105:       }
106:     ],
107:     "afterSign": "scripts/notarize.js",
108:     "mac": {
109:       "category": "public.app-category.developer-tools",
110:       "icon": "public/favicon.icns",
111:       "target": [
112:         "dmg",
113:         "zip"
114:       ],
115:       "hardenedRuntime": true,
116:       "gatekeeperAssess": false,
117:       "entitlements": "build/entitlements.mac.plist",
118:       "entitlementsInherit": "build/entitlements.mac.plist"
119:     },
120:     "win": {
121:       "target": [
122:         {
123:           "target": "nsis",
124:           "arch": [
125:             "x64"
126:           ]
127:         },
128:         {
129:           "target": "portable",
130:           "arch": [
131:             "x64"
132:           ]
133:         }
134:       ],
135:       "icon": "public/favicon.ico",
136:       "artifactName": "ContextCraft-${version}-${arch}-${name}.${ext}"
137:     },
138:     "nsis": {
139:       "oneClick": true,
140:       "perMachine": false,
141:       "allowToChangeInstallationDirectory": false,
142:       "deleteAppDataOnUninstall": true,
143:       "artifactName": "ContextCraft-${version}-${arch}-setup.${ext}"
144:     },
145:     "portable": {
146:       "artifactName": "ContextCraft-${version}-${arch}-portable.${ext}"
147:     },
148:     "linux": {
149:       "target": [
150:         "AppImage",
151:         "deb",
152:         "rpm"
153:       ],
154:       "category": "Development",
155:       "icon": "public/favicon.png"
156:     },
157:     "asar": true,
158:     "asarUnpack": [
159:       "node_modules/tree-sitter/**/*",
160:       "node_modules/tree-sitter-javascript/**/*",
161:       "node_modules/tree-sitter-typescript/**/*",
162:       "node_modules/tree-sitter-python/**/*",
163:       "node_modules/tree-sitter-css/**/*",
164:       "node_modules/tree-sitter-html/**/*",
165:       "node_modules/tiktoken/**/*",
166:       "node_modules/jsdom/**/*",
167:       "node_modules/chokidar/**/*",
168:       "node_modules/readdirp/**/*",
169:       "node_modules/node-gyp-build/**/*",
170:       "node_modules/nan/**/*"
171:     ],
172:     "publish": {
173:       "provider": "github",
174:       "releaseType": "draft"
175:     }
176:   },
177:   "devDependencies": {
178:     "@electron/notarize": "^3.0.1",
179:     "@electron/rebuild": "^3.7.1",
180:     "@testing-library/jest-dom": "^6.6.3",
181:     "@testing-library/react": "^16.2.0",
182:     "@types/css-modules": "^1.0.5",
183:     "@types/electron": "^1.4.38",
184:     "@types/jest": "^29.5.14",
185:     "@types/jsdom": "^21.1.7",
186:     "@types/node": "^20.10.5",
187:     "@types/prismjs": "^1.26.5",
188:     "@types/react": "^18.2.43",
189:     "@types/react-dom": "^18.2.17",
190:     "@typescript-eslint/eslint-plugin": "^6.14.0",
191:     "@typescript-eslint/parser": "^6.14.0",
192:     "@vitejs/plugin-react": "^4.2.1",
193:     "cross-env": "^7.0.3",
194:     "dotenv": "^16.5.0",
195:     "electron": "^34.3.0",
196:     "electron-builder": "^26.0.12",
197:     "eslint": "^8.55.0",
198:     "eslint-plugin-react-hooks": "^4.6.0",
199:     "eslint-plugin-react-refresh": "^0.4.5",
200:     "identity-obj-proxy": "^3.0.0",
201:     "jest": "^29.7.0",
202:     "jest-environment-jsdom": "^29.7.0",
203:     "jsdom": "^26.0.0",
204:     "ts-jest": "^29.2.6",
205:     "ts-node": "^10.9.2",
206:     "ts-prune": "^0.10.3",
207:     "typescript": "^5.3.3",
208:     "vite": "^5.0.8"
209:   },
210:   "dependencies": {
211:     "chokidar": "^3.5.3",
212:     "class-variance-authority": "^0.7.1",
213:     "clsx": "^2.1.1",
214:     "dompurify": "^3.2.4",
215:     "gpt-3-encoder": "^1.1.4",
216:     "ignore": "^7.0.3",
217:     "jsdom": "^26.0.0",
218:     "lucide-react": "^0.477.0",
219:     "micromatch": "^4.0.8",
220:     "minimatch": "^10.0.1",
221:     "prismjs": "^1.30.0",
222:     "react": "^18.2.0",
223:     "react-dom": "^18.2.0",
224:     "react-simple-code-editor": "^0.14.1",
225:     "sonner": "^2.0.3",
226:     "tiktoken": "^1.0.20",
227:     "tree-sitter": "^0.22.4",
228:     "tree-sitter-css": "0.23.2",
229:     "tree-sitter-html": "0.23.2",
230:     "tree-sitter-javascript": "0.23.1",
231:     "tree-sitter-python": "0.23.6",
232:     "tree-sitter-typescript": "0.23.2"
233:   },
234:   "overrides": {
235:     "esbuild": "^0.25.0",
236:     "vite": {
237:       "esbuild": "^0.25.0"
238:     },
239:     "@babel/helpers": "^7.26.10",
240:     "tree-sitter": "^0.22.4",
241:     "tree-sitter-html": {
242:       "tree-sitter": "^0.22.4"
243:     },
244:     "tree-sitter-css": {
245:       "tree-sitter": "^0.22.4"
246:     },
247:     "tree-sitter-javascript": {
248:       "tree-sitter": "^0.22.4"
249:     },
250:     "tree-sitter-python": {
251:       "tree-sitter": "^0.22.4"
252:     },
253:     "tree-sitter-typescript": {
254:       "tree-sitter": "^0.22.4"
255:     }
256:   }
257: }



================================================================
End of Codebase
================================================================
