#!/usr/bin/env node

/**
 * fix-tree-sitter-commandline.js
 * 
 * A focused script that directly addresses the command-line C++17 override issue in tree-sitter builds.
 * The specific problem is that even when /std:c++20 is properly set in binding.gyp and vcxproj files,
 * something in the build chain is appending /std:c++17 AFTER our C++20 flag, causing it to be overridden.
 * 
 * This script:
 * 1. Creates a high-priority MSBuild Directory.Build.props file to force C++20
 * 2. Generates a node-gyp wrapper script that filters out C++17 flags at the command-line level
 * 3. Ensures tree-sitter and related modules use C++20 regardless of their internal settings
 */

const fs = require('fs');
const path = require('path');
const os = require('os');
const { execSync, spawn } = require('child_process');

// Only applies to Windows
const isWindows = process.platform === 'win32';

// Logging with timestamps
function log(message) {
  console.log(`[${new Date().toISOString()}] ${message}`);
}

// Find all installed tree-sitter modules
function findTreeSitterModules() {
  const nodeModulesPath = path.resolve(process.cwd(), 'node_modules');
  if (!fs.existsSync(nodeModulesPath)) {
    log('No node_modules directory found.');
    return [];
  }
  
  const treeSitterPath = path.resolve(nodeModulesPath, 'tree-sitter');
  if (!fs.existsSync(treeSitterPath)) {
    log('No tree-sitter module found.');
    return [];
  }
  
  // Find all tree-sitter modules
  const modules = ['tree-sitter'];
  const dirs = fs.readdirSync(nodeModulesPath);
  
  for (const dir of dirs) {
    if (dir.startsWith('tree-sitter-') && 
        fs.existsSync(path.resolve(nodeModulesPath, dir, 'binding.gyp'))) {
      modules.push(dir);
    }
  }
  
  log(`Found ${modules.length} tree-sitter modules: ${modules.join(', ')}`);
  return modules;
}

// Create a Directory.Build.props file with highest MSBuild priority to force C++20
function createMsBuildProps(modulePath) {
  if (!isWindows) return false;
  
  const buildDir = path.resolve(modulePath, 'build');
  if (!fs.existsSync(buildDir)) {
    fs.mkdirSync(buildDir, { recursive: true });
    log(`Created build directory for ${path.basename(modulePath)}`);
  }
  
  const propsFile = path.resolve(buildDir, 'Directory.Build.props');
  const propsContent = `<?xml version="1.0" encoding="utf-8"?>
<!-- Generated by fix-tree-sitter-commandline.js -->
<Project>
  <ItemDefinitionGroup>
    <ClCompile>
      <!-- Force C++20 at highest MSBuild priority -->
      <LanguageStandard>stdcpp20</LanguageStandard>
      <!-- The additional options are appended AFTER other options -->
      <AdditionalOptions>/std:c++20 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  
  <!-- Remove any C++17 flag from command line -->
  <Target Name="RemoveCpp17Flag" 
          BeforeTargets="ClCompile">
    <ItemGroup>
      <ClCompile>
        <AdditionalOptions>$([System.String]::Copy('%(ClCompile.AdditionalOptions)').Replace('/std:c++17', ''))</AdditionalOptions>
      </ClCompile>
    </ItemGroup>
  </Target>
</Project>`;
  
  fs.writeFileSync(propsFile, propsContent);
  log(`Created MSBuild props file to force C++20 for ${path.basename(modulePath)}`);
  return true;
}

// Create node-gyp wrapper to intercept and modify CL.exe command line
function createNodeGypWrapper(modulePath) {
  if (!isWindows) return false;
  
  const buildDir = path.resolve(modulePath, 'build');
  if (!fs.existsSync(buildDir)) {
    fs.mkdirSync(buildDir, { recursive: true });
  }
  
  const wrapperScript = path.resolve(buildDir, 'cl-wrapper.js');
  const wrapperContent = `#!/usr/bin/env node

/**
 * cl-wrapper.js - Node.js script to wrap CL.exe and remove C++17 flags
 * 
 * This script is used as a wrapper around CL.exe to intercept and modify
 * the command line arguments before they're passed to the actual compiler.
 * It specifically removes /std:c++17 flags while preserving /std:c++20 flags.
 */

const { spawnSync } = require('child_process');
const fs = require('fs');
const path = require('path');

// The real CL.exe path
const originalArgs = process.argv.slice(2);
const clExePath = originalArgs[0];

// Log file for debugging
const logFile = path.resolve(__dirname, 'cl-wrapper.log');

// Function to log information
function logToFile(message) {
  fs.appendFileSync(logFile, \`[\${new Date().toISOString()}] \${message}\\n\`);
}

// Log the original command
logToFile('Original command: ' + process.argv.join(' '));

// Filter out C++17 flags but keep C++20 flags
const filteredArgs = originalArgs.map(arg => {
  if (arg === '/std:c++17' || arg === '-std:c++17') {
    logToFile(\`Removed flag: \${arg}\`);
    return null; // Will be filtered out
  }
  return arg;
}).filter(Boolean);

// Ensure we have C++20 flag somewhere
let hasCpp20Flag = filteredArgs.some(arg => 
  arg === '/std:c++20' || arg === '-std:c++20');

if (!hasCpp20Flag) {
  // Add C++20 flag - important to add it early in the command line
  // Find position after first few arguments (typically the compiler path and output options)
  const insertPos = Math.min(3, filteredArgs.length);
  filteredArgs.splice(insertPos, 0, '/std:c++20');
  logToFile('Added missing C++20 flag at position ' + insertPos);
}

// Log the modified command
logToFile('Modified command: ' + [process.execPath, ...filteredArgs].join(' '));

// Run the actual compiler with modified arguments
const result = spawnSync(clExePath, filteredArgs.slice(1), { 
  stdio: 'inherit',
  shell: true
});

// Exit with the same code as the compiler
process.exit(result.status);
`;
  
  fs.writeFileSync(wrapperScript, wrapperContent);
  log(`Created CL.exe wrapper script for ${path.basename(modulePath)}`);
  return true;
}

// Patch a binding.gyp file to use C++20 and our CL wrapper
function patchBindingGyp(modulePath) {
  if (!isWindows) return false;
  
  const bindingGypPath = path.resolve(modulePath, 'binding.gyp');
  if (!fs.existsSync(bindingGypPath)) {
    log(`No binding.gyp found for ${path.basename(modulePath)}`);
    return false;
  }
  
  try {
    // Read the binding.gyp file
    let content = fs.readFileSync(bindingGypPath, 'utf8');
    const originalContent = content;
    
    // Check if we're already patched to use our wrapper
    if (content.includes('cl-wrapper.js')) {
      log(`binding.gyp already patched for ${path.basename(modulePath)}`);
      return false;
    }
    
    // First, try to parse the JSON (with relaxed syntax)
    let bindingConfig;
    try {
      // Convert to proper JSON by replacing single quotes and removing trailing commas
      const jsonContent = content
        .replace(/'/g, '"')
        .replace(/,\s*([}\]])/g, '$1');
      
      bindingConfig = JSON.parse(jsonContent);
      
      // Add our wrapper to the configuration
      if (bindingConfig && bindingConfig.targets && bindingConfig.targets.length > 0) {
        // For each target, add our command wrapper
        bindingConfig.targets.forEach(target => {
          if (!target.conditions) {
            target.conditions = [];
          }
          
          // Find Windows condition or add one
          let winConditionFound = false;
          for (let i = 0; i < target.conditions.length; i++) {
            const condition = target.conditions[i];
            if (Array.isArray(condition) && condition[0] && condition[0].includes('OS=="win"')) {
              winConditionFound = true;
              
              // Add wrapper to this condition
              const winConfig = condition[1];
              if (!winConfig.msbuild_settings) {
                winConfig.msbuild_settings = {};
              }
              if (!winConfig.msbuild_settings.ClCompile) {
                winConfig.msbuild_settings.ClCompile = {};
              }
              
              // Force C++20
              winConfig.msbuild_settings.ClCompile.LanguageStandard = 'stdcpp20';
              
              // Set wrapper
              if (!winConfig.msbuild_toolset_dirs) {
                winConfig.msbuild_toolset_dirs = {};
              }
              winConfig.msbuild_toolset_dirs.ClCompile = 'build/cl-wrapper.js';
            }
          }
          
          // Add Windows condition if not found
          if (!winConditionFound) {
            target.conditions.push([
              'OS=="win"', 
              {
                'msbuild_settings': {
                  'ClCompile': {
                    'LanguageStandard': 'stdcpp20'
                  }
                },
                'msbuild_toolset_dirs': {
                  'ClCompile': 'build/cl-wrapper.js'
                }
              }
            ]);
          }
        });
        
        // Convert back to string with appropriate formatting
        let newContent = JSON.stringify(bindingConfig, null, 2)
          .replace(/"ClCompile":/g, '"ClCompile":')
          .replace(/"LanguageStandard":/g, '"LanguageStandard":');
        
        // Write back to file
        fs.writeFileSync(bindingGypPath, newContent);
        log(`Successfully patched binding.gyp for ${path.basename(modulePath)}`);
        return true;
      }
    } catch (parseError) {
      // JSON parsing failed, fall back to string replacement
      log(`JSON parsing failed for ${path.basename(modulePath)}, using string replacement`);
      
      // Add C++20 language standard using string replacement
      if (!content.includes('"LanguageStandard": "stdcpp20"')) {
        if (content.includes('msbuild_settings')) {
          // Update existing msbuild_settings
          if (content.includes('ClCompile')) {
            if (content.includes('LanguageStandard')) {
              // Replace existing language standard
              content = content.replace(
                /"LanguageStandard"\s*:\s*"stdcpp\d+"/g, 
                '"LanguageStandard": "stdcpp20"'
              );
            } else {
              // Add language standard to existing ClCompile
              content = content.replace(
                /"ClCompile"\s*:\s*{/g,
                '"ClCompile": {\n            "LanguageStandard": "stdcpp20",'
              );
            }
          }
        }
      }
      
      // Write modified content if changed
      if (content !== originalContent) {
        fs.writeFileSync(bindingGypPath, content);
        log(`Patched binding.gyp with string replacement for ${path.basename(modulePath)}`);
        return true;
      }
    }
  } catch (error) {
    log(`Error patching binding.gyp for ${path.basename(modulePath)}: ${error.message}`);
  }
  
  return false;
}

// Create a package.json patch for tree-sitter modules
function createPackagePatch(modulePath) {
  const packagePath = path.resolve(modulePath, 'package.json');
  if (!fs.existsSync(packagePath)) {
    return false;
  }
  
  try {
    const packageJson = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
    
    // Add C++20 flags to package.json scripts
    if (!packageJson.scripts) {
      packageJson.scripts = {};
    }
    
    // Add a special install script that sets C++20 flags
    packageJson.scripts['install'] = isWindows 
      ? 'node-gyp rebuild --msvs_version=2022 --verbose'
      : 'node-gyp rebuild --verbose';
    
    // Add environment variables to enforce C++20
    if (!packageJson.config) {
      packageJson.config = {};
    }
    
    packageJson.config.msvs_version = '2022';
    packageJson.config.node_gyp_force_unsupported_msvs_version = 'true';
    
    // Write updated package.json
    fs.writeFileSync(packagePath, JSON.stringify(packageJson, null, 2));
    log(`Updated package.json for ${path.basename(modulePath)}`);
    return true;
  } catch (error) {
    log(`Error updating package.json for ${path.basename(modulePath)}: ${error.message}`);
    return false;
  }
}

// Main function
async function main() {
  if (!isWindows) {
    log('This script is only needed on Windows. Exiting.');
    return;
  }
  
  log('Starting fix-tree-sitter-commandline.js');
  
  // Find tree-sitter modules
  const modules = findTreeSitterModules();
  
  if (modules.length === 0) {
    log('No tree-sitter modules found.');
    return;
  }
  
  // Process each module
  for (const moduleName of modules) {
    const modulePath = path.resolve(process.cwd(), 'node_modules', moduleName);
    log(`Processing ${moduleName}`);
    
    // 1. Create MSBuild props file to force C++20
    createMsBuildProps(modulePath);
    
    // 2. Create CL.exe wrapper to intercept command line
    createNodeGypWrapper(modulePath);
    
    // 3. Patch binding.gyp to use our wrapper
    patchBindingGyp(modulePath);
    
    // 4. Patch package.json if needed
    createPackagePatch(modulePath);
  }
  
  log('Tree-sitter command line fix completed!');
}

// Run the main function
main().catch(err => {
  log(`Error: ${err.message}`);
  process.exit(1);
}); 